<html><head><title>Java Speech Grammar Format</title></head>
<!--Intermediate split file from a FrameMaker file-->
<body BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#990000" ALINK="#333399" VLINK="#333399">
<!--#include virtual="/products/java-media/include/speechGlobal.html"-->


<table align="center" CELLSPACING=20 CELLPADDING=6 bgcolor="#f0f0ff">
<tr>
<td><code>
<a href="index.html">Contents</a>
</code>
<td><code>
<a href="Contrib.html">Previous</a>  </code>
<td><code>
&nbsp;&nbsp;<a href="">Next</a>&nbsp;&nbsp;  </code>
</table>


<blockquote>

<a name="18109"></a><p>

</p><a name="18520"></a><hr size=7 noshade>
<h1 align="right"><font size="+4">
Java Speech Grammar Format 
Specification

<BR>&nbsp;
</font></h1>
<P>&nbsp;</P>
<hr width="30%" align="center" noshade>
<P>&nbsp;</P>
<a name="11803"></a><h2>1.	 Introduction </h2>
<a name="14175"></a><p>
Speech recognition systems provide computers with the ability to listen to user 
speech and determine what is said. Current technology does not yet support 
<em>unconstrained</em> speech recognition: the ability to listen to any speech in any 
context and transcribe it accurately. To achieve reasonable recognition accuracy 
and response time, current speech recognizers constrain what they listen for by 
using <em>grammars</em>. 
</p><a name="18099"></a><p>
The <em>Java<SUP>TM</SUP> Speech Grammar Format</em> (JSGF) defines a platform-independent, 
vendor-independent way of describing one type of grammar, a <em>rule grammar</em> (also 
known as a <em>command and control</em> grammar or <em>regular grammar</em>). It uses a textual 
representation that is readable and editable by both developers and computers, and 
can be included in Java source code. The other major grammar type, the <em>dictation 
grammar</em>, is not discussed in this document.
</p><a name="18087"></a><p>
A rule grammar specifies the types of <em>utterances</em> a user might say (a spoken 
utterance is similar to a written sentence). For example, a simple window control 
grammar might listen for "open a file", "close the window", and similar 
commands.
</p><a name="17245"></a><p>
What the user can say depends upon the context: is the user controlling an email 
application, reading a credit card number, or selecting a font? Applications know 
the context, so applications are responsible for providing a speech recognizer with 
appropriate grammars.
</p><a name="18037"></a><p>
This document is the specification for the Java Speech Grammar Format. First, the 
basic naming and structural mechanisms are described. Following that, the basic 
components of the grammar, the <em>grammar header</em> and the <em>grammar body</em>, are 
described. The grammar header declares the <em>grammar name</em> and lists the 
<em>imported</em> rules and grammars. The grammar body defines the <em>rules</em> of this 
grammar as combinations of speakable text and references to other rules. Finally, 
some simple examples of grammar declarations are provided.
</p>
<a name="16281"></a><h3>1.1	 Related Documentation</h3>
<a name="17286"></a><p>
The following is a list of related documentation that may be helpful in 
understanding and using the Java Speech Grammar Format.
</p><a name="17289"></a><p>
The Java Speech Grammar Format has been developed for use with recognizers 
that implement the Java Speech API. However, it may also be used by other 
speech recognizers and in other types of applications.
</p><a name="16289"></a><p>
Readers interested in the programmatic use of the Java Speech Grammar Format 
with the <a http://java.sun.com/products/java-media/speech/>Java Speech API</a> are referred to the technical documentation and the 
Programmers Guide for the API. Among other issues, those documents define the 
mechanisms for loading grammars into recognizers, methods for controlling and 
modifying loaded grammars, error handling and so on.
</p><a name="16293"></a><p>
The Java Speech Grammar Format adopts some of the style and conventions of 
the Java Programming Language. Readers interested in a comprehensive 
specification are referred to <em>The Java Language Specification</em>, Gosling, Joy and 
Steele, Addison Wesley, 1996 (GJS96).
</p><a name="16300"></a><p>
Finally, like the Java Programming Language, grammars in the Java Speech 
Grammar Format may be written with the Unicode character set, as defined in <em>The 
Unicode Standard, Version 2.0</em>, The Unicode Consortium, Addison-Wesley 
Developers Press, 1996 (Uni96).
</p><P>&nbsp;</P>
<hr width="30%" align="center" noshade>
<P>&nbsp;</P>
<a name="16447"></a><h2>2.	 Definitions </h2>

<a name="16562"></a><h3>2.1	 Grammar Names and Package Names</h3>
<a name="16756"></a><p>
Each grammar defined by Java Speech Grammar Format has a unique name that 
is declared in the grammar header. Legal structures for grammar names are:
</p><DL><DD><pre>
<a name="16757"></a><code><EM>packageName.simpleGrammarName</EM></code> 
<a name="18651"></a><code><EM>grammarName</EM></code> 
</pre></DL>
<a name="16564"></a><p>
The first form (package name + simple grammar name) is a <em>full grammar name</em>. 
The second form is a <em>simple grammar name</em> (grammar name only). Examples of 
full grammar names and simple grammar names include:
</p><DL><DD><pre>
<a name="16565"></a>com.sun.speech.apps.numbers
<a name="16566"></a>edu.unsw.med.people
<a name="16567"></a>examples
</pre></DL>
<a name="16571"></a><p>
The package name and grammar name have the same format as packages and 
classes in the Java programming language. A full grammar name is a dot-
separated list of <em>Java identifiers</em><a href="jsgf.html#17364"><sup>1</sup></a> (see GJS96, &#167;3.8 and &#167;6.5).
</p><a name="17340"></a><p>
The grammar naming convention also follows the naming convention for classes 
in the Java Programming Language (see GJS96). The convention minimizes the 
chance of naming conflicts. The package name should be:
</p><DL><DD><pre>
<a name="16572"></a><code><EM>reversedDomainName</EM></code>.<code><EM>localPackaging
</EM></code></pre></DL>
<a name="16573"></a><p>
For example, for <code>com.sun.speech.apps.numbers</code>, the <code>com.sun</code> part is Sun's 
reversed Internet domain name, <code>speech.apps</code> is the local package name for 
Sun-wide division of the name space, and <code>numbers</code> is the simple grammar name.
</p>
<a name="16587"></a><h3>2.2	 Rulenames</h3>
<a name="16674"></a><p>
A grammar is composed of a set of rules that together define what may be spoken. 
Rules are combinations of speakable text and references to other rules. Each rule 
has a unique <em>rulename</em>. A reference to a rule is represented by the rule's name in 
surrounding &lt;&gt; characters (less-than and greater-than).
</p><a name="16692"></a><p>
A legal rulename is similar to a Java identifier but allows additional extra 
symbols. A legal rulename is an unlimited-length sequence of Unicode characters 
matching the following<a href="jsgf.html#19190"><sup>2</sup></a>:
</p><ul><li><a name="17376"></a>Characters matching <code>java.lang.Character.isJavaIdentifierPart
</code> including the Unicode letters and numbers plus other symbols.
</ul>

<!-- <li><a name="17376"></a>Characters matching <code>java.lang.Character.isJavaIdentifierPart
</code> including the Unicode letters and numbers plus other symbols.
 --><ul><li><a name="17386"></a>The following additional punctuation symbols:<br>
+ - : ; , = | / \ ( ) [ ] @ # % ! ^ &amp; ~
</ul>

<!-- <li><a name="17386"></a>The following additional punctuation symbols:<br>
+ - : ; , = | / \ ( ) [ ] @ # % ! ^ &amp; ~
 --><a name="17425"></a><p>
Grammar developers should be aware of two specific constraints. First, rulenames 
are compared with exact Unicode string matches, so case is significant. For 
example, <code>&lt;Name&gt;</code>, <code>&lt;NAME&gt;</code> and <code>&lt;name&gt;</code> are different. Second, whitespace<a href="jsgf.html#19180"><sup>3</sup></a> is not 
permitted in rulenames.
</p><a name="19469"></a><p>
The rulenames <code>&lt;NULL&gt;</code> and <code>&lt;VOID&gt;</code> are reserved. These special rules are 
discussed later in this section.
</p><a name="16596"></a><p>
The Unicode character set includes most writing scripts from the world's living 
languages, so rulenames can be written in Chinese, Japanese, Korean, Thai, 
Arabic, European languages, and many more. The following are examples of 
rulenames.
</p><DL><DD><pre>
<a name="16598"></a>&lt;hello&gt;
<a name="16599"></a>&lt;Z&uuml;rich&gt;
<a name="17436"></a>&lt;user_test&gt;
<a name="17438"></a>&lt;$100&gt;
<a name="17408"></a>&lt;1+2=3&gt;
<a name="16601"></a>&lt;<img src="./pi.gif" width="13" height="12"><img src="./alpha.gif" width="14" height="13"><img src="./beta.gif" width="11" height="15">&gt;
</pre></DL>

<a name="16602"></a><h4>2.2.1	 Qualified and Fully-Qualified Names</h4>
<a name="16603"></a><p>
Although rulenames are unique within a grammar, separate grammars may reuse 
the same simple rulename. A later section introduces the <code>import</code> statement, 
which allows one grammar to reference rules from another grammar. When two 
grammars use the same rulename, a reference to that rulename may be 
ambiguous. <em>Qualified names</em> and <em>fully-qualified names</em> are used to reference 
between grammars without ambiguity.
</p><a name="16737"></a><p>
A fully-qualified rulename includes the <em>full grammar name</em> and the simple 
<em>rulename</em>. For example:
</p><DL><DD><pre>
<a name="16604"></a>&lt;com.sun.greetings.english.hello&gt;
<a name="16768"></a>&lt;com.sun.greetings.deutsch.gutenTag&gt;
</pre></DL>
<a name="16777"></a><p>
A qualified rulename includes only the <em>simple grammar name</em> and the <em>rulename</em> 
and is a useful shorthand representation. For example:
</p><DL><DD><pre>
<a name="16798"></a>&lt;english.hello&gt;
<a name="16800"></a>&lt;deutsch.gutenTag&gt;
</pre></DL>
<a name="16775"></a><p>
The following conditions apply to the use of rulenames:
</p><ul><li><a name="16716"></a>Qualified and fully-qualified rulenames may not be used on the left side of 
the definition of a rule.
</ul>

<!-- <li><a name="16716"></a>Qualified and fully-qualified rulenames may not be used on the left side of 
the definition of a rule.
 --><ul><li><a name="16723"></a>Import statements must use fully-qualified rulenames.
</ul>

<!-- <li><a name="16723"></a>Import statements must use fully-qualified rulenames.
 --><ul><li><a name="21607"></a>Local rules can be referenced by qualified and fully-qualified names using 
the form <code>&lt;</code><code><EM>localGrammarName.ruleName</EM></code><code>&gt;</code>.
</ul>

<!-- <li><a name="21607"></a>Local rules can be referenced by qualified and fully-qualified names using 
the form <code>&lt;</code><code><EM>localGrammarName.ruleName</EM></code><code>&gt;</code>.
 -->
<a name="21609"></a><h4>2.2.2	 Resolving Rulenames</h4>
<a name="21610"></a><p>
It is an error to use an ambiguous reference to a rulename. The following defines 
behavior for resolving references:
</p><ul><li><a name="17475"></a>Local rules have precedence. If a local rule and one or more imported rules 
have the same name, <code>&lt;</code><code><EM>ruleName</EM></code><code>&gt;</code>, then a simple rule reference to <code>&lt;</code><code><EM>ruleName
</EM></code><code>&gt;</code> is a reference to the local rule.
</ul>

<!-- <li><a name="17475"></a>Local rules have precedence. If a local rule and one or more imported rules 
have the same name, <code>&lt;</code><code><EM>ruleName</EM></code><code>&gt;</code>, then a simple rule reference to <code>&lt;</code><code><EM>ruleName
</EM></code><code>&gt;</code> is a reference to the local rule.
 --><ul><li><a name="17488"></a>If two or more imported rules have the same name, <code>&lt;</code><code><EM>ruleName</EM></code><code>&gt;</code>, but there 
is no local rule of the same name, then a simple rule reference to <code>&lt;</code><code><EM>ruleName
</EM></code><code>&gt;</code> is ambiguous and is an error. To resolve this ambiguity these imported
rules must be referred to by their qualified or fully-qualified names.
</ul>

<!-- <li><a name="17488"></a>If two or more imported rules have the same name, <code>&lt;</code><code><EM>ruleName</EM></code><code>&gt;</code>, but there 
is no local rule of the same name, then a simple rule reference to <code>&lt;</code><code><EM>ruleName
</EM></code><code>&gt;</code> is ambiguous and is an error. To resolve this ambiguity these imported
rules must be referred to by their qualified or fully-qualified names.
 --><ul><li><a name="19226"></a>If two or more imported rules have the same name and come from grammars
with the same simple grammar name (but necessarily different package
names), then a simple rule reference or qualified rule reference is 
ambiguous and is an error. These imported rules must be referred to by 
their fully-qualified names.
</ul>

<!-- <li><a name="19226"></a>If two or more imported rules have the same name and come from grammars
with the same simple grammar name (but necessarily different package
names), then a simple rule reference or qualified rule reference is 
ambiguous and is an error. These imported rules must be referred to by 
their fully-qualified names.
 --><ul><li><a name="17497"></a>A reference by a fully-qualified rulename is never ambiguous.
</ul>

<!-- <li><a name="17497"></a>A reference by a fully-qualified rulename is never ambiguous.
 --><a name="19477"></a><p>
When a rulename reference cannot be resolved (not defined locally and not a 
public rule of an imported grammar), the handling of the reference is defined by 
the recognizer's software interface<a href="jsgf.html#19540"><sup>4</sup></a>.
</p>
<a name="19472"></a><h4>2.2.3	 Special Rulenames</h4>
<a name="19484"></a>The Java Speech Grammar Format defines two special rules, <code>&lt;NULL&gt;</code> and 
<code>&lt;VOID&gt;</code>. These rules are universally defined - they are available in any grammar 
without an explicit import statement - and they cannot be redefined. Both names 
are fully-qualified so no qualifying grammar name is required.
<p><a name="19508"></a><p>
<code>&lt;NULL&gt;</code> defines a rule that is automatically matched: that is, matched without the 
user speaking any word.
</p><a name="20893"></a><p>
<code>&lt;VOID&gt;</code> defines a rule that can never be spoken. Inserting <code>&lt;VOID&gt;</code> into a sequence 
automatically makes that sequence unspeakable<a href="jsgf.html#20057"><sup>5</sup></a>.
</p><a name="19525"></a><p>
The <code>&lt;NULL&gt;</code> and <code>&lt;VOID&gt;</code> rules are typically used in specialized circumstances. 
They can be used to block and enable parts of grammars, to control recursion, and 
to perform other advanced tasks. The <a href="jsgf.html#20689"><em>Uses of </em><em>&lt;NULL&gt; and &lt;VOID&gt;</em></a> are 
described later in this document.
</p>
<a name="16890"></a><h3>2.3	 Tokens</h3>
<a name="17523"></a><p>
A <em>token</em>, sometimes called a <em>terminal symbol</em>, is the part of a grammar that defines 
what may be spoken by a user. Most often, a token is equivalent to a <em>word</em>. Tokens 
may appear in isolation, for example,
</p><DL><DD><pre>
<a name="16892"></a>hello
<a name="17533"></a>konnichiwa
</pre></DL>
<a name="20899"></a><p>
or as sequences of tokens separated by whitespace characters, for example,
</p><DL><DD><pre>
<a name="20902"></a>this is a test
<a name="16893"></a>open the directory
</pre></DL>
<a name="16894"></a><p>
In Java Speech Grammar Format, a token is a character sequence bounded by 
whitespace, by quotes or delimited by the other symbols that are significant in the 
grammar:
</p><DL><DD><pre>
<a name="18149"></a>; = | * + &lt;&gt; () [] {} /* */ //
</pre></DL>
<a name="17576"></a><p>
A token is a reference to an entry in a <em>recognizer's vocabulary</em>, often referred to as 
the <em>lexicon</em>. The recognizer's vocabulary defines the <em>pronunciation</em> of the token. 
With the pronunciation, the recognizer is able to listen for that token.
</p><a name="18040"></a><p>
The Java Speech Grammar Format allows <em>multi-lingual</em> grammars, that is, 
grammars that include tokens from more than one language. However, most 
recognizers operate <em>mono-lingually</em> so a typical grammar will contain only one 
language. It is the responsibility of the application that loads a grammar into a 
recognizer to ensure that it has appropriate language support. As an example, the 
following is a simple multi-lingual rule.
</p><DL><DD><pre>
<a name="19560"></a>&lt;no&gt; = no | nein | nao | non | nem;
</pre></DL>
<a name="17538"></a><p>
Most recognizers have a comprehensive vocabulary for each language they 
support. However, it is never possible to include 100% of a language. For 
example, names, technical terms and foreign words are often missing from the 
vocabulary. For tokens missing from the vocabulary, there are three possibilities:
</p><ul><li><a name="17548"></a>An application or user can add the token and pronunciation to the recognizer's
vocabulary to ensure consistent recognition.
</ul>

<!-- <li><a name="17548"></a>An application or user can add the token and pronunciation to the recognizer's
vocabulary to ensure consistent recognition.
 --><ul><li><a name="17555"></a>Good recognizers are able to guess the pronunciation of many words not in 
the vocabulary.
</ul>

<!-- <li><a name="17555"></a>Good recognizers are able to guess the pronunciation of many words not in 
the vocabulary.
 --><ul><li><a name="19574"></a>If neither of the previous points apply, the behavior is determined by the 
software interface of the recognizer. In most cases, an undefined token will 
be unspeakable (equivalent to <code>&lt;VOID&gt;</code>), or it will cause an error or exception.
For the Java Speech API, undefined tokens are unspeakable.
</ul>

<!-- <li><a name="19574"></a>If neither of the previous points apply, the behavior is determined by the 
software interface of the recognizer. In most cases, an undefined token will 
be unspeakable (equivalent to <code>&lt;VOID&gt;</code>), or it will cause an error or exception.
For the Java Speech API, undefined tokens are unspeakable.
 --><a name="19576"></a><p>
Tokens do not need to be normal written words of a language, assuming that the 
token is properly defined in the recognizers vocabulary. For example, to handle 
the two pronunciations of "read" (past tense sounds like "red", present tense 
sounds like "reed") an application could define two separate tokens "read_past" 
and "read_present" with appropriate pronunciations.
</p>
<a name="16895"></a><h4>2.3.1	 Quoted Tokens</h4>
<a name="17573"></a><p>
A token does not need to be a word. A token may be a sequence of words or a 
symbol. Quotes can be used to surround multi-word tokens and special symbols. 
For example:
</p><DL><DD><pre>
<a name="17586"></a>the "New York" subway
<a name="17592"></a>"+"
</pre></DL>
<a name="18525"></a><p>
A multi-word token is useful when the pronunciation of words varies because of 
the context. Multi-word tokens can also be used to simplify the processing of 
results, for example, getting single-token results for "New York", "Sydney" and 
"Rio de Janeiro."
</p><a name="18526"></a><p>
Quoted tokens can be included in the recognizer's vocabulary like any other 
token. If a multi-word quoted token is not found in the vocabulary, then the 
default behavior is to determine the pronunciation of each space-separated token 
within the quotes, but otherwise treat the text within quotes as a single token.
</p><a name="19586"></a><p>
To include a quote symbol in a token, surrounding quotes must be used and the 
quote within the token must be preceded by a backslash `\'. Similarly, to include a 
backslash in a quoted token, it should be preceded by another backslash. For 
example, the following are two tokens representing a single backslash and a 
single quote character.
</p><DL><DD><pre>
<a name="19593"></a>"\\" "\""
</pre></DL>
<a name="19585"></a><p>
White space is significant in quoted tokens.
</p>
<a name="17597"></a><h4>2.3.2	 Symbols and Punctuation</h4>
<a name="17602"></a><p>
Most speech recognizers provide the ability to handle common symbols and 
punctuation forms. For example, recognizers for English usually handle 
apostrophes ("Mary's", "it's") and hyphens ("new-age"). 
</p><a name="17570"></a><p>
There are, however, many textual forms that are difficult for a recognizer to 
handle unambiguously. In these instances, a grammar developer should use tokens 
that are as close as possible to the way people will speak and that are likely to be 
built into the vocabulary. The following are common examples.
</p><ul><li><a name="16896"></a>Numbers: "0 1 2" should be expanded to "zero one two" or "oh one two". 
Similarly, "call 555 1234" should be expanded to "call five five five one 
two three four."
</ul>

<!-- <li><a name="16896"></a>Numbers: "0 1 2" should be expanded to "zero one two" or "oh one two". 
Similarly, "call 555 1234" should be expanded to "call five five five one 
two three four."
 --><ul><li><a name="16897"></a>Dates: "Dec 25, 1997" should be written as "December twenty fifth nineteen
ninety seven."
</ul>

<!-- <li><a name="16897"></a>Dates: "Dec 25, 1997" should be written as "December twenty fifth nineteen
ninety seven."
 --><ul><li><a name="19604"></a>Abbreviations and acronyms: "Mr." should be written as "mister", and "St" 
should be written as "street".
</ul>

<!-- <li><a name="19604"></a>Abbreviations and acronyms: "Mr." should be written as "mister", and "St" 
should be written as "street".
 --><ul><li><a name="16898"></a>Special symbols: `&amp;' as "ampersand" or "and", `+' as "plus", and so on.
</ul>

<!-- <li><a name="16898"></a>Special symbols: `&amp;' as "ampersand" or "and", `+' as "plus", and so on.
 -->
<a name="16628"></a><h3>2.4	 Comments</h3>
<a name="16629"></a><p>
Comments may appear in both the header and body. The comment style of the 
Java Programming Language is adopted (see GJS96). There are two forms of 
comment.<Table Border="3" CELLSPACING=5 CELLPADDING=6 align="center" bgcolor="#f0f0f0">
<caption></caption>
<tr><td><a name="18530"></a>/* text */ 

&nbsp;<td><a name="18532"></a>A traditional comment. All text between /* and */ is 
ignored.

&nbsp;
<tr><td><a name="18534"></a>// text 

&nbsp;<td><a name="18536"></a>A single-line comment. All the text from // to the end of a 
line is ignored.

&nbsp;

</Table>

<Table>
<tr><td>
</Table>

</p><a name="16632"></a><p>
Comments do not nest. Furthermore, <code>//</code> has no special meaning within comments 
beginning with <code>/*</code>. Similarly, <code>/*</code> has no special meaning within comments 
beginning with <code>//</code>. 
</p><a name="17633"></a><p>
Comments may appear anywhere in a grammar definition except within tokens, 
quoted tokens, rulenames, tags and weights.
</p><a name="19686"></a><p>
The Java Speech Grammar Format supports <em>documentation comments</em> with a 
similar style to the documentation comments of the Java Programming Language 
(GJS96, &#167;18). These special comments are defined in the section on 
<a href="jsgf.html#19654"><em>Documentation Comments</em></a>.
</p><P>&nbsp;</P>
<hr width="30%" align="center" noshade>
<P>&nbsp;</P>
<a name="16559"></a><h2>3.	 Grammar Header </h2>
<a name="17636"></a><p>
A single file defines a single grammar. The definition grammar contains two parts: 
the <em>grammar header</em> and the <em>grammar body</em>. The grammar header includes a self-
identifying header, declares the name of the grammar and declares imports of 
rules from other grammars. The body defines the rules of the grammar, some of 
which may be public.
</p>
<a name="20955"></a><h3>3.1	 Self-Identifying Header</h3>
<a name="20960"></a>A Java Speech Grammar Format document starts with a self-identifying header. 
This header identifies that the document contains JSGF and indicates the version 
of JSGF being used (currently "V1.0"). Next, the header optionally specifies the 
character encoding used in the document. The header may also optionally specify 
the locale of the grammar specified in the document. The locale<a href="jsgf.html#22078"><sup>6</sup></a> specifies the 
language and optionally the country or regional variant that the grammar 
supports. The header is terminated by a semi-colon character and a newline 
character.
<p><a name="22068"></a><p>
The header format is:
</p><DL><DD><pre>
<a name="20982"></a>#JSGF version char-encoding locale;
</pre></DL>
<a name="21009"></a><p>
The following are examples of self-identifying headers.
</p><DL><DD><pre>
<a name="21025"></a>#JSGF V1.0;
<a name="21034"></a>#JSGF V1.0 ISO8859-5;
<a name="21029"></a>#JSGF V1.0 JIS ja;
</pre></DL>
<a name="20989"></a><p>
The first example does not provide a character encoding or locale, so a reasonable 
default would be assumed. In the US, the default might be ISO8859-1 (a standard 
character set) and "en" (the symbol for English). The second example defines the 
ISO8859-5 set (Cyrillic) but the default locale is assumed. The final example 
defines the "JIS" character set (one of the Japanese character sets) and defines the 
language as "ja" (Japanese).
</p><a name="21030"></a><p>
The Java platform handles a very wide range of character sets which are converted 
internally to the Unicode character set. When using the Unicode character set, 
JSGF is suited to writing grammars for nearly all modern languages.
</p><a name="21046"></a><p>
The hash character (`#') must be the first character in the document and all 
characters in the self-identifying header must be in the ASCII subset of the 
encoding being used.
</p>
<a name="20957"></a><h3>3.2	 Grammar Name Declaration</h3>
<a name="16457"></a><p>
The grammar's name must be declared as the first statement of that grammar. The 
declaration must use the full grammar name (package name + simple grammar 
name). Thus, the declaration format is either of the following:
</p><DL><DD><pre>
<a name="16666"></a>grammar <code><EM>packageName.simpleGrammarName</EM></code>;
<a name="16668"></a>grammar <code><EM>grammarName</EM></code>;
</pre></DL>
<a name="16543"></a><p>
The naming of packages and grammars is described in the section on <a href="jsgf.html#16562"><em>Grammar 
Names and Package Names</em></a>.
</p><a name="18561"></a><p>
For example:
</p><DL><DD><pre>
<a name="18562"></a>grammar com.sun.speech.apps.numbers;
<a name="18563"></a>grammar edu.unsw.med.people;
<a name="16553"></a>grammar examples;
</pre></DL>

<a name="16460"></a><h3>3.3	 Import</h3>
<a name="16461"></a><p>
The grammar header can optionally include <em>import</em> declarations. The import 
declarations follow the grammar declaration and must come before the grammar 
body (the rule definitions). An import declaration allows one or all of the public 
rules of another grammar to be referenced locally. The format of the import 
statement is one of the following
</p><DL><DD><pre>
<a name="17718"></a>import &lt;<code><EM>fullyQualifiedRuleName</EM></code>&gt;;
<a name="17720"></a>import &lt;<code><EM>fullGrammarName</EM></code>.*&gt;;
</pre></DL>
<a name="17712"></a><p>
For example,
</p><DL><DD><pre>
<a name="17691"></a>import &lt;com.sun.speech.app.index.1stTo31st&gt;;
<a name="16463"></a>import &lt;com.sun.speech.app.numbers.*&gt;;
</pre></DL>
<a name="16465"></a><p>
The first example is an import of a single rule by its fully-qualified rulename: the 
rule <code>&lt;1stTo31st&gt;</code> from the grammar <code>com.sun.speech.app.index</code>. The 
imported rule, <code>&lt;1stTo31st&gt;</code>, must be a public rule of the imported grammar.
</p><a name="17698"></a><p>
The use of the asterisk in the second import statement requests the import of all 
public rules of the <code>numbers</code> grammar. For example, if that grammar defines three 
public rules, <code>&lt;digits&gt;</code>, <code>&lt;teens&gt;</code>, <code>&lt;zeroToMillion&gt;,</code> then all three may be 
referenced locally.
</p><a name="20048"></a><p>
Note that because both a grammar name and a rulename or asterisk are required, 
the import statement is never of the form:
</p><DL><DD><pre>
<a name="20051"></a>import &lt;ruleName&gt;; // not legal
</pre></DL>
<a name="17735"></a><p>
An imported rule can be referenced in three ways: by its simple rulename (e.g. 
<code>&lt;digits&gt;</code>), by its qualified rulename (e.g. <code>&lt;numbers.digits&gt;</code>), or by its fully-
qualified rulename (<code>&lt;com.sun.speech.apps.numbers.digits&gt;</code>).
</p><a name="16467"></a><p>
The name resolving behavior is defined earlier in this document in <a href="jsgf.html#21609"><em>Resolving 
Rulenames</em></a>. Note that an import statement is optional when an imported rule is 
always referenced by its fully-qualified rulename.
</p><DL><DD><pre>
<a name="21539"></a>// Importing com.sun.speech.app.numbers is optional
<a name="21556"></a>&lt;rule&gt; = &lt;com.sun.speech.app.numbers.digits&gt;;
</pre></DL>
<P>&nbsp;</P>
<hr width="30%" align="center" noshade>
<P>&nbsp;</P>
<a name="14185"></a><h2>4.	 Grammar Body </h2>
<a name="20071"></a>
4.0.1	 Rule Definitions
<p><a name="19048"></a><p>
The grammar body defines <em>rules</em>. Each rule is defined in a <em>rule definition</em>. A rule is 
defined once in a grammar. The order of definition of rules is not significant<a href="jsgf.html#20085"><sup>7</sup></a>.
</p><a name="15285"></a><p>
The two patterns for rule definitions are:
</p><DL><DD><pre>
<a name="14031"></a>&lt;<code><EM>ruleName</EM></code>&gt; = <code><EM>ruleExpansion</EM></code> ;
<a name="15701"></a>public &lt;<code><EM>ruleName</EM></code>&gt; = <code><EM>ruleExpansion</EM></code> ;
</pre></DL>
<a name="20109"></a><p>
The components of the rule definition are (1) an optional <em>public</em> declaration, (2) 
the name of the rule being defined, (3) an equals sign `=', (4) the <em>expansion</em> of the 
rule, and (5) a closing semi-colon `;'.
</p><a name="20509"></a><p>
White space is ignored before the definition, between the public keyword and the 
rulename, around the equal-sign character, and around the semi-colon. White 
space is significant within the rule expansion.
</p><a name="20510"></a><p>
The <em>rule expansion</em> defines how the rule may be spoken. It is a logical 
combination of <em>tokens</em> (text that may be spoken) and <em>references</em> to other rules. The 
term "expansion" is used because an expansion defines how a rule is expanded 
when it is spoken - a single rule may expand into many spoken words plus other 
rules which are themselves expanded. Later sections define the legal expansions.
</p>
<a name="20495"></a><h4>4.0.2	 Public Rules</h4>
<a name="20496"></a><p>
Any rule in a grammar may be declared as public by the use of the <code>public</code> 
keyword. A public rule has three possible uses:
</p><ul><li><a name="20499"></a>It can be referenced within the rule definitions of another grammar by its 
fully-qualified name or with an import declaration and an unambiguous 
reference form.
</ul>

<!-- <li><a name="20499"></a>It can be referenced within the rule definitions of another grammar by its 
fully-qualified name or with an import declaration and an unambiguous 
reference form.
 --><ul><li><a name="20500"></a>It can be used as an <em>active</em> rule for recognition. That is, the rule can be used 
by a recognizer to determine what may be spoken.
</ul>

<!-- <li><a name="20500"></a>It can be used as an <em>active</em> rule for recognition. That is, the rule can be used 
by a recognizer to determine what may be spoken.
 --><ul><li><a name="20501"></a>It can be referenced locally: that is, by any public or non-public rule defined
in the same grammar.
</ul>

<!-- <li><a name="20501"></a>It can be referenced locally: that is, by any public or non-public rule defined
in the same grammar.
 --><a name="20505"></a><p>
Without the public declaration, a rule is implicitly <em>private</em><a href="jsgf.html#20504"><sup>8</sup></a> and can only be 
referenced within rule definitions in the local grammar.
</p>
<a name="20480"></a><h3>4.1	 Rule Expansions</h3>
<a name="21083"></a><p>
The simplest rule expansions are a reference to a token and a reference to a rule. 
For example,
</p><DL><DD><pre>
<a name="20283"></a>&lt;a&gt; = elephant;
<a name="19167"></a>&lt;b&gt; = &lt;x&gt;;
<a name="19169"></a>&lt;c&gt; = &lt;com.acme.grammar.y&gt;;
</pre></DL>
<a name="20287"></a><p>
The rule <code>&lt;a&gt;</code> expands to a single token "elephant". Thus, to speak <code>&lt;a&gt;</code> the user 
must say the word "elephant".
</p><a name="20138"></a><p>
The rule <code>&lt;b&gt;</code> expands to <code>&lt;x&gt;</code>. This means that to speak <code>&lt;b&gt;</code>, the user must say 
something that matches the rule <code>&lt;x&gt;</code>. Similarly, to speak rule <code>&lt;c&gt;</code> the user must 
speak something that matches the rule <code>&lt;</code>com.acme.grammar.y<code>&gt;</code><a href="jsgf.html#20167"><sup>9</sup></a>.
</p><a name="20295"></a><p>
In more formal terms, the following are legal expansions.
</p><ul><li><a name="20296"></a>Any token.
</ul>

<!-- <li><a name="20296"></a>Any token.
 --><ul><li><a name="20528"></a>A reference to any public or non-public rule defined in the same grammar.
</ul>

<!-- <li><a name="20528"></a>A reference to any public or non-public rule defined in the same grammar.
 --><ul><li><a name="21796"></a>A reference to any public rule of another grammar which has been imported
into the current grammar.
</ul>

<!-- <li><a name="21796"></a>A reference to any public rule of another grammar which has been imported
into the current grammar.
 --><ul><li><a name="21797"></a>A reference to a public rule of another grammar when referenced with its 
fully-qualified rulename (with or without an import).
</ul>

<!-- <li><a name="21797"></a>A reference to a public rule of another grammar when referenced with its 
fully-qualified rulename (with or without an import).
 --><a name="20118"></a><p>
These reference policies are defined locally, that is, by the scope of the current 
rule. For example, a rule in <code>grammar1</code> can legally reference a public rule of 
<code>grammar2</code>, which in turn references a non-public rule of <code>grammar2</code>. In other 
words, a rule definition can indirectly reference a private rule of another grammar 
through a public rule of the other grammar.
</p><a name="20310"></a><p>
An empty definition is not legal.
</p><DL><DD><pre>
<a name="20333"></a>&lt;d&gt; = ; // not legal
</pre></DL>
<a name="20335"></a><p>
Definition of a rule as either <code>&lt;NULL&gt;</code> or <code>&lt;VOID&gt;</code> is legal.
</p><DL><DD><pre>
<a name="20536"></a>&lt;e&gt; = &lt;NULL&gt;; // legal
<a name="20337"></a>&lt;f&gt; = &lt;VOID&gt;; // legal
</pre></DL>
<a name="20298"></a><p>
The following sections explain ways in which more complex rules can be defined 
by logical combinations of legal expansions using:
</p><ul><li><a name="17771"></a><em>Composition</em>: sequences of expansions and sets of alternative expansions.
</ul>

<!-- <li><a name="17771"></a><em>Composition</em>: sequences of expansions and sets of alternative expansions.
 --><ul><li><a name="17779"></a><em>Grouping </em>using parentheses and brackets.
</ul>

<!-- <li><a name="17779"></a><em>Grouping </em>using parentheses and brackets.
 --><ul><li><a name="16932"></a><em>Unary operators</em> for repetition of expansions.
</ul>

<!-- <li><a name="16932"></a><em>Unary operators</em> for repetition of expansions.
 --><ul><li><a name="16936"></a>Attachment of application-specific <em>tags</em> to expansions.
</ul>

<!-- <li><a name="16936"></a>Attachment of application-specific <em>tags</em> to expansions.
 -->
<a name="14588"></a><h3>4.2	 Composition</h3>

<a name="16061"></a><h4>4.2.1	 Sequences</h4>
<a name="14608"></a><p>
A rule may be defined by a <em>sequence</em> of expansions. A sequence of legal 
expansions, each separated by white space, is itself a legal expansion. For 
example, because both tokens and rule references are legal expansions, the 
following are legal rule definitions.
</p><DL><DD><pre>
<a name="16955"></a>&lt;where&gt; = I live in Boston;
<a name="16957"></a>&lt;statement&gt; = this &lt;object&gt; is &lt;OK&gt;;
</pre></DL>
<a name="16067"></a><p>
To speak a sequence, each item in the sequence must be spoken in the defined 
order. In the first example, to say the rule <code>&lt;where&gt;</code>, the speaker must say the 
words "I live in Boston" in that exact order. The second example mixes tokens 
with references to the rules <code>&lt;object&gt;</code> and <code>&lt;OK&gt;</code>. To say the rule <code>&lt;statement&gt;</code>, 
the user must say "this" followed by something which matches <code>&lt;object&gt;</code>, then 
"is", and finally something matching <code>&lt;OK&gt;</code>.
</p><a name="16968"></a><p>
The items in a sequence may be any legal expansion. This includes the structures 
described below for alternatives, groups and so on.
</p>
<a name="16074"></a><h4>4.2.2	 Alternatives</h4>
<a name="14626"></a><p>
A rule may be defined as a <em>set of alternative</em> expansions separated by vertical bar 
characters `|' and optionally by whitespace. For example:
</p><DL><DD><pre>
<a name="14630"></a>&lt;name&gt; = Michael | Yuriko | Mary | Duke | &lt;otherNames&gt;;
</pre></DL>
<a name="14672"></a><p>
To say the rule <code>&lt;name&gt;</code>, the speaker must say one, and only one, of the items in 
the set of alternatives. For example, a speaker could say "Michael", "Yuriko", 
"Mary", "Duke" or anything that matches the rule <code>&lt;otherNames&gt;</code>. However, the 
speaker could not say "Mary Duke".
</p><a name="16972"></a><p>
Sequences have higher precedence than alternatives. For example,
</p><DL><DD><pre>
<a name="14675"></a>&lt;country&gt;= South Africa | New Zealand | Papua New Guinea;
</pre></DL>
<a name="18186"></a><p>
is a set of three alternatives, each naming a country.
</p><a name="20331"></a><p>
An empty alternative is not legal. 
</p><DL><DD><pre>
<a name="20368"></a>&lt;name&gt; = Michael | | Mary; // not legal
<a name="20370"></a>&lt;name&gt; = Michael | Mary | ; // not legal
</pre></DL>

<a name="16132"></a><h4>4.2.3	 Weights</h4>
<a name="16117"></a><p>
Not all ways of speaking a grammar are equally likely. Weights may be attached 
to the elements of a set of alternatives to indicate the likelihood of each alternative 
being spoken. A weight is a floating point number<a href="jsgf.html#21098"><sup>10</sup></a> surrounded by forward 
slashes, e.g. /3.14/. The higher the weight, the more likely it is that an entry will 
be spoken. The weight is placed before each item in a set of alternatives. For 
example:
</p><DL><DD><pre>
<a name="16119"></a>&lt;size&gt; = /10/ small | /2/ medium | /1/ large;
<a name="18195"></a>&lt;color&gt; = /0.5/ red | /0.1/ navy blue | /0.2/ sea green;
<a name="16120"></a>&lt;action&gt; = please (/20/save files |/1/delete all files);
<a name="20379"></a>&lt;place&gt; = /20/ &lt;city&gt; | /5/ &lt;country&gt;;
</pre></DL>
<a name="16121"></a><p>
The weights should reflect the occurrence patterns of the elements of a set of 
alternatives. In the first example, the grammar writer is indicating that "small" is 
10 times more likely to be spoken than "large" and 5 times more likely than 
"medium."
</p><a name="16122"></a><p>
The following conditions must be met when specifying weights:
</p><ul><li><a name="16123"></a>If a weight is specified for one item in a set of alternatives, then a weight 
must be specified for every item (the "all or nothing rule").
</ul>

<!-- <li><a name="16123"></a>If a weight is specified for one item in a set of alternatives, then a weight 
must be specified for every item (the "all or nothing rule").
 --><ul><li><a name="16124"></a>Weights are floating point numbers that could be passed to the <code>java.lang.Float.valueOf(String)
</code> method. For example, 56, 0.056, 
3.14e3, 8f.
</ul>

<!-- <li><a name="16124"></a>Weights are floating point numbers that could be passed to the <code>java.lang.Float.valueOf(String)
</code> method. For example, 56, 0.056, 
3.14e3, 8f.
 --><ul><li><a name="16357"></a>Only a floating point number and whitespace is allowed within the slashes.
</ul>

<!-- <li><a name="16357"></a>Only a floating point number and whitespace is allowed within the slashes.
 --><ul><li><a name="16125"></a>Weights must be zero or greater. A zero weight indicates that the item can 
never be spoken: equivalent to replacing the item by <code>&lt;VOID&gt;</code>. (Zero 
weights are useful in developing grammars.)
</ul>

<!-- <li><a name="16125"></a>Weights must be zero or greater. A zero weight indicates that the item can 
never be spoken: equivalent to replacing the item by <code>&lt;VOID&gt;</code>. (Zero 
weights are useful in developing grammars.)
 --><ul><li><a name="16127"></a>At least one non-zero positive weight is required.
</ul>

<!-- <li><a name="16127"></a>At least one non-zero positive weight is required.
 --><a name="16315"></a><p>
Appropriate weights are difficult to determine and guessing weights does not 
always improve recognition performance. Effective weights are usually obtained 
by study of real speech and textual data.
</p><a name="20382"></a><p>
Not all recognizers utilize weights in the recognition process. However, as a 
minimum, a recognizer is required to ensure that any alternative with a weight of 
zero cannot be spoken.
</p>
<a name="16086"></a><h3>4.3	 Grouping</h3>

<a name="17829"></a><h4>4.3.1	 (Parentheses)</h4>
<a name="14615"></a><p>
Any legal expansion may be explicitly grouped using matching parentheses `()'. 
Grouping has high precedence and so can be used to ensure the correct 
interpretation of rules. It is also useful for improving clarity. For example, 
because sequences have higher precedence than alternatives, parentheses are 
required in the following rule definition so that "please close" and "please delete" 
are legal.
</p><DL><DD><pre>
<a name="14639"></a>&lt;action&gt; = please (open | close | delete);
</pre></DL>
<a name="14604"></a><p>
The following example shows a sequence of three items, with each item being a 
set of alternatives surrounded by parentheses to ensure correct grouping.
</p><DL><DD><pre>
<a name="14663"></a>&lt;command&gt; = (open | close) (windows | doors) 
(immediately &#32;| &#32;later);
</pre></DL>
<a name="16098"></a><p>
To say something matching <code>&lt;command&gt;</code>, the speaker must say one word from 
each of the three sets of alternatives: for example, "open windows immediately" 
or "close doors later".
</p><a name="17003"></a><p>
If a grouping surrounds a single expansion, then the entity is defined to be a 
sequence of one item<a href="jsgf.html#20406"><sup>11</sup></a>. For example:
</p><DL><DD><pre>
<a name="16109"></a>( start )
<a name="16111"></a>( &lt;end&gt; )
</pre></DL>
<a name="20421"></a><p>
Empty parentheses are not legal.
</p><DL><DD><pre>
<a name="20416"></a>( ) // not legal
</pre></DL>

<a name="17835"></a><h4>4.3.2	 [Optional Grouping]</h4>
<a name="17836"></a><p>
Square brackets may be placed around any rule definition to indicate that the 
contents are optional. In other respects, it is equivalent to parentheses for 
grouping and has the same precedence. 
</p><a name="17843"></a><p>
For example, 
</p><DL><DD><pre>
<a name="17850"></a>&lt;polite&gt; = please | kindly | oh mighty computer;
<a name="17837"></a>public &lt;command&gt; = [ &lt;polite&gt; ] don't crash;
</pre></DL>
<a name="17838"></a><p>
allows a user to say "don't crash" and to optionally add one form of politeness 
such as "oh mighty computer don't crash" or "kindly don't crash".
</p><a name="20427"></a><p>
Empty brackets are not legal.
</p><DL><DD><pre>
<a name="20428"></a>[ ] // not legal
</pre></DL>

<a name="14660"></a><h3>4.4	 Unary Operators</h3>
<a name="17859"></a><p>
There are three <em>unary operators</em> in the Java Speech Grammar Format: the Kleene 
star, the plus operator and tags. The unary operators share the following features:
</p><ul><li><a name="17860"></a>A unary operator may be attached to any legal rule expansion.
</ul>

<!-- <li><a name="17860"></a>A unary operator may be attached to any legal rule expansion.
 --><ul><li><a name="17861"></a>They have high precedence: they attach to the immediate preceding rule 
expansion.
</ul>

<!-- <li><a name="17861"></a>They have high precedence: they attach to the immediate preceding rule 
expansion.
 --><ul><li><a name="20590"></a>Only one unary operator can be attached to any rule expansion (there is an 
exception to this rule for tags).
</ul>

<!-- <li><a name="20590"></a>Only one unary operator can be attached to any rule expansion (there is an 
exception to this rule for tags).
 --><ul><li><a name="20587"></a>White space between the rule expansion and attached operator is ignored.
</ul>

<!-- <li><a name="20587"></a>White space between the rule expansion and attached operator is ignored.
 --><a name="20572"></a><p>
Because the precedence of unary operators is higher than that of sequences and 
alternatives, parentheses must be used to surround a sequence or set of 
alternatives to attach an operator to the entire entity.
</p>
<a name="16139"></a><h4>4.4.1	 * Kleene Star</h4>
<a name="14687"></a><p>
A rule expansion followed by the asterisk symbol indicates that the expansion 
may be spoken <em>zero or more times</em>. The asterisk symbol is known as the Kleene 
star (after Stephen Cole Kleene, who originated the use of the symbol). For 
example, 
</p><DL><DD><pre>
<a name="14690"></a>&lt;command&gt; = &lt;polite&gt;* don't crash;
</pre></DL>
<a name="14688"></a><p>
allows a user to say things like "please don't crash", "oh mighty computer please 
please don't crash", or to ignore politeness with "don't crash".
</p><a name="17868"></a><p>
As a unary operator, this symbol has high precedence. For example, in
</p><DL><DD><pre>
<a name="17874"></a>&lt;song&gt; = sing New York *;
</pre></DL>
<a name="17872"></a><p>
the operator applies to the most immediate preceding legal expansion: the token 
"York". Thus to speak <code>&lt;song&gt;</code> the user may say "sing New York", "sing New" 
and "sing New York York York", but not "sing New York New York". Quotes or 
parentheses can be used to modify the scope of the * operator. For example,
</p><DL><DD><pre>
<a name="18234"></a>&lt;song&gt; = sing (New York) *;
</pre></DL>
<a name="18236"></a><p>
does match "sing New York New York".
</p>
<a name="16143"></a><h4>4.4.2	 + Plus Operator</h4>
<a name="14733"></a><p>
A rule expansion followed by the plus symbol indicates the expansion may be 
spoken <em>one or more times</em>. For example, 
</p><DL><DD><pre>
<a name="14753"></a>&lt;command&gt; = &lt;polite&gt;+ don't crash;
</pre></DL>
<a name="14755"></a><p>
requires at least one form of politeness. So, it allows a user to say "please please 
don't crash". However, "don't crash" is not legal.
</p>
<a name="15057"></a><h3>4.5	 Tags</h3>
<a name="20602"></a><p>
Tags provide a mechanism for grammar writers to attach application-specific 
information to parts of rule definitions. Applications typically use tags to simplify 
or enhance the processing of recognition results.
</p><a name="20605"></a><p>
Tag attachments do not affect the recognition of a grammar. Instead, the tags are 
attached to the result object returned by the recognizer to an application. The 
software interface of the recognizer defines the mechanism for providing tags<a href="jsgf.html#20617"><sup>12</sup></a>.
</p><a name="21362"></a><p>
A tag is a unary operator. As such it may be attached to any legal rule expansion. 
The tag is a string delimited by curly braces `{}'. All characters within the braces 
are considered a part of the tag, including white-space. Empty braces "{}" are a 
legal tag. In this instance the tag should be interpreted as a zero-length string ("" 
in the Java programming language).
</p><a name="21357"></a><p>
To include a closing brace character in a quote, it must be <em>escaped</em> with a 
backslash `\' character. To include a backslash character, it must also be escaped 
by a backslash. For example,
</p><DL><DD><pre>
<a name="20623"></a>{ {nasty \\looking\\ tag\} }
</pre></DL>
<a name="20585"></a><p>
is processed as the following string:
</p><DL><DD><pre>
<a name="21437"></a>" {nasty \looking\ tag} "
</pre></DL>
<a name="20631"></a><p>
The tag attaches to the immediate preceding rule expansion (intervening 
whitespace is ignored). For example:
</p><DL><DD><pre>
<a name="15604"></a>&lt;rule&gt; = &lt;action&gt; {tag in here};
<a name="15606"></a>&lt;command&gt;= please (open {OPEN} | close {CLOSE}) the file;
<a name="15062"></a>&lt;country&gt; = Australia {Oz} | (United States) {USA} | 
America &#32;{USA} &#32;| (U S of A) {USA};
</pre></DL>
<a name="17921"></a><p>
As a unary operator, tag attachment has higher precedence than sequences and 
alternatives. For example, in
</p><DL><DD><pre>
<a name="17931"></a>&lt;action&gt; = book | magazine | newspaper {thing};
</pre></DL>
<a name="17925"></a><p>
the "thing" tag is attached only to the "newspaper" token. Parentheses may be 
used to modify tag attachment:
</p><DL><DD><pre>
<a name="17927"></a>&lt;action&gt; = (book | magazine | newspaper) {thing};
</pre></DL>
<a name="16361"></a><p>
Unlike the other unary operators, more than one tag may follow a rule expansion. 
For example,
</p><DL><DD><pre>
<a name="21373"></a>&lt;OKRule&gt; = &lt;action&gt; {tag1} {tag2} {tag3}; // legal
</pre></DL>
<a name="21371"></a><p>
This is interpreted as if parentheses were used:
</p><DL><DD><pre>
<a name="21379"></a>&lt;OKRule&gt; = ((&lt;action&gt; {tag1}) {tag2}) {tag3}; // legal
</pre></DL>
<a name="21369"></a><p>
This syntactic convenience is only permitted for tags. The following are not 
permitted:
</p><DL><DD><pre>
<a name="17898"></a>&lt;badRule&gt; = &lt;action&gt; * {tag1}; // not legal
<a name="17900"></a>&lt;badRule&gt; = &lt;action&gt; {tag1} +; // not legal
</pre></DL>

<a name="15064"></a><h4>4.5.1	 Using Tags</h4>
<a name="16399"></a><p>
Tags can simplify the writing of applications by simplifying the processing of 
recognition results. The content of tags, and the use of tags are entirely up to the 
discretion of the developer. 
</p><a name="20641"></a><p>
One important use of tags is in internationalizing applications. The following are 
examples of rule definitions for four grammars, each for a separate language. The 
application loads the grammar for the language spoken by the user into an 
appropriate recognizer. The tags remain the same across all languages and thus 
simplify the application software that processes the results. Typically, the 
grammar name will include the language identifier so that it can be 
programmatically located and loaded.
</p><a name="19270"></a><p>
In the English grammar:
</p><DL><DD><pre>
<a name="15065"></a>&lt;greeting&gt;= (howdy | good morning) {hi};
</pre></DL>
<a name="19278"></a><p>
In the Japanese grammar:
</p><DL><DD><pre>
<a name="15066"></a>&lt;greeting&gt;= (ohayo | ohayogozaimasu) {hi};
</pre></DL>
<a name="19280"></a><p>
In the German grammar:
</p><DL><DD><pre>
<a name="15067"></a>&lt;greeting&gt;= (guten tag) {hi};
</pre></DL>
<a name="19282"></a><p>
In the French grammar:
</p><DL><DD><pre>
<a name="15068"></a>&lt;greeting&gt;= (bon jour) {hi};
</pre></DL>

<a name="16211"></a><h3>4.6	 Precedence</h3>
<a name="18253"></a><p>
The following defines the relative precedence of the entities of a rule expansion in 
the Java Speech Grammar Format. The list proceeds from highest to lowest 
precedence.
</p><ol>
<li><a name="14089"></a>Rulename contained within angle brackets, and a quoted or unquoted 
token.
<li><a name="17946"></a>`()' parentheses for grouping and `[]' for optional grouping.
<li><a name="14778"></a>The unary operators (`+', `*', and tag attachment) apply to the tightest 
immediate preceding rule expansion. (To apply them to a sequence or to 
alternatives, use `()' or `[]' grouping.)
<li><a name="14788"></a>Sequence of rule expansions.
<li><a name="15453"></a>`|' separated set of alternative rule expansions.
</ol>

<a name="14102"></a><h3>4.7	 Recursion</h3>
<a name="14806"></a><p>
<em>Recursion</em> is the definition of a rule in terms of itself. Recursion is a powerful tool 
that enables representation of many complex grammatical forms that occur in 
spoken languages. Recognizers supporting the Java Speech Grammar Format 
allow <em>right recursion</em>. In right recursion, the rule refers to itself as the last part of 
its definition. For example:
</p><DL><DD><pre>
<a name="14822"></a>&lt;command&gt; = &lt;action&gt; | (&lt;action&gt; and &lt;command&gt;);
<a name="14833"></a>&lt;action&gt; = stop | start | pause | resume | finish;
</pre></DL>
<a name="14811"></a><p>
allows the following commands: "stop", "stop and finish", "start and resume and 
finish".
</p><a name="17961"></a><p>
<em>Nested right recursion</em> is also permitted. Nested right recursion is a definition of a 
rule that references another rule that refers back to the first rule with each 
recursive reference being the last part of the definition. For example,
</p><DL><DD><pre>
<a name="17962"></a>&lt;X&gt; = something | &lt;Y&gt;;
<a name="17963"></a>&lt;Y&gt; = another thing &lt;X&gt;;
</pre></DL>
<a name="14104"></a><p>
Nested right recursion may occur across grammars. However, this is strongly 
discouraged, as it introduces unnecessary complexity and potential maintenance 
problems.
</p><a name="14883"></a><p>
Any right recursive rule can be re-written using the Kleene star `*' and/or the plus 
operator `+'. For example, the following rule definitions are equivalent:
</p><DL><DD><pre>
<a name="18272"></a>&lt;command&gt; = &lt;action&gt; | (&lt;action&gt; and &lt;command&gt;);
<a name="18273"></a>&lt;command&gt; = &lt;action&gt; (and &lt;action&gt;) *;
</pre></DL>
<a name="18297"></a><p>
Although it is possible to re-write right recursive grammars using the `+' and `*' 
operators, the recursive form is permitted because it allows simpler and more 
elegant representations of some grammars. Other forms of recursion (left 
recursion, embedded recursion) are not supported because the re-write condition 
cannot be guaranteed<a href="jsgf.html#20686"><sup>13</sup></a>.
</p>
<a name="20689"></a><h3>4.8	 Uses of &lt;NULL&gt; and &lt;VOID&gt;</h3>
<a name="20693"></a><p>
The two <a href="jsgf.html#19472"><em>Special Rulenames</em></a> defined earlier in this document - <code>&lt;NULL&gt;</code> and 
<code>&lt;VOID&gt;</code> - have a number of advanced uses.
</p><a name="20735"></a><p>
A reference to <code>&lt;NULL&gt;</code> as an alternative to any rule expansion is the same as using 
the optional grouping. So, the following are equivalent definitions:
</p><DL><DD><pre>
<a name="20746"></a>&lt;x&gt; = a | &lt;NULL&gt;;  
<a name="20748"></a>&lt;x&gt; = [ a ]; 
</pre></DL>
<a name="20753"></a><p>
The Kleene star and right recursion can be mapped as follows:
</p><DL><DD><pre>
<a name="20763"></a>&lt;x&gt; = &lt;NULL&gt; | a &lt;x&gt;;  
<a name="20764"></a>&lt;x&gt; = a*; 
</pre></DL>
<a name="20718"></a><p>
For the two previous cases, the grammars are identical in the sense that the user 
may speak exactly the same utterances. However, there may be programmatic 
differences in the representation of results produced by a recognizer when the 
user says something matching the grammar.
</p><a name="20790"></a><p>
A final use of <code>&lt;NULL&gt;</code> and <code>&lt;VOID&gt;</code> is for gating. To turn on and off particular 
parts of a grammar an application could define the rule <code>&lt;gate&gt;</code>, place it before 
the parts of the grammar that will be turned on and off, and alternate the definition 
of <code>&lt;gate&gt;</code> between:
</p><DL><DD><pre>
<a name="20804"></a>&lt;gate&gt; = &lt;NULL&gt;;  
<a name="20805"></a>&lt;gate&gt; = &lt;VOID&gt;; 
</pre></DL>
<a name="20791"></a><p>
When <code>&lt;gate&gt;</code> is <code>&lt;VOID&gt;</code>, it is unspeakable and the grammar region is turned off.
</p><a name="20816"></a><p>
As a caution, to work effectively, this technique requires a recognizer that can 
efficiently re-compile the grammar after changing the definition of <code>&lt;gate&gt;</code>. Not 
all recognizers perform this re-compilation efficiently.
</p>
<a name="19654"></a><h3>4.9	 Documentation Comments</h3>
<a name="19655"></a>The Java Speech Grammar Format supports <em>documentation comments</em> with a 
similar style to the documentation comments of the Java Programming Language 
(GJS96, &#167;18). Such comments can appear before the grammar declaration, before 
import statements and before the definition of any rule. Hypertext web pages and 
other forms of documentation can be automatically generated from these 
comments.
<p><a name="19696"></a><p>
A documentation comment commences with the characters <code>/**</code> and is terminated 
by <code>*/</code>. On each of the comment lines leading <code>*</code> characters and any preceding 
white space is ignored.
</p><a name="19700"></a><p>
The first sentence of the comment (terminated by the first period character) 
should be a <em>summary sentence</em> with a concise description of the entity being 
commented.
</p><a name="19904"></a><p>
Unlike Java code documentation, documentation comments in the Java Speech 
Grammar Format do not allow HTML tags. This is because HTML tags and JSGF 
rulename references use the same format. For example, is <code>&lt;font&gt;</code> a rulename or 
an HTML code?
</p><a name="19756"></a><p>
A <em>tagged paragraph</em> is marked by a line of a documentation comment that begins 
with the @ character followed by one of the keywords defined below. A tagged 
paragraph includes the following lines of the comment up to the start of the next 
tagged paragraph or to the end of the documentation comment. (Documentation 
tags are not related to tags in rule definitions.)
</p><a name="19913"></a><p>
The following example shows the basic structure of a documentation comment. 
<a href="jsgf.html#19936"><em>Example 3: Documentation Comments</em></a> shows an example of comments for a 
simple grammar.
</p><pre><hr>
<a name="19662"></a>/**
<a name="19727"></a> &#32; &#32;* Initial sentence provides a summary.
<a name="19664"></a> &#32; &#32;* Additional text and paragraphs can be inserted.
<a name="19666"></a> &#32; &#32;*
<a name="19667"></a> &#32; &#32;* @tag several types of tag are defined below
<a name="19668"></a> &#32; &#32;*/
<hr></pre>
<a name="19798"></a><h4>4.9.1	 The @author Tag</h4>
<a name="19764"></a>The <code>@author</code> tag may be used in the documentation comment for the grammar 
declaration. Although there is no defined structure for the <code>@author</code> tag, it is 
recommended that each author be listed in a separate tag. Multiple <code>@author</code> tags 
may be included in a single comment.
<p><a name="19841"></a><p>
For example,
</p><DL><DD><pre>
<a name="19814"></a>@author James Bond
<a name="19820"></a>@author Jose Alvarez
</pre></DL>

<a name="19843"></a><h4>4.9.2	 The @version Tag</h4>
<a name="19766"></a>A single <code>@version</code> tag may be included in the documentation comment of a 
grammar declaration. There is no defined structure or format. For example,
<p><DL><DD><pre>
<a name="19849"></a>@version versionInformation
</pre></DL>

<a name="19856"></a><h4>4.9.3	 The @see Tag</h4>
<a name="19770"></a>Any number of <code>@see</code> tags may be used in any documentation comment. The tag 
indicates a cross-reference to another rule (local or imported) or to another 
grammar. The <code>.*</code> suffix indicates the reference is to a grammar.
<p><DL><DD><pre>
<a name="19860"></a>@see &lt;com.acme.number.zeroToTen&gt;
<a name="19868"></a>@see &lt;com.acme.number.*&gt;
<a name="19872"></a>@see &lt;zeroToTen&gt;
</pre></DL>

<a name="19878"></a><h4>4.9.4	 The @example Tag</h4>
<a name="21271"></a>The <code>@example</code> tag can be provided in documentation comments for rule 
declarations to provide an example of how the rule may be spoken. Appropriate 
examples make grammars and rules easier to understand. The example text may 
also be used by grammar tools to verify the correctness of the grammar.
<p><DL><DD><pre>
<a name="21280"></a>@example please say your name and age
<a name="21282"></a>@example I love "south america"
</pre></DL>
<a name="21133"></a><p>
Developers are encouraged to use the same tokenization in examples as used in 
the rule definition. For example, the second sample above should be interpreted as 
two tokens because of the quotes around "south america". However, tool 
developers should consider the possibility that the example text includes human-
readable formatting for clarity. For English this might include punctuation 
(period, comma, question mark, exclamation point etc.), capitalization of some 
tokens, modified tokenization (e.g. missing quotes).
</p><a name="21953"></a><p>
The <code>@example</code> tag may include rulename references. For example,
</p><DL><DD><pre>
<a name="21961"></a>@example I want a pizza with &lt;topping&gt;
</pre></DL>
<a name="21959"></a><p>
would expand out with each example tag defined for the <code>&lt;topping&gt;</code> rule ("I want 
a pizza with pepperoni", "I want a pizza with mushrooms" and so on).
</p><P>&nbsp;</P>
<hr width="30%" align="center" noshade>
<P>&nbsp;</P>
<a name="14439"></a><h2>5.	 Examples </h2>
<a name="14440"></a><p>
By combining simple rules together, it is possible to build complex grammars that 
capture what users can say. The following are examples of grammars with 
complete headers and bodies.
</p>
<a name="17971"></a><h3>5.1	 Example 1: Simple Command and Control</h3>
<a name="17975"></a><p>
This example shows two basic grammars that define spoken commands that 
control a window. Optional politeness is included to show how speech interaction 
can be made a little more natural and conversational.
</p><pre><hr>
<a name="14441"></a>#JSGF V1.0;
<a name="21066"></a>
<a name="21069"></a>grammar com.acme.politeness;
<a name="14444"></a>
<a name="14445"></a>// Body
<a name="14446"></a>public &lt;startPolite&gt; = (please | kindly | could you | 
oh &#32;mighty &#32;computer) *;
<a name="14447"></a>public &lt;endPolite&gt; = [ please | thanks | thank you ];
<hr></pre><a name="14450"></a><p>
The <code>politeness</code> grammar is not useful on its own but is imported into the 
<code>commands</code> grammar to add the conversational style.
</p><pre><hr>
<a name="14452"></a>#JSGF V1.0 ISO8859-1 en;
<a name="21070"></a>
<a name="21060"></a>grammar com.acme.commands;
<a name="14456"></a>import &lt;com.acme.politeness.startPolite&gt;;
<a name="14457"></a>import &lt;com.acme.politeness.endPolite&gt;;
<a name="14458"></a>
<a name="17991"></a>/**
<a name="20012"></a> &#32;* Basic command.
<a name="20020"></a> &#32;* @example please move the window
<a name="20022"></a> &#32;* @example open a file
<a name="20009"></a> &#32;*/
<a name="20016"></a>
<a name="14460"></a>public &lt;basicCmd&gt; = &lt;startPolite&gt; &lt;command&gt; &lt;endPolite&gt;;
<a name="18742"></a>
<a name="14461"></a>&lt;command&gt; = &lt;action&gt; &lt;object&gt;;
<a name="14462"></a>&lt;action&gt; = /10/ open |/2/ close |/1/ delete |/1/ move;
<a name="14463"></a>&lt;object&gt; = [the | a] (window | file | menu);
<hr></pre><a name="14465"></a><p>
The <code>commands</code> grammar defines a single <code>public</code> rule, <code>&lt;basicCommand&gt;</code>, which 
is composed of two imported rules, <code>&lt;startPolite&gt;</code> and <code>&lt;endPolite&gt;</code>, and 
three private rules, <code>&lt;command&gt;</code>, <code>&lt;action&gt;</code> and <code>&lt;object&gt;</code>. Both the <code>&lt;action&gt;</code> 
and <code>&lt;object&gt;</code> rules are sets of alternative words and the actions list has weights 
that indicate that "open" is more likely than the others. The <code>&lt;command&gt;</code> rule 
defines a sequence in which <code>&lt;action&gt;</code> is followed optionally by "the" or "a" and 
always by an <code>&lt;object&gt;</code>.
</p><a name="15135"></a><p>
Because <code>&lt;com.acme.commands.basicCommand&gt;</code> is public, it can be made 
active for recognition. When it is active, users may say commands such as:
</p><ul><li><a name="15146"></a>"open a window"
</ul>

<!-- <li><a name="15146"></a>"open a window"
 --><ul><li><a name="15151"></a>"close file please"
</ul>

<!-- <li><a name="15151"></a>"close file please"
 --><ul><li><a name="15152"></a>"oh mighty computer please open a menu"
</ul>

<!-- <li><a name="15152"></a>"oh mighty computer please open a menu"
 -->
<a name="17514"></a><h3>5.2	 Example 2: Resolving Names</h3>
<a name="17505"></a><p>
The following example grammar illustrates the use of fully-qualified names for an 
application that deals with clothing. The two imported grammars define import 
rules regarding pants and shirts, including the lists of colors that shirts and pants 
may have. The local <code>&lt;color&gt;</code> rule is a combination of the imported color lists. 
Because a reference to <code>&lt;color&gt;</code> is ambiguous (it could come from either the 
pants or shirts grammar), qualified or fully-qualified names are required.
</p><pre><hr>
<a name="17506"></a>#JSGF V1.0;
<a name="21078"></a>grammar com.acme.selections;
<a name="17507"></a>import &lt;com.acme.pants.*&gt;;
<a name="17508"></a>import &lt;com.sun.shirts.*&gt;;
<a name="21076"></a>
<a name="17509"></a>&lt;color&gt; = &lt;com.acme.pants.color&gt; | 
&lt;com.acme.shirts.color&gt;;
<a name="17510"></a>public &lt;statement&gt; = I like &lt;color&gt;;
<hr></pre><a name="17511"></a><p>
The reference to <code>&lt;color&gt;</code> in the last definition is not ambiguous: because local 
rules have precedence over imported rules, it refers to the locally-defined 
<code>&lt;color&gt;</code> rule. In the definition of the local <code>&lt;color&gt;</code> rule, qualified names could 
have been used as they would be unambiguous references: that is,
</p><DL><DD><pre>
<a name="17512"></a>&lt;color&gt; = &lt;pants.color&gt; | &lt;shirts.color&gt;;
</pre></DL>

<a name="19936"></a><h3>5.3	 Example 3: Documentation Comments</h3>
<a name="19950"></a><p>
The following example grammar illustrates the use of documentation comments 
for a simple grammar. It shows all three types of use of documentation comments, 
for the grammar declaration, for import statements and for rule definitions.
</p><pre><hr>
<a name="19922"></a>#JSGF 1.0 ISO8559-1;
<a name="21081"></a>
<a name="21082"></a>/**
<a name="19958"></a> &#32;* Define simple travel directives.
<a name="19977"></a> &#32;* 
<a name="19983"></a> &#32;* @author Mary Contrary
<a name="19984"></a> &#32;* @version 3.141beta
<a name="19959"></a> &#32;*/
<a name="19923"></a>
<a name="19971"></a>grammar com.acme.travel;
<a name="19963"></a>
<a name="19970"></a>/**
<a name="19969"></a> &#32;* Get a list of city names: &lt;city&gt;.
<a name="19964"></a> &#32;*/
<a name="19972"></a>
<a name="19924"></a>import &lt;com.acme.cities.*&gt;;
<a name="19926"></a>
<a name="19927"></a>/**
<a name="19981"></a> &#32;* A simple travel command
<a name="19985"></a> &#32;* 
<a name="20043"></a> &#32;* @example go from sydney to tokyo to dublin
<a name="20045"></a> &#32;* @example go from "san francisco" to bangkok
<a name="19982"></a> &#32;*/
<a name="19987"></a>
<a name="19934"></a>public &lt;travel&gt; = go from &lt;city&gt; ( to &lt;city&gt; )+;
<hr></pre>

<hr size=7 noshade>

</blockquote>

<sup>1</sup><!--"Footnote" is same tag as body.-->
<a name="17364"></a>A Java identifier is an unlimited-length sequence of Unicode characters. The first character is 
a letter or one of a set of special symbols (including `$' and `_'). Following characters include 
letters, numbers, the special symbols and other characters. The <code>java.lang.Character</code> class 
defines methods to test identifiers and document the character sets in more detail: 
<code>isJavaIdentifierStart</code> and <code>isJavaIdentifierPart</code>.
<p><sup>2</sup><!--"Footnote" is same tag as body.-->
<a name="19190"></a>The <code>isRuleNamePart</code> method of the <code>javax.speech.recognition.RuleName</code> class of the 
Java Speech API tests the set of legal rulename characters.
<p><sup>3</sup><!--"Footnote" is same tag as body.-->
<a name="19180"></a>The <code>isWhitespace</code> method of the <code>java.lang.Character</code> class can be used to test for 
whitespace characters in the Unicode character set.
<p><sup>4</sup><!--"Footnote" is same tag as body.-->
<a name="19540"></a>The Java Speech API throws a <code>GrammarException</code> when an unresolvable rulename is 
detected.
<p><sup>5</sup><!--"Footnote" is same tag as body.-->
<a name="20057"></a>The <code>javax.speech.recognition.RuleName</code> class defines static instances for <code>NULL</code> and 
<code>VOID</code> for convenience.
<p><sup>6</sup><!--"Footnote" is same tag as body.-->
<a name="22078"></a>The documentation for the <code>java.util.Locale</code> class explains the use of locales.
<p><sup>7</sup><!--"Footnote" is same tag as body.-->
<a name="20085"></a>These properties differ from some linguistic and computational grammar formats which 
permit multiple alternate definition of non-terminals or for which order is significant.
<p><sup>8</sup><!--"Footnote" is same tag as body.-->
<a name="20504"></a>Unlike the Java Programming Language, the Java Speech Grammar <br>
Format does not have keywords for <code>private</code> or <code>protected</code>.
<p><sup>9</sup><!--"Footnote" is same tag as body.-->
<a name="20167"></a>As defined in the section on <a href="jsgf.html#16587"><em>Rulenames</em></a>, if <code>&lt;x&gt;</code> or <code>&lt;com.acme.grammar.y&gt;</code> are imported 
rules, there should be an appropriate import statement and the rule must be declared public in 
the imported grammar.
<p><sup>10</sup><!--"Footnote" is same tag as body.-->
<a name="21098"></a>The Java programming language requires an `f' or `F' suffix for floating point numbers. This 
is not required in the Java Speech Grammar Format.
<p><sup>11</sup><!--"Footnote" is same tag as body.-->
<a name="20406"></a>This definition provides consistency in parsing and other grammar analysis.
<p><sup>12</sup><!--"Footnote" is same tag as body.-->
<a name="20617"></a>In the Java Speech API, both the <code>FinalRuleResult</code> and the <code>RuleTag</code> object within a 
<code>RuleParse</code> provide information on tags in a recognition result.
<p><sup>13</sup><!--"Footnote" is same tag as body.-->
<a name="20686"></a>Technically speaking, the Java Speech Grammar Format defines what is formally called a 
<em>regular grammar</em>. Some features typically associated with a <em>context-free grammar</em> are 
permitted for clarity or convenience.
<p><!-- This inserts footnotes--><p>
<table align="center" CELLSPACING=20 CELLPADDING=6 bgcolor="#f0f0ff">
<tr>
<td><code>
<a href="index.html">Contents</a>
</code>
<td><code>
<a href="Contrib.html">Previous</a>  </code>
<td><code>
&nbsp;&nbsp;<a href="">Next</a>&nbsp;&nbsp;  </code>
</table>

<HR width="30%" noshade align="center">
<P align="center">
<font size=-1>Java<SUP><font size="-2">TM</font></sup> Speech Grammar Format Specification<br>
<a href="Copyright.html">Copyright &#169 1997-1998 Sun Microsystems, Inc.</a>
All rights reserved<br>
Send comments or corrections to <a href="mailto:javaspeech-comments@sun.com">javaspeech-comments@sun.com</a>
</font>
</P>


</body></html>