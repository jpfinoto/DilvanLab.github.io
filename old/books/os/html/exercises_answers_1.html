<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>3.&nbsp;Answers 1</title><link rel="stylesheet" href="html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.67.0"><link rel="start" href="index.html" title="Operating Systems"><link rel="up" href="exercises.html" title="Chapter&nbsp;9.&nbsp;Exercises"><link rel="prev" href="exercises_list_2.html" title="2.&nbsp;List 2"><link rel="next" href="exercises_answers_2.html" title="4.&nbsp;Answers 2"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3.&nbsp;Answers 1</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="exercises_list_2.html"><img src="images/prev.gif" alt="Prev"></a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;9.&nbsp;Exercises</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="exercises_answers_2.html"><img src="images/next.gif" alt="Next"></a></td></tr></table><hr></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="exercises_answers_1"></a>3.&nbsp;Answers 1</h2></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>Answers 1</p><div class="orderedlist"><ol type="1"><li><p>Processos: &middot; Cria&ccedil;&atilde;o e remo&ccedil;&atilde;o de processos (do sistema e dos usu&aacute;rios) &middot; Suspens&atilde;o e ativa&ccedil;&atilde;o de processos &middot; Sincroniza&ccedil;&atilde;o de processos &middot; Comunica&ccedil;&atilde;o entre processos &middot; Tratamento de deadlock entre os processos Mem&oacute;ria: &middot; Manter informa&ccedil;&atilde;o sobre quais partes da mem&oacute;ria est&atilde;o sendo usadas no instante atual e por quem &middot; Decidir quais processos devem ser carregados na mem&oacute;ria quando algum espa&ccedil;o de mem&oacute;ria se torna dispon&iacute;vel &middot; Alocar espa&ccedil;o e remover programas e dados da mem&oacute;ria quando necess&aacute;rio</p></li><li><p>Um processo corresponde a um programa em execu&ccedil;&atilde;o. Normalmente o termo programa &eacute; utilizado para definir o c&oacute;digo do mesmo e o termo processo para se referir &agrave; ativa&ccedil;&atilde;o do mesmo, incluindo c&oacute;digo, dados, arquivos e outros recursos necess&aacute;rios &agrave; sua execu&ccedil;&atilde;o. Em alguns casos, um mesmo programa pode fazer parte de v&aacute;rios processos. Um processo pode conter um &uacute;nico thread (processo pesado) ou v&aacute;rios (processo leve). Cada thread compartilhando o mesmo c&oacute;digo mas executando "paralelamente".</p></li><li><p>Na cria&ccedil;&atilde;o de novos processos, para que haja compartilhamento de todos os recursos alocados para o processo pai, o processo filho deve ser uma c&oacute;pia do pai. Isso implica em armazenar todas as informa&ccedil;&otilde;es, que est&atilde;o armazenadas no espa&ccedil;o de endere&ccedil;amento do processo pai, no espa&ccedil;o de endere&ccedil;amento do processo filho. Cada processo consiste de contador de programas, se&ccedil;&atilde;o de dados e c&oacute;digo, ponteiro de pilha de execu&ccedil;&atilde;o e registradores. Todos esses dados s&atilde;o copiados para o novo processo. Na cria&ccedil;&atilde;o de uma thread, &eacute; criado um espa&ccedil;o de endere&ccedil;amento (dentro do espa&ccedil;o do processo) com um contador de instru&ccedil;&otilde;es, registradores e um espa&ccedil;o de pilha para aquela thread. Todas as outras informa&ccedil;&otilde;es existentes no espa&ccedil;o de endere&ccedil;amento do processo (que &eacute; comum para todas as threads) n&atilde;o precisam ser replicadas e podem ser utilizadas por todas as threads que fazem parte do processo. Ou seja, o tempo de cria&ccedil;&atilde;o e aloca&ccedil;&atilde;o de espa&ccedil;o para criar a thread &eacute; menor do que para criar o processo, fazendo c/ que a cria&ccedil;&atilde;o de threads seja mais barata do que a de processos. As thread compartilham a se&ccedil;&atilde;o de dados e de c&oacute;digo e os recursos do sistema operacional com as demais threads do processo.</p></li><li><p>Cada processo &eacute; descrito no SO por um Bloco de controle de processos (BCP) e cada thread &eacute; descrita no processo por um bloco de controle pr&oacute;prio (BCT). No BCP h&aacute; informa&ccedil;&otilde;es: compartilhadas (espa&ccedil;o de endere&ccedil;amento, vari&aacute;veis globais, arquivos abertos, temporizadores, sinais, sem&aacute;foros e contabiliza&ccedil;&atilde;o de recursos) e espec&iacute;ficas (processos filhos, contador de programa, pilha, conjunto de registradores e informa&ccedil;&otilde;es sobre o estado do processo). No BCT, h&aacute; informa&ccedil;&otilde;es: espec&iacute;ficas (contador de programa, pilha, conjunto de registradores e informa&ccedil;&otilde;es sobre o estado do thread). Na troca de contextos entre processos, o SO armazena o estado do processo atual e recupera o estado do processo que ser&aacute; executado realizando as seguintes opera&ccedil;&otilde;es: &middot; atualiza o estado do processo, o contador de programa e outras informa&ccedil;&otilde;es do BCP &middot; salva registradores da CPU nos registradores do processo &middot; recupera as informa&ccedil;&otilde;es do BCP do novo processo e grava os valores dos registradores do novo processo nos registradores da CPU &middot; come&ccedil;a a execu&ccedil;&atilde;o do novo processo Entre threads, n&atilde;o existe uma troca de contexto propriamente dita. O SO salva as informa&ccedil;&otilde;es espec&iacute;ficas da thread e recupera as informa&ccedil;&otilde;es espec&iacute;ficas da outra thread que dever&aacute; entrar em execu&ccedil;&atilde;o. O contexto do processo continua o mesmo, ocorrendo apenas a troca entre contador de programa, pilha e registradores da thread.</p></li><li><p></p></li><li><p>1) processo que estava executando &eacute; bloqueado pelo SO (entrada de dados)</p><p>2) processo que estava executando &eacute; suspenso pelo SO (troca entre processos)</p><p>3) processo suspenso entra novamente em execu&ccedil;&atilde;o (processo escalonado)</p><p>4) processo bloqueado fica pronto para ser executado (libera&ccedil;&atilde;o de entrada de dados)</p></li><li><p>Runnable: pronta para executar Active: executando Sleeping: dormindo (esperando recurso) Stopped: parada Zombie: finalizada</p></li><li><p>As system calls servem para que o usu&aacute;rio possa interagir com as fun&ccedil;&otilde;es do sistema operacional. A chamada a uma system call &eacute; semelhante &agrave; chamada de uma fun&ccedil;&atilde;o em um programa, com a diferen&ccedil;a que as fun&ccedil;&otilde;es realizadas atrav&eacute;s da chamada de uma system call s&atilde;o realizadas (e implementadas) pelo kernel do sistema operacional (interrup&ccedil;&atilde;o de software).</p></li><li><p>&middot; Gerenciar as &aacute;reas de mem&oacute;ria que est&atilde;o sendo usadas e as que est&atilde;o livres</p><p>&middot; Alocar e desalocar mem&oacute;ria para os processos</p><p>&middot; Alocar espa&ccedil;o em disco quando a mem&oacute;ria principal n&atilde;o for suficiente (gerenciar swapping)</p></li><li><p>Vantagens:</p><p>&middot; criar threads &eacute; mais r&aacute;pido e mais barato</p><p>&middot; N&atilde;o &eacute; necess&aacute;ria a troca de todo o contexto para trocar o thread que est&aacute; em execu&ccedil;&atilde;o por outro que est&aacute; esperando para ser executado</p><p>&middot; Pode fornecer respostas mais r&aacute;pidas</p><p>&middot; Recursos podem ser compartilhados</p><p>Desvantagem: necessidade de sincroniza&ccedil;&atilde;o</p><p>Beneficiada: aplica&ccedil;&otilde;es sem depend&ecirc;ncia de dados</p><p>N&atilde;o beneficiada: aplica&ccedil;&otilde;es com depend&ecirc;ncia de dados</p></li><li><p>Preemptivo: um processo em execu&ccedil;&atilde;o pode ser suspenso para dar lugar &agrave; execu&ccedil;&atilde;o de outro processo que est&aacute; esperando para ser executado</p><p>N&atilde;o preemptivo: uma vez alocada a CPU a um processo, esse &eacute; executado at&eacute; o fim ou quando o processo aguarda por algum recurso bloqueado.</p></li><li><p>Linux: Round Robin com prioridade Solaris:</p></li><li><p>Uma pequena unidade de tempo, denominada timeslice ou quantum, &eacute; definida. Todos os processos s&atilde;o armazenados em uma fila circular. O escalonador da CPU percorre a fila, alocando a CPU para cada processo durante um quantum. Mais precisamente, o escalonador retira o primeiro processo da fila e procede &agrave; sua execu&ccedil;&atilde;o. Se o processo n&atilde;o termina ap&oacute;s um quantum, ocorre uma preemp&ccedil;&atilde;o, e o processo &eacute; inserido no fim da fila. Se o processo termina antes de um quantum, a CPU &eacute; liberada para a execu&ccedil;&atilde;o de novos processos. Em ambos os casos, ap&oacute;s a libera&ccedil;&atilde;o da CPU, um novo processo &eacute; escolhido na fila. Novos processos s&atilde;o inseridos no fim da fila. Quando um processo &eacute; retirado da fila para a CPU, ocorre uma troca de contexto, o que resulta em um tempo adicional na execu&ccedil;&atilde;o do processo.</p></li><li><p></p></li><li><p>Situa&ccedil;&atilde;o na qual v&aacute;rios threads acessam e manipulam os mesmos dados de forma concorrente. Quando ocorre race condition, o resultado da execu&ccedil;&atilde;o do processo depende da ordem espec&iacute;fica em que o acesso aos dados acontece.</p></li><li><p>Deadlock &eacute; a situa&ccedil;&atilde;o na qual dois ou mais processos competem por um recurso sendo que, em um dado instante, um processo solicita um recurso que n&atilde;o est&aacute; dispon&iacute;vel e fica bloqueado esperando pela libera&ccedil;&atilde;o do recurso. Pode ser que, por algum motivo, o recurso nunca seja liberado, fazendo com que o processo que o est&aacute; esperando nunca seja desbloqueado e conseq&uuml;entemente n&atilde;o termine sua execu&ccedil;&atilde;o.</p><p>As condi&ccedil;&otilde;es seguintes devem ser satisfeitas num dado instante para que o deadlock ocorra: &middot; Exclus&atilde;o m&uacute;tua: apenas um processo por vez pode utilizar um dado recurso; &middot; Uso e espera: pelo menos um processo utilizando um recurso e esperando pela libera&ccedil;&atilde;o de outro &middot; Inexist&ecirc;ncia de preemp&ccedil;&atilde;o: um recurso s&oacute; pode ser liberado pelo processo que o alocou &middot; Espera circular: um conjunto de processos espera por recursos alocados por outros processos de forma circular (um depende do outro imediatamente anterior). Deadlocks s&atilde;o evitados quando pelo menos uma das quatro condi&ccedil;&otilde;es n&atilde;o &eacute; verdade. Atrav&eacute;s da sincroniza&ccedil;&atilde;o, o deadlock &eacute; evitado.</p></li><li><p>Busy wait &eacute; quando um conjunto de instru&ccedil;&otilde;es &eacute; executado infinitamente at&eacute; que uma dada condi&ccedil;&atilde;o seja satisfeita, por exemplo, enquanto um thread est&aacute; executando a se&ccedil;&atilde;o cr&iacute;tica, os outros que tentarem acessa-la dever&atilde;o executar um la&ccedil;o at&eacute; que a se&ccedil;&atilde;o cr&iacute;tica seja liberada. Os algoritmos que empregam busy wait s&atilde;o ineficientes porque consomem tempo de CPU enquanto outros threads poderiam ser executados. No bloqueio, o thread que chega &agrave; se&ccedil;&atilde;o cr&iacute;tica, que est&aacute; sendo utilizada por outro thread, &eacute; colocado em estado de espera e s&oacute; volta &agrave; execu&ccedil;&atilde;o quando a regi&atilde;o for liberada e ele for escalonado para ser executado.</p></li><li><p>Exclus&atilde;o m&uacute;tua: pro&iacute;be que mais de um thread acesse o dado compartilhado ao mesmo tempo vantagem: resolve o problema de v&aacute;rios threads alterarem o valor de um dado de forma desordenada desvantagem: n&atilde;o garante a seq&uuml;&ecirc;ncia das instru&ccedil;&otilde;es (sincroniza&ccedil;&atilde;o) Vari&aacute;veis de condi&ccedil;&atilde;o: bloqueia um thread at&eacute; que uma dada condi&ccedil;&atilde;o seja verdadeira Vantagem: resolve o problema de sincroniza&ccedil;&atilde;o Desvantagem: sinais podem ser perdidos e quando &eacute; necess&aacute;rio controlar mais de uma condi&ccedil;&atilde;o, a implementa&ccedil;&atilde;o fica complicada Sem&aacute;foros: um thread espera por um sem&aacute;foro para realizar determinada regi&atilde;o cr&iacute;tica (atomicidade na adi&ccedil;&atilde;o, remo&ccedil;&atilde;o do recurso e bloqueio do thread). Vantagem: n&atilde;o perde sinais e permite controlar grande variedade de recursos e condi&ccedil;&otilde;es de forma mais simplificada. Desvantagem:</p></li><li><p></p></li><li><p>Atomicidade de uma transa&ccedil;&atilde;o significa que uma dado opera&ccedil;&atilde;o ou &eacute; executada at&eacute; o seu fim, ou n&atilde;o &eacute; executada, ou seja, uma transa&ccedil;&atilde;o at&ocirc;mica garante a execu&ccedil;&atilde;o da opera&ccedil;&atilde;o por inteira. Se as opera&ccedil;&otilde;es de wait e signal n&atilde;o forem at&ocirc;micas, ou seja, n&atilde;o garantirem a execu&ccedil;&atilde;o do restante do c&oacute;digo do thread, o programa n&atilde;o funcionar&aacute; porque um thread ficar&aacute; esperando pelo sinal que n&atilde;o vai ser enviado pelo outro thread.</p></li><li><p></p></li><li><p></p></li><li><p></p></li><li><p></p></li><li><p></p></li></ol></div></li></ul></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="exercises_list_2.html"><img src="images/prev.gif" alt="Prev"></a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="exercises.html"><img src="images/up.gif" alt="Up"></a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="exercises_answers_2.html"><img src="images/next.gif" alt="Next"></a></td></tr><tr><td width="40%" align="left" valign="top">2.&nbsp;List 2&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/home.gif" alt="Home"></a></td><td width="40%" align="right" valign="top">&nbsp;4.&nbsp;Answers 2</td></tr></table></div></body></html>