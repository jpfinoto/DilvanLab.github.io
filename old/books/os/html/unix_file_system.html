<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>6.&nbsp;File System</title><link rel="stylesheet" href="html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.67.0"><link rel="start" href="index.html" title="Operating Systems"><link rel="up" href="unix.html" title="Chapter&nbsp;2.&nbsp;Unix"><link rel="prev" href="unix_pipes.html" title="5.&nbsp;Pipes"><link rel="next" href="threads.html" title="Chapter&nbsp;3.&nbsp;Threads"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">6.&nbsp;File System</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="unix_pipes.html"><img src="images/prev.gif" alt="Prev"></a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;2.&nbsp;Unix</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="threads.html"><img src="images/next.gif" alt="Next"></a></td></tr></table><hr></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="unix_file_system"></a>6.&nbsp;File System</h2></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>The File system</p><p>In Unix the separate file systems the system may use are not accessed by device identifiers but instead they are combined into a single hierarchical tree structure that represents the file system as one whole single entity.</p><p><span class="bold"><strong>Virtual File System</strong></span> VFS allows Linux to support many, often very different, file systems, each presenting a common software interface to the VFS.</p><p><span class="bold"><strong>Block Devices</strong></span></p><div class="itemizedlist"><ul type="circle"><li><p>All file system use an Unix block device.</p></li><li><p>All kinds of disks (IDE, floppy, SCSI, etc) are mapped into a block device.</p></li></ul></div><p>A block device model any disk as a linear array of characters with a pointer that can be randomly moved to allow any block of characters to be read.</p></li><li><p>The Second Extended File system (EXT2)</p><p>EXT2 defines the file system topology by describing each file in the system with an inode data structure, it is the most used system in Linux.</p><p><span class="bold"><strong>inodes</strong></span> An inode describes which blocks the data within a file occupies as well as the access rights of the file, the file's modification times and the type of the file.</p><div class="itemizedlist"><ul type="circle"><li><p>Every file in the EXT2 file system is described by a single inode and each inode has a single unique number identifying it.</p></li><li><p>The inodes for the file system are all kept together in inode tables.</p></li></ul></div><p><span class="emphasis"><em><span class="emphasis"><em><span class="bold"><strong>Directories</strong></span></em></span></em></span> EXT2 directories are simply special files (themselves described by inodes) which contain pointers to the inodes of their directory entries.</p><p><span class="bold"><strong>Blocks</strong></span> The EXT2 file system divides the logical partition that it occupies into Block Groups:</p><div class="figure"><a name="d0e1410"></a><p class="title"><b>Figure&nbsp;2.10.&nbsp;Ext2 Blocks</b></p><div class="mediaobject"><img src="resources/ext2.gif" alt="Ext2 Blocks"></div></div><p>Block devices are just a series of blocks that can be read and written. Each group duplicates information critical to the integrity of the file system as well as holding real files and directories as blocks of information and data. This duplication is necessary for file system recovering.</p><p><span class="bold"><strong>The EXT2 Inode</strong></span></p><div class="figure"><a name="d0e1421"></a><p class="title"><b>Figure&nbsp;2.11.&nbsp;Ext2 Inode</b></p><div class="mediaobject"><img src="resources/ext2_inode.gif" alt="Ext2 Inode"></div></div><p>In the EXT2 file system, the inode is the basic building block; every file and directory in the file system is described by one and only one inode. The EXT2 inodes for each Block Group are kept in the inode table together with a bitmap that allows the system to keep track of allocated and unallocated inodes. It contains the following fields:</p><p><span class="bold"><strong>mode</strong></span> This holds two pieces of information; what this inode describes and the permissions that users have to it. For EXT2, an inode can describe one of file, directory, symbolic link, block device, character device or FIFO.</p><p><span class="bold"><strong>Owner Information</strong></span> The user and group identifiers of the owners of this file or directory.</p><p><span class="bold"><strong>Size</strong></span> The size of the file in bytes,</p><p><span class="bold"><strong>Timestamps</strong></span> The time that the inode was created and the last time that it was modified,</p><p><span class="bold"><strong>Datablocks</strong></span> Pointers to the blocks that contain the data that this inode is describing. The first twelve are pointers to the physical blocks containing the data described by this inode and the last three pointers contain more and more levels of indirection.</p><p><span class="bold"><strong>The EXT2 Superblock</strong></span> The Superblock contains a description of the basic size and shape of this file system. The information within it allows the file system manager to use and maintain the file system. Usually only the Superblock in Block Group 0 is read when the file system is mounted but each Block Group contains a duplicate copy in case of file system corruption.</p><p><span class="bold"><strong>Magic Number</strong></span> This allows the mounting software to check that this is indeed the Superblock for an EXT2 file system. For the current version of EXT2 this is 0xEF53.</p><p><span class="bold"><strong>Revision Level</strong></span> The major and minor revision levels allow the mounting code to determine whether or not this file system supports features that are only available in particular revisions of the file system.</p><p><span class="bold"><strong>Mount Count and Maximum Mount Count</strong></span> Together these allow the system to determine if the file system should be fully checked.</p><p><span class="bold"><strong>Block Group Number </strong></span> The Block Group number that holds this copy of the Superblock,</p><p><span class="bold"><strong>Block Size</strong></span> The size of the block for this file system in bytes, for example 1024 bytes,</p><p><span class="bold"><strong>Blocks per Group </strong></span> The number of blocks in a group. Like the block size this is fixed when the file system is created,</p><p><span class="bold"><strong>Free Blocks </strong></span> The number of free blocks in the file system,</p><p><span class="bold"><strong>Free Inodes </strong></span> The number of free Inodes in the file system,</p><p><span class="bold"><strong>First Inode </strong></span> This is the inode number of the first inode in the file system. The first inode in an EXT2 root file system would be the directory entry for the '/' directory.</p><p><span class="bold"><strong>The EXT2 Group Descriptor</strong></span> Each Block Group has a data structure describing it. Like the Superblock, all the group descriptors for all of the Block Groups are duplicated in each Block Group in case of file system corruption.</p><p><span class="bold"><strong>Blocks Bitmap</strong></span> The block number of the block allocation bitmap for this Block Group.</p><p><span class="bold"><strong>Inode Bitmap</strong></span> The block number of the inode allocation bitmap for this Block Group.</p><p><span class="bold"><strong>Inode Table</strong></span> The block number of the starting block for the inode table for this Block Group. Each inode is represented by the EXT2 inode data structure described below.</p><p><span class="bold"><strong>Free blocks count, Free Inodes count, Used directory count</strong></span> The group descriptors are placed on after another and together they make the group descriptor table. Each Blocks Group contains the entire table of group descriptors after its copy of the Superblock. Only the first copy (in Block Group 0) is actually used by the EXT2 file system. The other copies are there, like the copies of the Superblock, in case the main copy is corrupted.</p><p><span class="bold"><strong>EXT2 Directories</strong></span></p><div class="figure"><a name="d0e1512"></a><p class="title"><b>Figure&nbsp;2.12.&nbsp;Ext2 Directories</b></p><div class="mediaobject"><img src="resources/ext2_dir.gif" alt="Ext2 Directories"></div></div><p>In the EXT2 file system, directories are special files that are used to create and hold access paths to the files in the file system. A directory file is a list of directory entries, each one containing the following information:</p><p><span class="bold"><strong>inode</strong></span> The inode for this directory entry. This is an index into the array of inodes held in the Inode Table of the Block Group.</p><p><span class="bold"><strong>name length </strong></span> The length of this directory entry in bytes,</p><p><span class="bold"><strong>name </strong></span> The name of this directory entry.</p></li><li><p>The Virtual File System (VFS)</p><p>The VFS maintains data structures that describe the whole (virtual) file system and the real, mounted, file systems. The VFS describes the system's files in terms of superblocks and inodes in much the same way as the EXT2 file system uses superblocks and inodes.</p><div class="figure"><a name="d0e1537"></a><p class="title"><b>Figure&nbsp;2.13.&nbsp;VFS - Virtual File System</b></p><div class="mediaobject"><img src="resources/vfs.gif" alt="VFS - Virtual File System"></div></div><p>The VFS inodes describe files and directories within the system; the contents and topology of the Virtual File System.</p><div class="itemizedlist"><ul type="circle"><li><p>As each file system is initialised, it registers itself with the VFS.</p></li><li><p>This happens as the operating system initialises itself at system boot time</p></li><li><p>The real file systems are either built into the kernel itself or are built as loadable modules.</p></li></ul></div><p>When a block device based file system is mounted, and this includes the root file system, the VFS must read its superblock. Each file system type's superblock read routine must work out the file system's topology and map that information onto a VFS superblock data structure. The VFS keeps a list of the mounted file systems in the system together with their VFS superblocks. Each VFS superblock contains information and pointers to routines that perform particular functions.</p><div class="itemizedlist"><ul type="circle"><li><p>The superblock representing a mounted EXT2 file system contains a pointer to the EXT2 specific inode reading routine.</p></li><li><p>This EXT2 inode read routine, like all of the file system specific inode read routines, fills out the fields in a VFS inode.</p></li><li><p>Each VFS superblock contains a pointer to the first VFS inode on the file system. For the root file system, this is the inode that represents the ``/'' directory.</p></li><li><p>This mapping of information is very efficient for the EXT2 file system but moderately less so for other file systems.</p></li></ul></div><p>As the system's processes access directories and files, system routines are called that traverse the VFS inodes in the system.</p><p><span class="bold"><strong>The VFS Inode</strong></span> Like the EXT2 file system, every file, directory and so on in the VFS is represented by one and only one VFS inode. The information in each VFS inode is built from information in the underlying file system by file system specific routines. VFS inodes exist only in the kernel's memory and are kept in the VFS inode cache as long as they are useful to the system.</p><p><span class="bold"><strong>Mounting a File System</strong></span> Consider the following mount command:</p><pre class="programlisting">$ mount -t iso9660 -o ro /dev/cdrom /mnt/cdrom
</pre><p>This mount command will pass the kernel three pieces of information; the name of the file system, the physical block device that contains the file system and, thirdly, where in the existing file system topology the new file system is to be mounted.</p><div class="figure"><a name="d0e1584"></a><p class="title"><b>Figure&nbsp;2.14.&nbsp;Mount Structure</b></p><div class="mediaobject"><img src="resources/mounted.gif" alt="Mount Structure"></div></div></li><li><p>The /proc File System</p><p>The /proc file system really shows the power of the Virtual File System. It does not really exist, neither the /proc directory nor its subdirectories and its files actually exist:</p><div class="itemizedlist"><ul type="circle"><li><p>The /proc file system, like a real file system, registers itself with the Virtual File System.</p></li><li><p>When the VFS makes calls to it requesting inodes as its files and directories are opened, the /proc file system creates those files and directories from information within the kernel.</p></li></ul></div></li></ul></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="unix_pipes.html"><img src="images/prev.gif" alt="Prev"></a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="unix.html"><img src="images/up.gif" alt="Up"></a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="threads.html"><img src="images/next.gif" alt="Next"></a></td></tr><tr><td width="40%" align="left" valign="top">5.&nbsp;Pipes&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/home.gif" alt="Home"></a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;3.&nbsp;Threads</td></tr></table></div></body></html>