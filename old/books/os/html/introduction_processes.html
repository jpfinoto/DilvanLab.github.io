<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>2.&nbsp;Process</title><link rel="stylesheet" href="html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.67.0"><link rel="start" href="index.html" title="Operating Systems"><link rel="up" href="introduction.html" title="Chapter&nbsp;1.&nbsp;Introduction"><link rel="prev" href="introduction_operating_systems.html" title="1.&nbsp;Operating Systems"><link rel="next" href="introduction_memory_management.html" title="3.&nbsp;Memory Management"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2.&nbsp;Process</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="introduction_operating_systems.html"><img src="images/prev.gif" alt="Prev"></a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;1.&nbsp;Introduction</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="introduction_memory_management.html"><img src="images/next.gif" alt="Next"></a></td></tr></table><hr></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="introduction_processes"></a>2.&nbsp;Process</h2></div></div></div><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>Process</p><p>Main concept in a operating system: is a running program abstraction.</p><div class="figure"><a name="d0e161"></a><p class="title"><b>Figure&nbsp;1.2.&nbsp;Processes</b></p><div class="mediaobject"><img src="resources/fig1_2.gif" alt="Processes"></div></div><p><span class="bold"><strong>Pseudo parallelism:</strong></span> The CPU is switched between processes, given the illusion of parallelism.</p></li><li style="list-style-type: disc"><p>Process Model</p><div class="itemizedlist"><ul type="disc"><li><p>All programs, including the operating system, are organized in a sequential process set.</p></li><li><p>In a concept model, each process has its own CPU.</p></li><li><p>Multiprogramming is used to switch the CPU between processes.</p><div class="figure"><a name="d0e184"></a><p class="title"><b>Figure&nbsp;1.3.&nbsp;Process Model</b></p><div class="mediaobject"><img src="resources/fig1_3.gif" alt="Process Model"></div></div></li></ul></div><p><span class="bold"><strong>Attention:</strong></span></p><div class="itemizedlist"><ul type="disc"><li><p>Depending on how the CPU is switched, process execution time vary.</p></li><li><p>Execution at different moments may results in different execution time.</p></li><li><p>In UNIX, time considerations for use in real-time applications are not reliable.</p></li></ul></div></li><li style="list-style-type: disc"><p>Analogy</p><div class="itemizedlist"><ul type="disc"><li><p>Computer scientist making a cake. </p><div class="itemizedlist"><ul type="circle" compact><li>RECIPE: program</li><li>COMPUTER SCIENTIST: CPU</li><li>INGREDIENTS: input data</li><li><p>PROCESS: activities: </p><div class="itemizedlist"><ul type="disc" compact><li>read the recipe</li><li>find the ingredients</li><li>bake the cake.</li></ul></div></li></ul></div></li><li><p>Interruptions are possible: son is attacked by bee and run into kitchen. </p><div class="itemizedlist"><ul type="circle"><li>Computer scientist records his stage in the recipe.</li><li>Take a first emergency book (another program)</li><li>Follow the instructions (another program)</li></ul></div></li></ul></div></li><li style="list-style-type: disc"><p>Process States</p><div class="figure"><a name="d0e249"></a><p class="title"><b>Figure&nbsp;1.4.&nbsp;Process States</b></p><div class="mediaobject"><img src="resources/fig1_5.gif" alt="Process States"></div></div><div class="itemizedlist"><ul type="disc"><li style="list-style-type: none">1. Process block for input</li><li style="list-style-type: none">2. Scheduler searches for another process</li><li style="list-style-type: none">3. Schedule picks a process</li><li style="list-style-type: none">4. Input becomes available</li></ul></div></li><li style="list-style-type: disc"><p>Implementation</p><div class="figure"><a name="d0e271"></a><p class="title"><b>Figure&nbsp;1.5.&nbsp;Process Implementation</b></p><div class="mediaobject"><img src="resources/fig1_6.gif" alt="Process Implementation"></div></div><div class="orderedlist"><ol type="1"><li><p>Device (disc) starts an interruption</p></li><li><p>Hardware puts on stack:</p><div class="orderedlist"><ol type="a"><li><p>Program Counter</p></li><li><p>Program status word</p></li><li><p>registers</p></li></ol></div></li><li><p>CPU jumps to the specified address to serve the interruption</p></li><li><p>Attendant service save all register (assembly)</p></li><li><p>Attendant service runs the service</p></li><li><p>Attendant service finds which process requested the service</p></li><li><p>The process state is changed from blocked to ready</p></li><li><p>The scheduler is called to select next process</p></li><li><p>The control returns to the attendant service</p></li><li><p>The registers are reload</p></li><li><p>The process restarts</p></li></ol></div></li><li style="list-style-type: disc"><p>A Process Consists of:</p><div class="itemizedlist"><ul type="disc" compact><li>An executable program</li><li>Data and program stacks</li><li>A program counter</li><li>A stack pointer</li><li>Registers</li></ul></div><p><span class="bold"><strong>Preemptive Multitasking: </strong></span>the OS periodically decides to stop the execution of a process and starts the execution of the another process. Eventually, the stopped process must come back to the execution point where it was when it was interrupted.</p><p>All process information must be explicitly stored. Process tables implement this.</p><p><span class="bold"><strong>Process tables implement this.</strong></span></p></li><li style="list-style-type: disc"><p>A Suspend Process Consists of: </p><div class="itemizedlist"><ul type="disc" compact><li>Its address space (core image)</li><li>Its process table (registers)</li></ul></div><p>Example:</p><div class="itemizedlist"><ul type="disc" compact><li>a shell process reads commands (from terminal)</li><li>a user inputs a command (Ex: program compilation)</li><li>the shell starts a process (child) to run the compiler</li><li>this process runs the compilation and activates a System Call to kill itself</li><li><p>control goes back to the shell process.</p><pre class="programlisting">while (TRUE) { 

    read_command (command, parameters); 

    if (fork() != 0){ 

      wait (&amp;status); 

    } else 

   execve (command, parameters, 0); 

  } </pre></li></ul></div></li><li style="list-style-type: disc"><p>Process can create processes</p><div class="figure"><a name="d0e382"></a><p class="title"><b>Figure&nbsp;1.6.&nbsp;Process Tree</b></p><div class="mediaobject"><img src="resources/fig1_7.gif" alt="Process Tree"></div></div><p>Other process System Calls:</p><div class="itemizedlist"><ul type="disc"><li><p>Memory request</p></li><li><p>Wait a child process termination</p></li><li><p>Memory reallocation</p></li></ul></div></li><li style="list-style-type: disc"><p>Signals</p><p>Signals are OS mechanisms to notify events to processes. A signal can suspend, in a temporary way, process execution, save his registers on stacks and start a special program to treat it.</p><p>Ex: time out, memory violation, etc.</p></li><li style="list-style-type: disc"><p>UID</p><div class="itemizedlist"><ul type="disc"><li><p>Each authorized person to use the system has a UID (user identification).</p></li><li><p>Each started process has the UID from the user that started it.</p></li><li><p>The super-user has a special UID. This UID can violate the protection rules.</p></li></ul></div></li><li style="list-style-type: disc"><p>Files</p><p>The second bigger set of System Calls works with the FILE SYSTEM.</p><p>Main function of the OS: hide particularities from discs and other I/O devices. The programmer must have an abstract model of the file system. This model must be independent of file system devices implementation.</p><p>Directory tree is a UNIX key concept, used to group files:</p><div class="figure"><a name="d0e429"></a><p class="title"><b>Figure&nbsp;1.7.&nbsp;File System Tree</b></p><div class="mediaobject"><img src="resources/fig1_8.gif" alt="File System Tree"></div></div><p>The processes and files hierarchy are both organized in trees. However, they have many differences:</p><div class="itemizedlist"><ul type="disc"><li><p>Process hierarchies are not very depth, but file hierarchies are.</p></li><li><p>Process hierarchies have a short life. File hierarchies can last for years.</p></li><li><p>Normally, child processes can be accessed or modified only by their parent process, while files can be accessed by anyone.</p></li><li><p>Each file, in a directory hierarchy, can be specified using its pathname.</p></li><li><p>A "/" on the beginning of a file pathname indicates that the path is absolute.</p></li><li><p>On each moment, each process has a working directory, used to find processes' files without absolute pathnames.</p></li></ul></div></li></ul></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="introduction_operating_systems.html"><img src="images/prev.gif" alt="Prev"></a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="introduction.html"><img src="images/up.gif" alt="Up"></a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="introduction_memory_management.html"><img src="images/next.gif" alt="Next"></a></td></tr><tr><td width="40%" align="left" valign="top">1.&nbsp;Operating Systems&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/home.gif" alt="Home"></a></td><td width="40%" align="right" valign="top">&nbsp;3.&nbsp;Memory Management</td></tr></table></div></body></html>