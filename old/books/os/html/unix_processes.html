<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>3.&nbsp;Processes</title><link rel="stylesheet" href="html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.67.0"><link rel="start" href="index.html" title="Operating Systems"><link rel="up" href="unix.html" title="Chapter&nbsp;2.&nbsp;Unix"><link rel="prev" href="unix_memory_management.html" title="2.&nbsp;Memory Management"><link rel="next" href="unix_signals.html" title="4.&nbsp;Signals"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3.&nbsp;Processes</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="unix_memory_management.html"><img src="images/prev.gif" alt="Prev"></a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;2.&nbsp;Unix</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="unix_signals.html"><img src="images/next.gif" alt="Next"></a></td></tr></table><hr></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="unix_processes"></a>3.&nbsp;Processes</h2></div></div></div><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>Processes</strong></span></p><p><span class="bold"><strong>Definition</strong></span>:</p><p>Processes carry out tasks within the operating system. A program is a set of machine code instructions and data stored in an executable image on disk and is a passive entity; a process can be thought of as a computer program in action.</p></li><li><p><span class="bold"><strong>Identifiers</strong></span></p><p><span class="emphasis"><em><span class="emphasis"><em>Every process in the system has a process identifier. It is simply a number. Each process also has User and group identifiers, these are used to control this processes access to the files and devices in the system.</em></span></em></span></p></li><li><p><span class="bold"><strong>State</strong></span></p><p><span class="emphasis"><em><span class="emphasis"><em><span class="bold"><strong>Running</strong></span> The process is either running (it is the current process in the system) or it is ready to run (it is waiting to be assigned to one of the system's CPUs). </em></span></em></span></p><p><span class="emphasis"><em><span class="emphasis"><em><span class="bold"><strong> Waiting</strong></span> The process is waiting for an event or for a resource. Linux differentiates between two types of waiting process; interruptible and uninterruptible. Interruptible waiting processes can be interrupted by signals whereas uninterruptible waiting processes are waiting directly on hardware conditions and cannot be interrupted under any circumstances. </em></span></em></span></p><p><span class="emphasis"><em><span class="emphasis"><em><span class="bold"><strong> Stopped </strong></span> The process has been stopped, usually by receiving a signal. A process that is being debugged can be in a stopped state. </em></span></em></span></p><p><span class="emphasis"><em><span class="emphasis"><em><span class="bold"><strong> Zombie </strong></span> This is a halted process which, for some reason, still has a data structure representing it. It is what it sounds like, a dead process.</em></span></em></span></p></li><li><p><span class="bold"><strong>Scheduling</strong></span></p><p><span class="emphasis"><em><span class="emphasis"><em>Processes are always making system calls and so may often need to wait. Even so, if a process executes until it waits then it still might use a disproportionate amount of CPU time and so Linux uses preemptive scheduling: </em></span></em></span></p><p><span class="emphasis"><em><span class="emphasis"><em><span class="bold"><strong> time-slice</strong></span> </em></span></em></span></p><p><span class="emphasis"><em><span class="emphasis"><em> In this scheme, each process is allowed to run for a small amount of time, 200ms, and, when this time has expired another process is selected to run and the original process is made to wait for a little while until it can run again.</em></span></em></span></p><p><span class="emphasis"><em><span class="emphasis"><em>Each time the scheduler is run it does the following:</em></span></em></span></p><p><span class="emphasis"><em><span class="emphasis"><em><span class="bold"><strong>kernel work </strong></span> The scheduler runs the bottom half handlers and processes the scheduler task queue. </em></span></em></span></p><p><span class="emphasis"><em><span class="emphasis"><em><span class="bold"><strong>Current process</strong></span> The current process must be processed before another process can be selected to run. </em></span></em></span></p><p><span class="emphasis"><em><span class="emphasis"><em><span class="bold"><strong>Process selection</strong></span> The scheduler looks through the processes on the run queue looking for the most deserving process to run. If there are any real time processes (those with a real time scheduling policy) then those will get a higher weighting than ordinary processes. </em></span></em></span></p><p><span class="emphasis"><em><span class="emphasis"><em><span class="bold"><strong>Round Robin</strong></span> If several processes have the same priority, the one nearest the front of the run queue is chosen. The current process will get put onto the back of the run queue. In a balanced system with many processes of the same priority, each one will run in turn. </em></span></em></span></p><p><span class="emphasis"><em><span class="emphasis"><em><span class="bold"><strong>Swap processes</strong></span> If the most deserving process to run is not the current process, then the current process must be suspended and the new one made to run.</em></span></em></span></p></li><li><p><span class="bold"><strong>Files</strong></span></p><div class="figure"><a name="d0e1151"></a><p class="title"><b>Figure&nbsp;2.4.&nbsp;Files</b></p><div class="mediaobject"><img src="resources/files.gif" alt="Files"></div></div><p><span class="emphasis"><em>fs_struct </em></span> contains pointers to this process's VFS inodes and its umask. The umask is the default mode that new files will be created in, and it can be changed via system calls.</p><p><span class="emphasis"><em>files_struct </em></span> contains information about all of the files that this process is currently using.</p></li><li><p><span class="bold"><strong>Virtual Memory</strong></span></p><p>A process's virtual memory contains executable code and data from many sources:</p><div class="itemizedlist"><ul type="circle"><li><p><span class="bold"><strong>The program image</strong></span> that is loaded; for example a command like ls. This command is composed of both executable code and data.</p></li><li><p><span class="bold"><strong>Allocated (virtual) memory</strong></span> to use during their processing. This newly allocated, virtual, memory needs to be linked into the process's existing virtual memory so that it can be used.</p></li><li><p><span class="bold"><strong>Libraries of commonly useful code</strong></span>. The code and the data from shared libraries must be linked into the process's virtual address space and also into the virtual address space of the other processes sharing it.</p><div class="figure"><a name="d0e1187"></a><p class="title"><b>Figure&nbsp;2.5.&nbsp;Virtual Memory</b></p><div class="mediaobject"><img src="resources/process-vm.gif" alt="Virtual Memory"></div></div></li></ul></div></li><li><p><span class="bold"><strong>Creating a Process</strong></span></p><p>When the system starts up it is running in kernel mode and there is, in a sense, only one process, the initial process (Idle). Like all processes, the initial process has a machine state represented by stacks, registers and so on.</p><p><span class="bold"><strong>init kernel thread</strong></span> At the end of system initialization, the initial process starts up a kernel thread (called init) and then sits in an idle loop doing nothing. The init kernel thread or process has a process identifier of 1 as it is the system's first real process. It does some initial setting up of the system (such as opening the system console and mounting the root file system) and then executes the system initialization program. This is one of /etc/init, /bin/init or /sbin/init depending on your system. The init program uses /etc/inittab as a script file to create new processes within the system. New processes are created by cloning old processes, or rather by cloning the current process. A new task is created by a system call (fork or clone) and the cloning happens within the kernel in kernel mode. At the end of the system call there is a new process waiting to run once the scheduler chooses it.</p><p><span class="bold"><strong>Exec call</strong></span> After a process has been cloned a call to the system call exec will replace its current code image for a new one, from a different executable, and the process can begin to run a new application.</p></li><li><p><span class="bold"><strong>Links</strong></span></p><p>Every process in the system, except the initial process has a parent process. New processes are not created, they are copied, or rather cloned from previous processes.</p><pre class="programlisting">init(1)-+-crond(98) |-emacs(387) |-gpm(146) |-inetd(110) |-kerneld(18) |-kflushd(2) |-klogd(87) |-kswapd(3) |-login(160)---bash(192)---emacs(225) |-lpd(121) |-mingetty(161) |-mingetty(162) |-mingetty(163) |-mingetty(164) |-login(403)---bash(404)---pstree(594) |-sendmail(134) |-syslogd(78) `-update(166)</pre></li></ul></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="unix_memory_management.html"><img src="images/prev.gif" alt="Prev"></a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="unix.html"><img src="images/up.gif" alt="Up"></a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="unix_signals.html"><img src="images/next.gif" alt="Next"></a></td></tr><tr><td width="40%" align="left" valign="top">2.&nbsp;Memory Management&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/home.gif" alt="Home"></a></td><td width="40%" align="right" valign="top">&nbsp;4.&nbsp;Signals</td></tr></table></div></body></html>