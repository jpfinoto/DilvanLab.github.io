<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>3.&nbsp;Scheduling</title><link rel="stylesheet" href="html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.67.0"><link rel="start" href="index.html" title="Operating Systems"><link rel="up" href="threads.html" title="Chapter&nbsp;3.&nbsp;Threads"><link rel="prev" href="threads_lightweight_process.html" title="2.&nbsp;Lightweight Process"><link rel="next" href="threads_synchronization.html" title="4.&nbsp;Synchronization"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3.&nbsp;Scheduling</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="threads_lightweight_process.html"><img src="images/prev.gif" alt="Prev"></a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;3.&nbsp;Threads</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="threads_synchronization.html"><img src="images/next.gif" alt="Next"></a></td></tr></table><hr></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="threads_scheduling"></a>3.&nbsp;Scheduling</h2></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>Thread Scheduling</p><p>The threads library implements a thread scheduler that multiplexes thread execution across a pool of LWPs.</p><div class="figure"><a name="d0e1832"></a><p class="title"><b>Figure&nbsp;3.3.&nbsp;Thread Scheduling</b></p><div class="mediaobject"><img src="resources/Parallel6.gif" alt="Thread Scheduling"></div></div><div class="orderedlist"><ol type="1"><li><p>An LWP in the pool is either idling or running a thread.</p></li><li><p>When a thread, T1 is made runnable, it is added to the dispatch queue.</p></li><li><p>An idle LWP L1 in the pool is awakened by signalling the idle synchronization variable.</p></li><li><p>LWP L1 wakes up and switches to the highest priority thread on the dispatch queue.</p></li><li><p>If T1 blocks on a local synchronization object, L1 puts T1 on a sleep queue and then switches to the highest priority thread on the dispatch queue.</p></li><li><p>If the dispatch queue is empty, the LWP goes back to idling.</p></li><li><p>If all LWPs in the pool are busy when T1 becomes runnable, T1 simply stays on the dispatch queue, waiting for an LWP to become available.</p></li></ol></div><p>An LWP becomes available either when a new one is added to the pool or when one of the running threads blocks on a process-local synchronization variable, exits or stops, freeing its LWP.</p></li></ul></div><div class="itemizedlist"><ul type="disc"><li><p>Thread States</p><p>An unbound thread can be in one of five different states:</p><div class="itemizedlist"><ul type="circle"><li><p>RUNNABLE</p></li><li><p>ACTIVE</p></li><li><p>SLEEPING</p></li><li><p>STOPPED</p></li><li><p>ZOMBIE</p></li></ul></div><p>The transitions between these states and the events that cause these transitions are:</p><div class="figure"><a name="d0e1886"></a><p class="title"><b>Figure&nbsp;3.4.&nbsp;Thread States</b></p><div class="mediaobject"><img src="resources/Parallel7.gif" alt="Thread States"></div></div></li></ul></div><div class="itemizedlist"><ul type="disc"><li><p>Preemption</p><p>Threads compete for LWPs based on their priorities.</p><p>A queue of ACTIVE threads is maintained.</p><p>If a RUNNABLE thread has a higher priority than that of some ACTIVE thread:</p><div class="orderedlist"><ol type="1"><li><p>This thread is removed from the ACTIVE queue and preempted from its LWP.</p></li><li><p>This LWP then schedules the higher priority RUNNABLE thread which caused the preemption.</p></li></ol></div><p>There are basically two cases when the need to preempt arises:</p><div class="itemizedlist"><ul type="circle"><li><p>When a newly RUNNABLE thread has a higher priority than that of the lowest priority ACTIVE thread.</p></li><li><p>When the priority of an ACTIVE thread is lowered below that of the highest priority RUNNABLE thread.</p></li></ul></div><p><span class="bold"><strong>Cleaning ZOMBIE Threads:</strong></span></p><p>When a thread terminates, it is put on a deathrow queue and their state is set to ZOMBIE.</p><p><span class="bold"><strong>Note:</strong></span> The action of freeing a thread's stack is not done at thread exit time to minimize the cost of thread exit by deferring unnecessary and expensive work.</p><p>A special thread called the reaper does this job periodically:</p><div class="itemizedlist"><ul type="circle"><li><p>The reaper runs when there are idle LWPs, or when a reap limit is reached.</p></li><li><p>The reaper traverses the deathrow list, freeing the stack for each thread.</p></li></ul></div></li></ul></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="threads_lightweight_process.html"><img src="images/prev.gif" alt="Prev"></a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="threads.html"><img src="images/up.gif" alt="Up"></a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="threads_synchronization.html"><img src="images/next.gif" alt="Next"></a></td></tr><tr><td width="40%" align="left" valign="top">2.&nbsp;Lightweight Process&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/home.gif" alt="Home"></a></td><td width="40%" align="right" valign="top">&nbsp;4.&nbsp;Synchronization</td></tr></table></div></body></html>