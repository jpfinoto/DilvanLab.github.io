<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>1.&nbsp;List 1</title><link rel="stylesheet" href="html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.67.0"><link rel="start" href="index.html" title="Operating Systems"><link rel="up" href="exercises.html" title="Chapter&nbsp;9.&nbsp;Exercises"><link rel="prev" href="exercises.html" title="Chapter&nbsp;9.&nbsp;Exercises"><link rel="next" href="exercises_list_2.html" title="2.&nbsp;List 2"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">1.&nbsp;List 1</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="exercises.html"><img src="images/prev.gif" alt="Prev"></a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;9.&nbsp;Exercises</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="exercises_list_2.html"><img src="images/next.gif" alt="Next"></a></td></tr></table><hr></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="exercises_list_1"></a>1.&nbsp;List 1</h2></div></div></div><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>List 1</strong></span></p><div class="orderedlist"><ol type="1"><li><p>Quais s&atilde;o as principais atividades de um sistema operacional em rela&ccedil;&atilde;o ao gerenciamento: de mem&oacute;ria e de processos.</p></li><li><p>Diferencie os termos processos, threads e programas.</p></li><li><p>Explique a diferen&ccedil;a entre criar um processo e criar um thread. O que &eacute; compartilhado entre os threads de um processo.</p></li><li><p>Descreva as a&ccedil;&otilde;es realizadas pelo n&uacute;cleo de um SO para uma mudan&ccedil;a de contexto: &middot; entre threads e entre processos.</p></li><li><p>Um programa pode gerar m&uacute;ltiplos processos. D&ecirc; um exemplo de um problema que pode ser resolvido fazendo-se v&aacute;rias computa&ccedil;&otilde;es independentemente.</p></li><li><p>Fa&ccedil;a um esquema que represente os estados de um processo e explique como cada estado pode ocorrer.</p></li><li><p>Cite e explique os estados dos threads.</p></li><li><p>Para que servem as &#8220;systems calls&#8221;?</p></li><li><p>Qual a fun&ccedil;&atilde;o do gerenciamento de mem&oacute;ria em um sistema operacional?</p></li><li><p>Quais s&atilde;o as vantagens do uso de threads sobre o uso de m&uacute;ltiplos processos? Qual a maior desvantagem que apresentam? Sugira uma aplica&ccedil;&atilde;o que se beneficiaria do uso de threads e uma que n&atilde;o se beneficiaria.</p></li><li><p>Qual &eacute; a diferen&ccedil;a fundamental entre escalonamento preemptivo e escalonamento n&atilde;o preemptivo?</p></li><li><p>Qual o tipo de escalonamento feito nos sistemas Linux e Solaris?</p></li><li><p>Como funciona o escalonamento Round Robin?</p></li><li><p>A maioria dos escalonadores Round Robin usa um quantum de tamanho fixo. Pense em algum argumento em favor de um quantum pequeno. Agora pense em um argumento que justifique um quantum grande.</p></li><li><p>Explique o que &eacute; race condition.</p></li><li><p>O que &eacute; deadlock? Quais s&atilde;o as quatro condi&ccedil;&otilde;es necess&aacute;rias para que o deadlock ocorra? Como ele pode ser evitado?</p></li><li><p>Explique o que &eacute; busy wait (espera ocupada) e por que os algoritmos que empregam essa t&eacute;cnica s&atilde;o considerados ineficientes. Qual a diferen&ccedil;a com bloqueio?</p></li><li><p>Explique cada um dos mecanismos de sincroniza&ccedil;&atilde;o abaixo apontando vantagens e desvantagens: - exclus&atilde;o m&uacute;tua - vari&aacute;veis de condi&ccedil;&atilde;o - sem&aacute;foros</p></li><li><p>Utilizando o programa do exerc&iacute;cio 3 da pr&aacute;tica 4 (produtor/consumidor), fa&ccedil;a a implementa&ccedil;&atilde;o utilizando sem&aacute;foros.</p></li><li><p>Explique o conceito de atomicidade de uma transa&ccedil;&atilde;o. Mostre que, se as opera&ccedil;&otilde;es wait e signal n&atilde;o forem executadas atomicamente, n&atilde;o se pode garantir a exclus&atilde;o m&uacute;tua.</p></li><li><p>O problema do Barbeiro Dorminhoco. Uma barbearia consiste de uma sala de espera com N cadeiras, e a sala do barbeiro com a cadeira do mesmo. Se n&atilde;o h&aacute; clientes a serem servidos, o barbeiro vai dormir. Se um cliente entra na barbearia e todas as cadeiras est&atilde;o ocupadas, ent&atilde;o o cliente deixa a barbearia. Se o barbeiro est&aacute; ocupado, mas h&aacute; cadeiras dispon&iacute;veis, ent&atilde;o o cliente senta em uma das cadeiras livres. Se o barbeiro est&aacute; dormindo, ent&atilde;o o cliente acorda o barbeiro. Escreva um programa que represente a situa&ccedil;&atilde;o acima, coordenando o barbeiro e os clientes. Dicas: crie um processo barbeiro e um cliente e use sem&aacute;foros na sincroniza&ccedil;&atilde;o.</p></li><li><p>A solu&ccedil;&atilde;o adotada no exerc&iacute;cio anterior pode ser generalizada para o caso de mais de um barbeiro? Se sim, mostre como.</p></li><li><p>Considere 5 (cinco) fil&oacute;sofos que passam a vida comendo e pensando. Eles ficam todos em uma mesa circular com cinco cadeiras, sendo cada cadeira pertencente ao um fil&oacute;sofo. Uma travessa de espaguete fica no cento da mesa, que &eacute; posta com cinco pratos e cinco garfos usados pelos fil&oacute;sofos para comer o espaguete. Quando fica pensando, um fil&oacute;sofo n&atilde;o interage com seus colegas. De vez em quando, um fil&oacute;sofo fica com fome e tenta pegar dois garfos pr&oacute;ximos a ele (que est&atilde;o entre ele e seus vizinhos &agrave; direita e &agrave; esquerda). Um fil&oacute;sofo pode pegar apenas um garfo por vez. Obviamente, ele n&atilde;o pode pegar um garfo que j&aacute; esteja na m&atilde;o de outro fil&oacute;sofo. Quando um fil&oacute;sofo consegue pegar os dois garfos, ele come sem larg&aacute;-los. Quando termina de comer, ele coloca os garfos nos seus lugares e volta a pensar. Fa&ccedil;a o algoritmo para resolver o problema dos fil&oacute;sofos usando sem&aacute;foros.</p></li><li><p>Mostre que as quatro condi&ccedil;&otilde;es necess&aacute;rias &agrave; ocorr&ecirc;ncia de deadlocks est&atilde;o presentes no problema do jantar dos fil&oacute;sofos.</p></li><li><p>Suponha que dois processos P1 e P2 contenham, cada qual, os seguintes comandos de linguagem de alto n&iacute;vel em um loop: Num = Num + 1</p><p>if Num = 50 then</p><p>Num = 0</p><p>Suponha tamb&eacute;m que ambos compartilham a vari&aacute;vel Num e estejam ativos. Mesmo com apenas uma CPU, explique como Num pode nunca ser igual a 0 (zero).</p></li><li><p>Quais as vantagens na utiliza&ccedil;&atilde;o de sockets? Explique as diferen&ccedil;as entre stream sockets e datagram sockets. D&ecirc; exemplos de onde cada tipo pode ser melhor aplicado.</p></li></ol></div></li></ul></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="exercises.html"><img src="images/prev.gif" alt="Prev"></a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="exercises.html"><img src="images/up.gif" alt="Up"></a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="exercises_list_2.html"><img src="images/next.gif" alt="Next"></a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;9.&nbsp;Exercises&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/home.gif" alt="Home"></a></td><td width="40%" align="right" valign="top">&nbsp;2.&nbsp;List 2</td></tr></table></div></body></html>