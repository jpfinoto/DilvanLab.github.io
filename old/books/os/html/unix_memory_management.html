<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>2.&nbsp;Memory Management</title><link rel="stylesheet" href="html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.67.0"><link rel="start" href="index.html" title="Operating Systems"><link rel="up" href="unix.html" title="Chapter&nbsp;2.&nbsp;Unix"><link rel="prev" href="unix_goals.html" title="1.&nbsp;Goals"><link rel="next" href="unix_processes.html" title="3.&nbsp;Processes"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2.&nbsp;Memory Management</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="unix_goals.html"><img src="images/prev.gif" alt="Prev"></a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;2.&nbsp;Unix</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="unix_processes.html"><img src="images/next.gif" alt="Next"></a></td></tr></table><hr></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="unix_memory_management"></a>2.&nbsp;Memory Management</h2></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>Memory Management</p><p>The memory management subsystem is one of the most important parts of the operating system. It allows:</p><p><span class="bold"><strong>Large Address Spaces</strong></span> The virtual memory can be many times larger than the physical memory in the system, <span class="bold"><strong>Protection </strong></span> Each process in the system has its own virtual address space completely separate from each other and so a process running one application cannot affect another. <span class="bold"><strong>Memory Mapping</strong></span> Memory mapping is used to map image and data files into a processes address space. <span class="bold"><strong>Fair Physical Memory Allocation</strong></span> The memory management subsystem allows each running process in the system a fair share of the physical memory of the system, <span class="bold"><strong>Shared Virtual Memory </strong></span> There are times when processes share memory: when there are several processes in the system running the same program code.</p></li><li><p>An Abstract Model of Virtual Memory</p><div class="figure"><a name="d0e885"></a><p class="title"><b>Figure&nbsp;2.2.&nbsp;Virtual Memory</b></p><div class="mediaobject"><img src="resources/vm.gif" alt="Virtual Memory"></div></div><p>A virtual address is composed of two parts:</p><div class="itemizedlist"><ul type="circle"><li><p>an offset</p></li><li><p>a virtual page frame number.</p><p><span class="emphasis"><em>Pages:</em></span> virtual and physical memory are divided into handy sized chunks called pages. Each of these pages is given a unique number; the page frame number (PFN).</p><p>If the page size is 4 Kbytes, bits 11:0 of the virtual address contain the offset and bits 12 and above are the virtual page frame number:</p><p>&lt;--------- Page Frame Number --------&gt;|&lt;------ Offset ------&gt;</p><p>|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|</p><p>32 BITS Address Word</p><p>Each entry in the page table contains the following information:</p><div class="itemizedlist"><ul type="disc"><li><p>Valid flag: this indicates if this page table entry is valid,</p></li><li><p>The physical page frame number: that this entry is describing,</p></li><li><p>Access control information: this describes how the page may be used. Can it be written to? Does it contain executable code?</p></li></ul></div><p><span class="bold"><strong>Page Fault:</strong></span></p><p>The way the processor notifies the operating system that the correct process has attempted to access a virtual address for which there is no valid translation is specific to the processor.</p><p><span class="bold"><strong>Dealing with Page Faults</strong></span></p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>Invalid virtual address</strong></span>: It means that the process has attempted to access a virtual address that it should not have.</p><div class="orderedlist"><ol type="1"><li><p>The application has gone wrong in some way.</p></li><li><p>In this case the operating system will terminate it.</p></li></ol></div></li><li><p><span class="bold"><strong>Valid virtual address</strong></span>: It means that the page that it refers to is not currently in memory.</p><div class="orderedlist"><ol type="1"><li><p>The operating system must bring the appropriate page into memory from the image on disk.</p></li></ol></div></li></ul></div><p><span class="bold"><strong>Swapping</strong></span></p><p><span class="emphasis"><em><span class="emphasis"><em> Happens when the operating system needs to create new pages in the physical memory and there is no space. It will discard old pages in to create space: </em></span></em></span></p><p><span class="emphasis"><em><span class="emphasis"><em><span class="bold"><strong> Clean Pages</strong></span> If the page to be discarded came from an image or data file and has not been written to then the page does not need to be saved. It is just discarded.</em></span></em></span></p><p><span class="emphasis"><em><span class="emphasis"><em> <span class="bold"><strong>Dirty Pages </strong></span> If the page has been modified, its contents must preserve and it is saved in a special sort of file called the swap file.</em></span></em></span></p><p><span class="emphasis"><em><span class="emphasis"><em> <span class="bold"><strong> Thrashing </strong></span>: If the algorithm used to decide which pages to discard or swap is not efficient then a condition known as thrashing occurs. In this case, pages are constantly being written to disk and then being read back and the operating system is too busy to allow much real work to be performed.</em></span></em></span></p><p><span class="emphasis"><em><span class="emphasis"><em><span class="bold"><strong> Least Recently Used (LRU)</strong></span> This scheme involves every page in the system having an age which changes as the page is accessed. The more that a page is accessed, the younger it is; the less that it is accessed the older and more stale it becomes. Old pages are good candidates for swapping.</em></span></em></span></p><p><span class="bold"><strong>Physical Addressing Mode</strong></span></p><p>It does not make much sense for the operating system itself to run in virtual memory.</p><p><span class="bold"><strong>Physical addressing mode</strong></span> requires no page tables and the processor does not attempt to perform any address translations in this mode. The kernel is linked to run in physical address space.</p></li></ul></div></li><li><p>Caches</p><p><span class="bold"><strong>Buffer Cache</strong></span> These buffers are of fixed sizes (for example 512 bytes) and contain blocks of information that have either been read from a block device or are being written to it.</p><p><span class="bold"><strong>Page Cache </strong></span> It is used to cache the logical contents of a file a page at a time and is accessed via the file and offset within the file. As pages are read into memory from disk, they are cached in the page cache.</p><p><span class="bold"><strong>Swap Cache</strong></span> So long as pages are not modified after they have been written to the swap file then the next time the page is swapped out there is no need to write it to the swap.</p><p><span class="bold"><strong>Hardware Caches </strong></span> Example: cache of Page Table Entries. In this case, the processor does not always read the page table directly but instead caches translations for pages as it needs them.</p></li><li><p>Memory Mapping</p><p>When an image is executed, the contents of the executable image must be brought into the processes virtual address space.</p><p><span class="bold"><strong>Implementation: </strong></span> The executable file is not actually brought into physical memory, instead it is merely linked into the processes virtual memory. Then, as the parts of the program are referenced by the running application, the image is brought into memory from the executable image.</p><div class="figure"><a name="d0e1024"></a><p class="title"><b>Figure&nbsp;2.3.&nbsp;Memory Mapping</b></p><div class="mediaobject"><img src="resources/vm_area.gif" alt="Memory Mapping"></div></div><p><span class="bold"><strong>Swapping Out and Discarding Pages</strong></span></p><p><span class="emphasis"><em><span class="emphasis"><em>When physical memory becomes scarce the Linux memory management subsystem must attempt to free physical pages. This task falls to the kernel swap daemon (kswapd). The kernel swap daemon is a special type of process, a kernel thread. Kernel threads are processes have no virtual memory, instead they run in kernel mode in the physical address space.</em></span> </em></span></p><div class="itemizedlist"><ul type="circle"><li><p>It swap pages out to the system's swap files.</p></li><li><p>It makes sure that there are enough free pages in the system to keep the memory management system operating efficiently.</p></li></ul></div></li></ul></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="unix_goals.html"><img src="images/prev.gif" alt="Prev"></a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="unix.html"><img src="images/up.gif" alt="Up"></a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="unix_processes.html"><img src="images/next.gif" alt="Next"></a></td></tr><tr><td width="40%" align="left" valign="top">1.&nbsp;Goals&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/home.gif" alt="Home"></a></td><td width="40%" align="right" valign="top">&nbsp;3.&nbsp;Processes</td></tr></table></div></body></html>