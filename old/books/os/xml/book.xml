<?xml version="1.0" encoding="UTF-8"?>
<!-- DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" -->
<book id="os">
  <bookinfo>
    <title>Operating Systems</title>

    <subtitle>A Course about Operating Systems</subtitle>

    <author>
      <firstname>Dilvan</firstname>

      <othername>de Abreu</othername>

      <surname>Moreira</surname>

      <email>dilvan@computer.org</email>
    </author>

    <editor>
      <firstname>Dilvan</firstname>

      <surname>Moreira</surname>
    </editor>

    <copyright>
      <year>1997</year>

      <year>1998</year>

      <year>1999</year>

      <year>2000</year>

      <year>2001</year>

      <year>2002</year>

      <year>2003</year>

      <year>2004</year>

      <holder>Dilvan Moreira</holder>
    </copyright>

    <edition>First</edition>

    <publisher>
      <publishername>Dilvan Moreira</publishername>

      <address><city>SÃ£o Carlos </city><country>Brazil</country></address>
    </publisher>

    <revhistory>
      <revision>
        <revnumber>$Revision: 1.4 $</revnumber>

        <date>$Date: 2004/07/28 20:36:23 $</date>
      </revision>
    </revhistory>

    <pubdate>March 1997</pubdate>
  </bookinfo>

  <chapter id="introduction">
    <title>Introduction</title>

    <section id="introduction_operating_systems">
      <title>Operating Systems</title>

      <itemizedlist mark="bullet" spacing="normal">
        <listitem>
          <para>Operating Systems <itemizedlist mark="bullet" spacing="normal">
              <listitem>
                <para>Hardware: <itemizedlist spacing="compact">
                    <listitem>
                      <simpara>1 or more processors</simpara>
                    </listitem>

                    <listitem>
                      <simpara>Main Memory</simpara>
                    </listitem>

                    <listitem>
                      <simpara>Clocks</simpara>
                    </listitem>

                    <listitem>
                      <simpara>Discs</simpara>
                    </listitem>

                    <listitem>
                      <simpara>Bus</simpara>
                    </listitem>
                  </itemizedlist></para>
              </listitem>

              <listitem>
                <para>Software: <itemizedlist spacing="compact">
                    <listitem>
                      <simpara>Application programs</simpara>
                    </listitem>

                    <listitem>
                      <para>System programs <itemizedlist spacing="compact">
                          <listitem>
                            <simpara>Compilers</simpara>
                          </listitem>

                          <listitem>
                            <simpara>Editors</simpara>
                          </listitem>

                          <listitem>
                            <simpara>Linkers</simpara>
                          </listitem>

                          <listitem>
                            <simpara>Command Interpreter(shell)</simpara>
                          </listitem>
                        </itemizedlist></para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
            </itemizedlist></para>
        </listitem>

        <listitem>
          <para>OS Responsibilities <itemizedlist>
              <listitem>
                <para>Control all computer's resources</para>
              </listitem>

              <listitem>
                <para>Build a necessary base for application programs</para>
              </listitem>

              <listitem>
                <para>Create a Virtual Machine easier to understand and
                use.</para>

                <figure>
                  <title>Computing Layers</title>

                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/fig1_1.gif" />
                    </imageobject>
                  </mediaobject>
                </figure>
              </listitem>
            </itemizedlist></para>
        </listitem>

        <listitem>
          <para>OS Basic Concepts</para>

          <para><emphasis role="bold">System Calls</emphasis> are OS provide
          instruction extensions. They given to user OS kernel access.</para>

          <para>There are 2 system calls classes in UNIX:</para>

          <orderedlist>
            <listitem>
              <para>Process system calls</para>
            </listitem>

            <listitem>
              <para>File System system calls</para>
            </listitem>
          </orderedlist>

          <para><emphasis role="bold">Process:</emphasis></para>

          <para>A process is a running program.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="introduction_processes">
      <title>Process</title>

      <itemizedlist mark="bullet" spacing="normal">
        <listitem>
          <para>Process</para>

          <para>Main concept in a operating system: is a running program
          abstraction.</para>

          <figure>
            <title>Processes</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/fig1_2.gif" />
              </imageobject>
            </mediaobject>
          </figure>

          <para><emphasis role="bold">Pseudo parallelism:</emphasis> The CPU
          is switched between processes, given the illusion of
          parallelism.</para>
        </listitem>

        <listitem>
          <para>Process Model</para>

          <itemizedlist>
            <listitem>
              <para>All programs, including the operating system, are
              organized in a sequential process set.</para>
            </listitem>

            <listitem>
              <para>In a concept model, each process has its own CPU.</para>
            </listitem>

            <listitem>
              <para>Multiprogramming is used to switch the CPU between
              processes.</para>

              <figure>
                <title>Process Model</title>

                <mediaobject>
                  <imageobject>
                    <imagedata fileref="img/fig1_3.gif" />
                  </imageobject>
                </mediaobject>
              </figure>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">Attention:</emphasis></para>

          <itemizedlist>
            <listitem>
              <para>Depending on how the CPU is switched, process execution
              time vary.</para>
            </listitem>

            <listitem>
              <para>Execution at different moments may results in different
              execution time.</para>
            </listitem>

            <listitem>
              <para>In UNIX, time considerations for use in real-time
              applications are not reliable.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Analogy</para>

          <itemizedlist>
            <listitem>
              <para>Computer scientist making a cake. <itemizedlist
                  spacing="compact">
                  <listitem>
                    <simpara>RECIPE: program</simpara>
                  </listitem>

                  <listitem>
                    <simpara>COMPUTER SCIENTIST: CPU</simpara>
                  </listitem>

                  <listitem>
                    <simpara>INGREDIENTS: input data</simpara>
                  </listitem>

                  <listitem>
                    <para>PROCESS: activities: <itemizedlist spacing="compact">
                        <listitem>
                          <simpara>read the recipe</simpara>
                        </listitem>

                        <listitem>
                          <simpara>find the ingredients</simpara>
                        </listitem>

                        <listitem>
                          <simpara>bake the cake.</simpara>
                        </listitem>
                      </itemizedlist></para>
                  </listitem>
                </itemizedlist></para>
            </listitem>

            <listitem>
              <para>Interruptions are possible: son is attacked by bee and run
              into kitchen. <itemizedlist>
                  <listitem>
                    <simpara>Computer scientist records his stage in the
                    recipe.</simpara>
                  </listitem>

                  <listitem>
                    <simpara>Take a first emergency book (another
                    program)</simpara>
                  </listitem>

                  <listitem>
                    <simpara>Follow the instructions (another
                    program)</simpara>
                  </listitem>
                </itemizedlist></para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Process States</para>

          <figure>
            <title>Process States</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/fig1_5.gif" />
              </imageobject>
            </mediaobject>
          </figure>

          <itemizedlist>
            <listitem override="none">
              <simpara>1. Process block for input</simpara>
            </listitem>

            <listitem override="none">
              <simpara>2. Scheduler searches for another process</simpara>
            </listitem>

            <listitem override="none">
              <simpara>3. Schedule picks a process</simpara>
            </listitem>

            <listitem override="none">
              <simpara>4. Input becomes available</simpara>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Implementation</para>

          <figure>
            <title>Process Implementation</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/fig1_6.gif" />
              </imageobject>
            </mediaobject>
          </figure>

          <orderedlist>
            <listitem>
              <para>Device (disc) starts an interruption</para>
            </listitem>

            <listitem>
              <para>Hardware puts on stack:</para>

              <orderedlist>
                <listitem>
                  <para>Program Counter</para>
                </listitem>

                <listitem>
                  <para>Program status word</para>
                </listitem>

                <listitem>
                  <para>registers</para>
                </listitem>
              </orderedlist>
            </listitem>

            <listitem>
              <para>CPU jumps to the specified address to serve the
              interruption</para>
            </listitem>

            <listitem>
              <para>Attendant service save all register (assembly)</para>
            </listitem>

            <listitem>
              <para>Attendant service runs the service</para>
            </listitem>

            <listitem>
              <para>Attendant service finds which process requested the
              service</para>
            </listitem>

            <listitem>
              <para>The process state is changed from blocked to ready</para>
            </listitem>

            <listitem>
              <para>The scheduler is called to select next process</para>
            </listitem>

            <listitem>
              <para>The control returns to the attendant service</para>
            </listitem>

            <listitem>
              <para>The registers are reload</para>
            </listitem>

            <listitem>
              <para>The process restarts</para>
            </listitem>
          </orderedlist>
        </listitem>

        <listitem>
          <para>A Process Consists of:</para>

          <itemizedlist spacing="compact">
            <listitem>
              <simpara>An executable program</simpara>
            </listitem>

            <listitem>
              <simpara>Data and program stacks</simpara>
            </listitem>

            <listitem>
              <simpara>A program counter</simpara>
            </listitem>

            <listitem>
              <simpara>A stack pointer</simpara>
            </listitem>

            <listitem>
              <simpara>Registers</simpara>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">Preemptive Multitasking: </emphasis>the
          OS periodically decides to stop the execution of a process and
          starts the execution of the another process. Eventually, the stopped
          process must come back to the execution point where it was when it
          was interrupted.</para>

          <para>All process information must be explicitly stored. Process
          tables implement this.</para>

          <para><emphasis role="bold">Process tables implement
          this.</emphasis></para>
        </listitem>

        <listitem>
          <para>A Suspend Process Consists of: <itemizedlist spacing="compact">
              <listitem>
                <simpara>Its address space (core image)</simpara>
              </listitem>

              <listitem>
                <simpara>Its process table (registers)</simpara>
              </listitem>
            </itemizedlist></para>

          <para>Example:<itemizedlist spacing="compact">
              <listitem>
                <simpara>a shell process reads commands (from
                terminal)</simpara>
              </listitem>

              <listitem>
                <simpara>a user inputs a command (Ex: program
                compilation)</simpara>
              </listitem>

              <listitem>
                <simpara>the shell starts a process (child) to run the
                compiler</simpara>
              </listitem>

              <listitem>
                <simpara>this process runs the compilation and activates a
                System Call to kill itself</simpara>
              </listitem>

              <listitem>
                <simpara>control goes back to the shell process.</simpara>

                <programlisting>while (TRUE) { 

    read_command (command, parameters); 

    if (fork() != 0){ 

      wait (&amp;status); 

    } else 

   execve (command, parameters, 0); 

  } </programlisting>
              </listitem>
            </itemizedlist></para>
        </listitem>

        <listitem>
          <para>Process can create processes</para>

          <figure>
            <title>Process Tree</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/fig1_7.gif" />
              </imageobject>
            </mediaobject>
          </figure>

          <para>Other process System Calls:</para>

          <itemizedlist>
            <listitem>
              <para>Memory request</para>
            </listitem>

            <listitem>
              <para>Wait a child process termination</para>
            </listitem>

            <listitem>
              <para>Memory reallocation</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Signals</para>

          <para>Signals are OS mechanisms to notify events to processes. A
          signal can suspend, in a temporary way, process execution, save his
          registers on stacks and start a special program to treat it.</para>

          <para>Ex: time out, memory violation, etc.</para>
        </listitem>

        <listitem>
          <para>UID</para>

          <itemizedlist>
            <listitem>
              <para>Each authorized person to use the system has a UID (user
              identification).</para>
            </listitem>

            <listitem>
              <para>Each started process has the UID from the user that
              started it.</para>
            </listitem>

            <listitem>
              <para>The super-user has a special UID. This UID can violate the
              protection rules.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Files</para>

          <para>The second bigger set of System Calls works with the FILE
          SYSTEM.</para>

          <para>Main function of the OS: hide particularities from discs and
          other I/O devices. The programmer must have an abstract model of the
          file system. This model must be independent of file system devices
          implementation.</para>

          <para>Directory tree is a UNIX key concept, used to group
          files:</para>

          <figure>
            <title>File System Tree</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/fig1_8.gif" />
              </imageobject>
            </mediaobject>
          </figure>

          <para>The processes and files hierarchy are both organized in trees.
          However, they have many differences:</para>

          <itemizedlist>
            <listitem>
              <para>Process hierarchies are not very depth, but file
              hierarchies are.</para>
            </listitem>

            <listitem>
              <para>Process hierarchies have a short life. File hierarchies
              can last for years.</para>
            </listitem>

            <listitem>
              <para>Normally, child processes can be accessed or modified only
              by their parent process, while files can be accessed by
              anyone.</para>
            </listitem>

            <listitem>
              <para>Each file, in a directory hierarchy, can be specified
              using its pathname.</para>
            </listitem>

            <listitem>
              <para>A "/" on the beginning of a file pathname indicates that
              the path is absolute.</para>
            </listitem>

            <listitem>
              <para>On each moment, each process has a working directory, used
              to find processes' files without absolute pathnames.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>

    <section id="introduction_memory_management">
      <title>Memory Management</title>

      <itemizedlist>
        <listitem>
          <para>Memory</para>

          <para>Important resource. Must be managed carefully.</para>

          <itemizedlist>
            <listitem>
              <para>Which parts of memory are being used and which ones are
              free</para>
            </listitem>

            <listitem>
              <para>Allocate and deallocate memory for processes</para>
            </listitem>

            <listitem>
              <para>When main memory is not enough, allocate space on
              disc</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Memory Management</para>

          <para>Happens on two ways:</para>

          <orderedlist>
            <listitem>
              <para>With SWAPPING &amp; PAGING: Processes are transferred
              continuously between main memory and disc.</para>
            </listitem>

            <listitem>
              <para>Without SWAPPING &amp; PAGING</para>
            </listitem>
          </orderedlist>

          <itemizedlist>
            <listitem>
              <para>Monoprogramming</para>

              <para><emphasis role="bold">Simple Systems
              (IBM-PC)</emphasis></para>

              <para>Memory is split between the operating system and the only
              user process.</para>

              <figure>
                <title>Memory Management</title>

                <mediaobject>
                  <imageobject>
                    <imagedata fileref="img/fig1_9.gif" />
                  </imageobject>
                </mediaobject>
              </figure>

              <para>One program at a time:</para>

              <itemizedlist>
                <listitem>
                  <para>User types a command</para>
                </listitem>

                <listitem>
                  <para>OS takes the program from disc</para>
                </listitem>

                <listitem>
                  <para>OS puts a prompt when the program process
                  terminates</para>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para>Multiprogramming with fix partitions (batch)</para>

              <para>MFT-Multiprogramming with a Fixed number of Tasks (used
              for IBM OS/360)</para>

              <itemizedlist>
                <listitem>
                  <para>Multiple Queues: a big partition may have an empty
                  queue, while small partitions have full queues.</para>
                </listitem>

                <listitem>
                  <para>Single queue: as soon as one partition is free, the
                  job closer to queue head runs ( if it fits in the
                  partition). A big partition may be allocated to a small
                  job.</para>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para>Multiprogramming</para>

              <itemizedlist>
                <listitem>
                  <para>More than one process in memory</para>
                </listitem>

                <listitem>
                  <para>On interactive systems: many user are allocated at
                  same time</para>
                </listitem>

                <listitem>
                  <para>Time expended waiting I/O is not wasted</para>
                </listitem>
              </itemizedlist>

              <para><emphasis role="bold">GOAL:</emphasis> improve CPU
              utilization</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>
  </chapter>

  <chapter id="unix">
    <title>Unix</title>

    <section id="unix_goals">
      <title>Goals</title>

      <itemizedlist>
        <listitem>
          <para>Goals</para>

          <para>Unix is an operating system made by programmers to
          programmers.</para>

          <itemizedlist>
            <listitem>
              <para>Easy to use</para>
            </listitem>

            <listitem>
              <para>Powerful</para>
            </listitem>

            <listitem>
              <para>Extensible</para>
            </listitem>

            <listitem>
              <para>Easy to understand</para>
            </listitem>

            <listitem>
              <para>Open</para>
            </listitem>

            <listitem>
              <para>Elegant</para>
            </listitem>

            <listitem>
              <para>Multitasking and multiuser</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Logging</para>

          <para><emphasis role="bold">Logging in.</emphasis> At login time,
          you'll see a prompt resembling the following:</para>

          <programlisting>java login: larry
Password:</programlisting>

          <para><emphasis role="bold">Logging out.</emphasis></para>

          <para><programlisting>/home/larry# exit</programlisting></para>

          <para><emphasis><emphasis role="bold">The directory
          tree</emphasis>.</emphasis></para>

          <para>In particular, each user has a home directory, which is the
          directory set aside for that user to store his files.</para>

          <figure>
            <title>Directory Tree</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/img123.gif" />
              </imageobject>
            </mediaobject>
          </figure>

          <para><emphasis role="bold">The current working
          directory.</emphasis></para>

          <para>At any moment, commands that you enter are assumed to be
          relative to your current working directory. You can think of your
          working directory as the directory in which you are currently
          ``located''.</para>

          <para><emphasis role="bold">Referring to home
          directories.</emphasis></para>

          <programlisting>/home/larry# more ~/papers/history-final
/home/larry# more /home/larry/papers/history-final
</programlisting>
        </listitem>

        <listitem>
          <para>First Steps</para>

          <para>Moving around.</para>

          <programlisting>cd directory</programlisting>

          <para>Looking at the contents of directories.</para>

          <programlisting>/home/larry# ls /etc
Images    ftpusers    lpc     rc.new   shells
adm       getty       magic   rc0.d    startcons
bcheckrc  gettydefs   motd    rc1.d    swapoff
brc       group       mount   rc2.d    swapon
brc~      inet        mtab    rc3.d    syslog.conf
/home/larry#</programlisting>

          <para><emphasis role="bold">For MS-DOS users:</emphasis> Filenames
          can be longer than 8 characters, and can contain periods in any
          position. You can even use more than one period in a filename.
          <emphasis role="bold">Creating new directories</emphasis>.</para>

          <programlisting>/home/larry# mkdir foo
/home/larry# ls -F
Mail/
foo/
letters/
papers/
/home/larry# cd foo
/home/larry# ls
/home/larry#</programlisting>

          <para><emphasis role="bold">Copying files</emphasis>.</para>

          <programlisting>/home/larry/foo# cp /etc/termcap .
/home/larry/foo# cp /etc/shells .
/home/larry/foo# ls --F
shells    termcap
/home/larry/foo# cp shells bells
/home/larry/foo# ls --F
bells     shells     termcap
/home/larry/foo# </programlisting>

          <para><emphasis role="bold">Moving files</emphasis>.</para>

          <programlisting>/home/larry/foo# mv termcap sells
/home/larry/foo# ls --F
bells    sells    shells
/home/larry/foo#</programlisting>

          <para><emphasis role="bold">Deleting files and
          directories.</emphasis></para>

          <programlisting>/home/larry/foo# rm bells sells
/home/larry/foo# ls --F
shells
/home/larry/foo#</programlisting>

          <para><emphasis role="bold">Looking at files</emphasis>.</para>

          <programlisting>/home/larry/foo# more shells</programlisting>

          <para><emphasis role="bold">Getting online help</emphasis>.</para>

          <programlisting>/home/larry/foo# man ls
&lt;the manual page for ls displayed&gt;</programlisting>
        </listitem>

        <listitem>
          <para>Types of Shells</para>

          <itemizedlist>
            <listitem>
              <para>Bourne shell - /bin/sh - syntax like the original shell on
              early UNIX systems</para>
            </listitem>

            <listitem>
              <para>C shell - /bin/csh - syntax similar to the C
              language</para>
            </listitem>
          </itemizedlist>

          <para>Wildcards.</para>

          <para>* specifies any character or string of characters in a file
          name.</para>

          <programlisting>/home/larry# ls *o*
frog    joe
/home/larry#

/home/larry# ls *
frog   joe   stuff
/home/larry#</programlisting>

          <para>? expands to only a single character.</para>

          <programlisting>/home/larry# ls j?e
joe
/home/larry# ls f??g
frog
/home/larry# ls ????f
stuff
/home/larry#</programlisting>

          <para><emphasis role="bold">This is important</emphasis>: a command
          never sees the "*" or "?" in its list of parameters.</para>

          <para>The shell expands the wildcard to include all filenames that
          match: /home/larry# ls *o* is expanded to /home/larry# ls frog
          joe</para>

          <para><emphasis role="bold">Hidden files</emphasis><programlisting>/home/larry# ls -a
.     ..     .bash_profle     .bashrc     frog     joe     stuff
/home/larry#</programlisting></para>

          <para><emphasis role="bold">Redirecting input and
          output</emphasis>.</para>

          <programlisting>/home/larry/pappers# sort items &gt; shopping-list
/home/larry# cat shopping-list
apples     
bananas
carrots
/home/larry/pappers#
/home/larry/pappers# sort &lt; items
apples
bananas
carrots
/home/larry/pappers#</programlisting>

          <para><emphasis role="bold">Using pipes</emphasis><programlisting>/home/larry/pappers# ls | sort -r
notes
masters-thesis
history-final
english-list
/home/larry/pappers#
/home/larry/pappers# ls /usr/bin | more</programlisting></para>
        </listitem>

        <listitem>
          <para>File Permissions</para>

          <para><emphasis role="bold">Concepts of file
          permissions</emphasis></para>

          <para>Permissions fall into three main divisions: read, write, and
          execute. These permissions may be granted to three classes of users:
          the owner of the file, the group to which the file belongs, and to
          all users, regardless of group.</para>

          <programlisting>/home/larry/foo# ls -l stuff
-rw-r--r--   1 larry     users     505 Mar 13 19:05  stuff
/home/larry/foo#

-rwxr-xr-x   The owner of the file may read, write and execute the file. Users int the 
             file's group and all other users may read and execute the file.

-rw-------   The owner of the file may read and write the file. No other user can access the file.
</programlisting>

          <para><emphasis role="bold">Changing permissions</emphasis>.</para>

          <para>chmod is used to set the permissions on a file. Only the owner
          of a file may change the permissions on that file. The syntax of
          chmod is</para>

          <programlisting>chmod {a,u,g,o}{+,-}{r,w,x} filenames</programlisting>

          <para>Briefly, you supply one or more of all, user, group, or other.
          Then you specify whether you are adding rights (+) or taking them
          away (-). Finally, you specify one or more of read, write, and
          execute:</para>

          <programlisting>chmod a+r stuff
      Gives all users read access to the file.

chmod +r stuff
      Same as above - if none of a, u, g or o is specified, a is assumed.

chmod og-x stuff
      Remove execute permission from users other than the owner.

chmod u+rwx stuff
      Let the owner of th file read, write and execute the file.

chmod o-rwx stuff
      Remove read, write and execute permissions from users other than the owner and users in the file's group.</programlisting>
        </listitem>

        <listitem>
          <para>Managing file links</para>

          <para><emphasis role="bold">Hard links</emphasis>.</para>

          <programlisting>/home/larry$ ls -i foo
22192 foo
/home/larry#</programlisting>

          <para>Here, foo has an inode number of 22192 in the file system. You
          can create another link to foo, named bar, as follows:</para>

          <programlisting>/home/larry# ln foo bar
/home/larry# ls -i foo bar
22192 bar   22192 foo</programlisting>

          <para>Symbolic links.</para>

          <programlisting>/home/larry# ln -s foo bar</programlisting>

          <para>You will create a symbolic link named bar that points to the
          file foo. If you use ls -i, you'll see that the two files have
          different inodes, indeed.</para>

          <programlisting>/home/larry# ls -i foo bar
22195 bar   22192 foo
/home/larry#</programlisting>
        </listitem>

        <listitem>
          <para>Job control</para>

          <para><emphasis role="bold">Jobs and processes</emphasis>.</para>

          <para><emphasis role="bold">Job control</emphasis> lets you control
          multiple running commands, or <emphasis role="bold">jobs</emphasis>,
          at once. To see the <emphasis
          role="bold">processes</emphasis>:</para>

          <programlisting>/home/larry# ps
PID   TT   STAT   TIME   COMMAND
 24    3   S       0:03   (bash)
161    3   R       0:00   ps</programlisting>

          <itemizedlist>
            <listitem>
              <para>PID listed in the first column is the process ID, a unique
              number given to every running process</para>
            </listitem>

            <listitem>
              <para>COMMAND, is the name of the running command</para>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">Backgrounding and killing
          jobs</emphasis></para>

          <para>One way to put a process in the background is to append an
          ``&amp;'' character to the end of the command.</para>

          <programlisting>/home/larry# yes &gt; /dev/null &amp;
[1] 164
/home/larry#

The "[1]" represents the job number for the yes process.
The "164" is the process ID, or PID.
/home/larry# jobs
[1]+  Running                  yes &gt;/dev/null  &amp;
/home/larry#
</programlisting>

          <para>To terminate the job, use the kill command</para>

          <programlisting>/home/larry# kill %1</programlisting>

          <para>When identifying the job with the job number, you must prefix
          the number with a percent (``%'') character. Checking on it:</para>

          <programlisting>/home/larry# jobs
[1]+ Terminated       yes &gt;/dev/null
/home/larry#

/home/larry# kill 164
is equivalent to
/home/larry# kill %1</programlisting>
        </listitem>

        <listitem>
          <para>Customizing your environment</para>

          <para><emphasis role="bold">Creating new command with
          scripts.</emphasis></para>

          <para>For example, the three commands:</para>

          <programlisting>/home/larry# cat chapter1 chapter2 chapter3 &gt; book
/home/larry# wc -l book
/home/larry# lp book</programlisting>

          <para>They concatenates the files chapter1, chapter2, and chapter3
          and places the result in the file book. The second command displays
          a count of the number of lines in book, and the third command lp
          book prints book. Create a shell script to perform the same action
          (name it makebook):</para>

          <programlisting>#!/bin/sh
# A shell script to create and print the book
cat chapter1 chapter2 chapter3 &gt; book
wc -l book
lp book</programlisting>

          <para>Make it runnable:</para>

          <programlisting>/home/larry# chmod u+x makebook</programlisting>

          <para>Use it !</para>

          <programlisting>/home/larry# makebook
&lt; run all the commands in the script&gt;</programlisting>

          <para><emphasis role="bold">Shell variables and the
          environment</emphasis>.</para>

          <para>A shell lets you define <emphasis
          role="bold">variables</emphasis>, as do most programming languages.
          A variable is just a piece of data that is given a name. T<emphasis
          role="bold">he PATH environment variable</emphasis>. The shell uses
          the environment variable PATH to locate executable files for
          commands you type. For example, your PATH variable may be set
          to</para>

          <programlisting>/bin:/usr/bin:/usr/local/bin:</programlisting>

          <para>This is a list of directories for the shell to search, each
          directory separated by a ``:''. When you use the command ls, the
          shell first looks for /bin/ls, then /usr/bin/ls, and so on.</para>

          <para><emphasis role="bold">Shell initialization scripts.</emphasis>
          There are a number of scripts that the system uses for certain
          purposes. The most important of these are initialization scripts,
          which are scripts executed by the shell when you log in.</para>

          <para>Bash:</para>

          <itemizedlist>
            <listitem>
              <para>/etc/profile :set up by the system administrator and
              executed by all bash users at login time</para>
            </listitem>

            <listitem>
              <para>$HOME/.bash_profile : executed by a login bash
              session</para>
            </listitem>

            <listitem>
              <para>$HOME/.bashrc : executed by all non-login instances of
              bash</para>
            </listitem>
          </itemizedlist>

          <para>Csh:</para>

          <itemizedlist>
            <listitem>
              <para>/etc/csh.login : executed by all tcsh users at login
              time</para>
            </listitem>

            <listitem>
              <para>$HOME/.cshrc : executed at login time and by all new
              instances of csh</para>
            </listitem>

            <listitem>
              <para>$HOME/.login : executed at login time, following
              .cshrc</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para></para>
    </section>

    <section id="unix_memory_management">
      <title>Memory Management</title>

      <itemizedlist>
        <listitem>
          <para>Memory Management</para>

          <para>The memory management subsystem is one of the most important
          parts of the operating system. It allows:</para>

          <para><emphasis role="bold">Large Address Spaces</emphasis> The
          virtual memory can be many times larger than the physical memory in
          the system, <emphasis role="bold">Protection </emphasis> Each
          process in the system has its own virtual address space completely
          separate from each other and so a process running one application
          cannot affect another. <emphasis role="bold">Memory
          Mapping</emphasis> Memory mapping is used to map image and data
          files into a processes address space. <emphasis role="bold">Fair
          Physical Memory Allocation</emphasis> The memory management
          subsystem allows each running process in the system a fair share of
          the physical memory of the system, <emphasis role="bold">Shared
          Virtual Memory </emphasis> There are times when processes share
          memory: when there are several processes in the system running the
          same program code.</para>
        </listitem>

        <listitem>
          <para>An Abstract Model of Virtual Memory</para>

          <figure>
            <title>Virtual Memory</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/vm.gif" />
              </imageobject>
            </mediaobject>
          </figure>

          <para>A virtual address is composed of two parts:</para>

          <itemizedlist>
            <listitem>
              <para>an offset</para>
            </listitem>

            <listitem>
              <para>a virtual page frame number.</para>

              <para><emphasis>Pages:</emphasis> virtual and physical memory
              are divided into handy sized chunks called pages. Each of these
              pages is given a unique number; the page frame number
              (PFN).</para>

              <para>If the page size is 4 Kbytes, bits 11:0 of the virtual
              address contain the offset and bits 12 and above are the virtual
              page frame number:</para>

              <para>&lt;--------- Page Frame Number --------&gt;|&lt;------
              Offset ------&gt;</para>

              <para>|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|</para>

              <para>32 BITS Address Word</para>

              <para>Each entry in the page table contains the following
              information:</para>

              <itemizedlist>
                <listitem>
                  <para>Valid flag: this indicates if this page table entry is
                  valid,</para>
                </listitem>

                <listitem>
                  <para>The physical page frame number: that this entry is
                  describing,</para>
                </listitem>

                <listitem>
                  <para>Access control information: this describes how the
                  page may be used. Can it be written to? Does it contain
                  executable code?</para>
                </listitem>
              </itemizedlist>

              <para><emphasis role="bold">Page Fault:</emphasis></para>

              <para>The way the processor notifies the operating system that
              the correct process has attempted to access a virtual address
              for which there is no valid translation is specific to the
              processor.</para>

              <para><emphasis role="bold">Dealing with Page
              Faults</emphasis></para>

              <itemizedlist>
                <listitem>
                  <para><emphasis role="bold">Invalid virtual
                  address</emphasis>: It means that the process has attempted
                  to access a virtual address that it should not have.</para>

                  <orderedlist>
                    <listitem>
                      <para>The application has gone wrong in some way.</para>
                    </listitem>

                    <listitem>
                      <para>In this case the operating system will terminate
                      it.</para>
                    </listitem>
                  </orderedlist>
                </listitem>

                <listitem>
                  <para><emphasis role="bold">Valid virtual
                  address</emphasis>: It means that the page that it refers to
                  is not currently in memory.</para>

                  <orderedlist>
                    <listitem>
                      <para>The operating system must bring the appropriate
                      page into memory from the image on disk.</para>
                    </listitem>
                  </orderedlist>
                </listitem>
              </itemizedlist>

              <para><emphasis role="bold">Swapping</emphasis></para>

              <para><emphasis><emphasis> Happens when the operating system
              needs to create new pages in the physical memory and there is no
              space. It will discard old pages in to create space:
              </emphasis></emphasis></para>

              <para><emphasis><emphasis><emphasis role="bold"> Clean
              Pages</emphasis> If the page to be discarded came from an image
              or data file and has not been written to then the page does not
              need to be saved. It is just
              discarded.</emphasis></emphasis></para>

              <para><emphasis><emphasis> <emphasis role="bold">Dirty Pages
              </emphasis> If the page has been modified, its contents must
              preserve and it is saved in a special sort of file called the
              swap file.</emphasis></emphasis></para>

              <para><emphasis><emphasis> <emphasis role="bold"> Thrashing
              </emphasis>: If the algorithm used to decide which pages to
              discard or swap is not efficient then a condition known as
              thrashing occurs. In this case, pages are constantly being
              written to disk and then being read back and the operating
              system is too busy to allow much real work to be
              performed.</emphasis></emphasis></para>

              <para><emphasis><emphasis><emphasis role="bold"> Least Recently
              Used (LRU)</emphasis> This scheme involves every page in the
              system having an age which changes as the page is accessed. The
              more that a page is accessed, the younger it is; the less that
              it is accessed the older and more stale it becomes. Old pages
              are good candidates for swapping.</emphasis></emphasis></para>

              <para><emphasis role="bold">Physical Addressing
              Mode</emphasis></para>

              <para>It does not make much sense for the operating system
              itself to run in virtual memory.</para>

              <para><emphasis role="bold">Physical addressing mode</emphasis>
              requires no page tables and the processor does not attempt to
              perform any address translations in this mode. The kernel is
              linked to run in physical address space.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Caches</para>

          <para><emphasis role="bold">Buffer Cache</emphasis> These buffers
          are of fixed sizes (for example 512 bytes) and contain blocks of
          information that have either been read from a block device or are
          being written to it.</para>

          <para><emphasis role="bold">Page Cache </emphasis> It is used to
          cache the logical contents of a file a page at a time and is
          accessed via the file and offset within the file. As pages are read
          into memory from disk, they are cached in the page cache.</para>

          <para><emphasis role="bold">Swap Cache</emphasis> So long as pages
          are not modified after they have been written to the swap file then
          the next time the page is swapped out there is no need to write it
          to the swap.</para>

          <para><emphasis role="bold">Hardware Caches </emphasis> Example:
          cache of Page Table Entries. In this case, the processor does not
          always read the page table directly but instead caches translations
          for pages as it needs them.</para>
        </listitem>

        <listitem>
          <para>Memory Mapping</para>

          <para>When an image is executed, the contents of the executable
          image must be brought into the processes virtual address
          space.</para>

          <para><emphasis role="bold">Implementation: </emphasis> The
          executable file is not actually brought into physical memory,
          instead it is merely linked into the processes virtual memory. Then,
          as the parts of the program are referenced by the running
          application, the image is brought into memory from the executable
          image.</para>

          <figure>
            <title>Memory Mapping</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/vm_area.gif" />
              </imageobject>
            </mediaobject>
          </figure>

          <para><emphasis role="bold">Swapping Out and Discarding
          Pages</emphasis></para>

          <para><emphasis><emphasis>When physical memory becomes scarce the
          Linux memory management subsystem must attempt to free physical
          pages. This task falls to the kernel swap daemon (kswapd). The
          kernel swap daemon is a special type of process, a kernel thread.
          Kernel threads are processes have no virtual memory, instead they
          run in kernel mode in the physical address space.</emphasis>
          </emphasis></para>

          <itemizedlist>
            <listitem>
              <para>It swap pages out to the system's swap files.</para>
            </listitem>

            <listitem>
              <para>It makes sure that there are enough free pages in the
              system to keep the memory management system operating
              efficiently.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>

    <section id="unix_processes">
      <title>Processes</title>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Processes</emphasis></para>

          <para><emphasis role="bold">Definition</emphasis>:</para>

          <para>Processes carry out tasks within the operating system. A
          program is a set of machine code instructions and data stored in an
          executable image on disk and is a passive entity; a process can be
          thought of as a computer program in action.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Identifiers</emphasis></para>

          <para><emphasis><emphasis>Every process in the system has a process
          identifier. It is simply a number. Each process also has User and
          group identifiers, these are used to control this processes access
          to the files and devices in the system.</emphasis></emphasis></para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">State</emphasis></para>

          <para><emphasis><emphasis><emphasis role="bold">Running</emphasis>
          The process is either running (it is the current process in the
          system) or it is ready to run (it is waiting to be assigned to one
          of the system's CPUs). </emphasis></emphasis></para>

          <para><emphasis><emphasis><emphasis role="bold"> Waiting</emphasis>
          The process is waiting for an event or for a resource. Linux
          differentiates between two types of waiting process; interruptible
          and uninterruptible. Interruptible waiting processes can be
          interrupted by signals whereas uninterruptible waiting processes are
          waiting directly on hardware conditions and cannot be interrupted
          under any circumstances. </emphasis></emphasis></para>

          <para><emphasis><emphasis><emphasis role="bold"> Stopped </emphasis>
          The process has been stopped, usually by receiving a signal. A
          process that is being debugged can be in a stopped state.
          </emphasis></emphasis></para>

          <para><emphasis><emphasis><emphasis role="bold"> Zombie </emphasis>
          This is a halted process which, for some reason, still has a data
          structure representing it. It is what it sounds like, a dead
          process.</emphasis></emphasis></para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Scheduling</emphasis></para>

          <para><emphasis><emphasis>Processes are always making system calls
          and so may often need to wait. Even so, if a process executes until
          it waits then it still might use a disproportionate amount of CPU
          time and so Linux uses preemptive scheduling:
          </emphasis></emphasis></para>

          <para><emphasis><emphasis><emphasis role="bold">
          time-slice</emphasis> </emphasis></emphasis></para>

          <para><emphasis><emphasis> In this scheme, each process is allowed
          to run for a small amount of time, 200ms, and, when this time has
          expired another process is selected to run and the original process
          is made to wait for a little while until it can run
          again.</emphasis></emphasis></para>

          <para><emphasis><emphasis>Each time the scheduler is run it does the
          following:</emphasis></emphasis></para>

          <para><emphasis><emphasis><emphasis role="bold">kernel work
          </emphasis> The scheduler runs the bottom half handlers and
          processes the scheduler task queue. </emphasis></emphasis></para>

          <para><emphasis><emphasis><emphasis role="bold">Current
          process</emphasis> The current process must be processed before
          another process can be selected to run.
          </emphasis></emphasis></para>

          <para><emphasis><emphasis><emphasis role="bold">Process
          selection</emphasis> The scheduler looks through the processes on
          the run queue looking for the most deserving process to run. If
          there are any real time processes (those with a real time scheduling
          policy) then those will get a higher weighting than ordinary
          processes. </emphasis></emphasis></para>

          <para><emphasis><emphasis><emphasis role="bold">Round
          Robin</emphasis> If several processes have the same priority, the
          one nearest the front of the run queue is chosen. The current
          process will get put onto the back of the run queue. In a balanced
          system with many processes of the same priority, each one will run
          in turn. </emphasis></emphasis></para>

          <para><emphasis><emphasis><emphasis role="bold">Swap
          processes</emphasis> If the most deserving process to run is not the
          current process, then the current process must be suspended and the
          new one made to run.</emphasis></emphasis></para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Files</emphasis></para>

          <figure>
            <title>Files</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/files.gif" />
              </imageobject>
            </mediaobject>
          </figure>

          <para><emphasis>fs_struct </emphasis> contains pointers to this
          process's VFS inodes and its umask. The umask is the default mode
          that new files will be created in, and it can be changed via system
          calls.</para>

          <para><emphasis>files_struct </emphasis> contains information about
          all of the files that this process is currently using.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Virtual Memory</emphasis></para>

          <para>A process's virtual memory contains executable code and data
          from many sources:</para>

          <itemizedlist>
            <listitem>
              <para><emphasis role="bold">The program image</emphasis> that is
              loaded; for example a command like ls. This command is composed
              of both executable code and data.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Allocated (virtual)
              memory</emphasis> to use during their processing. This newly
              allocated, virtual, memory needs to be linked into the process's
              existing virtual memory so that it can be used.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Libraries of commonly useful
              code</emphasis>. The code and the data from shared libraries
              must be linked into the process's virtual address space and also
              into the virtual address space of the other processes sharing
              it.</para>

              <figure>
                <title>Virtual Memory</title>

                <mediaobject>
                  <imageobject>
                    <imagedata fileref="img/process-vm.gif" />
                  </imageobject>
                </mediaobject>
              </figure>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Creating a Process</emphasis></para>

          <para>When the system starts up it is running in kernel mode and
          there is, in a sense, only one process, the initial process (Idle).
          Like all processes, the initial process has a machine state
          represented by stacks, registers and so on.</para>

          <para><emphasis role="bold">init kernel thread</emphasis> At the end
          of system initialization, the initial process starts up a kernel
          thread (called init) and then sits in an idle loop doing nothing.
          The init kernel thread or process has a process identifier of 1 as
          it is the system's first real process. It does some initial setting
          up of the system (such as opening the system console and mounting
          the root file system) and then executes the system initialization
          program. This is one of /etc/init, /bin/init or /sbin/init depending
          on your system. The init program uses /etc/inittab as a script file
          to create new processes within the system. New processes are created
          by cloning old processes, or rather by cloning the current process.
          A new task is created by a system call (fork or clone) and the
          cloning happens within the kernel in kernel mode. At the end of the
          system call there is a new process waiting to run once the scheduler
          chooses it.</para>

          <para><emphasis role="bold">Exec call</emphasis> After a process has
          been cloned a call to the system call exec will replace its current
          code image for a new one, from a different executable, and the
          process can begin to run a new application.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Links</emphasis></para>

          <para>Every process in the system, except the initial process has a
          parent process. New processes are not created, they are copied, or
          rather cloned from previous processes.</para>

          <programlisting>init(1)-+-crond(98) |-emacs(387) |-gpm(146) |-inetd(110) |-kerneld(18) |-kflushd(2) |-klogd(87) |-kswapd(3) |-login(160)---bash(192)---emacs(225) |-lpd(121) |-mingetty(161) |-mingetty(162) |-mingetty(163) |-mingetty(164) |-login(403)---bash(404)---pstree(594) |-sendmail(134) |-syslogd(78) `-update(166)</programlisting>
        </listitem>
      </itemizedlist>
    </section>

    <section id="unix_signals">
      <title>Signals</title>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Signals</emphasis></para>

          <para><emphasis><emphasis>Signals are one of the oldest
          inter-process communication methods used by Unix TM systems. They
          are used to signal asynchronous events to one or more processes.
          </emphasis></emphasis></para>

          <itemizedlist>
            <listitem>
              <para>A signal could be generated by a keyboard interrupt or an
              error condition.</para>
            </listitem>
          </itemizedlist>

          <itemizedlist>
            <listitem>
              <para>Signals are also used by programs to signal job control
              commands to their child processes.</para>
            </listitem>
          </itemizedlist>

          <para>There are a set of defined signals that the kernel can
          generate or that can be generated by other processes in the system:
          <programlisting> 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGIOT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP 21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ 26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR</programlisting></para>

          <para>Processes can choose to ignore most of the signals that are
          generated, with two notable exceptions:</para>

          <itemizedlist>
            <listitem>
              <para>The SIGSTOP signal which causes a process to halt its
              execution.</para>
            </listitem>

            <listitem>
              <para>The SIGKILL signal which causes a process to exit can be
              ignored.</para>
            </listitem>
          </itemizedlist>

          <para>Processes can choose just how they want to handle the other
          signals:</para>

          <itemizedlist>
            <listitem>
              <para>They can block the signals.</para>
            </listitem>

            <listitem>
              <para>Choose to handle them themselves.</para>
            </listitem>

            <listitem>
              <para>Allow the kernel to handle them.</para>
            </listitem>
          </itemizedlist>

          <para>If the kernel handles the signals, it will do the default
          actions required for this signal: For example, the default action
          when a process receives the SIGFPE (floating point exception) signal
          is to core dump and then exit. The process modifies the default
          signal handling by making system calls and these calls alter the
          sigaction for the appropriate signal as well as the blocked
          mask.</para>

          <para><emphasis role="bold">Security</emphasis> Not every process in
          the system can send signals to every other process, the kernel can
          and super users can. Normal processes can only send signals to
          processes with the same uid and gid or to processes in the same
          process group1.</para>

          <para><emphasis role="bold">Signals are not presented to the process
          immediately they are generated, they must wait until the process is
          running again.</emphasis></para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="unix_pipes">
      <title>Pipes</title>

      <itemizedlist>
        <listitem>
          <para>Pipes</para>

          <para><emphasis role="bold">Definition</emphasis>:</para>

          <para>A one-way data path between two processes:</para>

          <figure>
            <title>Pipe</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/Unix1.gif" />
              </imageobject>
            </mediaobject>
          </figure>

          <para><emphasis role="bold">Creation</emphasis>:</para>

          <programlisting>int fd[2]; int pipe(fd); fork(); ...</programlisting>

          <para>Two file descriptors are created: fd[0] for reading &amp;
          fd[1] for writing. They are copied to the child process:</para>

          <figure>
            <title>Two Pipes</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/Unix2.gif" />
              </imageobject>
            </mediaobject>
          </figure>

          <para>To construct the one-way pipe, the Parent process close its
          read fd and the child its write fd.</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>Piping many processes</para>

          <para>The stdout of a process can be connected to the stdin of
          another through a pipe. For instance, that is what happens when the
          following shell command is executed:</para>

          <programlisting>who | sort | lpr</programlisting>

          <para>The shell program will use the pipe system call to create the
          following construction:</para>

          <figure>
            <title>Piping Processes</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/Unix3.gif" />
              </imageobject>
            </mediaobject>
          </figure>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>Two-way Connections</para>

          <para>To create a two-way connection between process, two pipes have
          to be created. One in each direction:</para>

          <figure>
            <title>Two-way Connection</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/Unix4.gif" />
              </imageobject>
            </mediaobject>
          </figure>

          <para>Creation Sequence:</para>

          <programlisting><emphasis role="bold">Parent Child </emphasis> Create Pipe 1 and Pipe 2 Fork Close read fd of Pipe1 Close write fd of Pipe1 Close write fd of Pipe2 Close read fd of Pipe 2 </programlisting>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>FIFO (named pipes)</para>

          <para>Named Pipes are Pipes that have a name associated with them.
          They are used as data path between processes that are not related to
          each other.</para>

          <para><emphasis role="bold">Creation</emphasis>: They are created
          through the mknod call:</para>

          <programlisting>int mknod ( char *pathname, int mode, int dev);</programlisting>

          <itemizedlist>
            <listitem>
              <para>pathname is the a common Unix pathname.</para>
            </listitem>

            <listitem>
              <para>mode define the access mode</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>After creation, a FIFO can be opened like a file.</para>
    </section>

    <section id="unix_file_system">
      <title>File System</title>

      <itemizedlist>
        <listitem>
          <para>The File system</para>

          <para>In Unix the separate file systems the system may use are not
          accessed by device identifiers but instead they are combined into a
          single hierarchical tree structure that represents the file system
          as one whole single entity.</para>

          <para><emphasis role="bold">Virtual File System</emphasis> VFS
          allows Linux to support many, often very different, file systems,
          each presenting a common software interface to the VFS.</para>

          <para><emphasis role="bold">Block Devices</emphasis></para>

          <itemizedlist>
            <listitem>
              <para>All file system use an Unix block device.</para>
            </listitem>

            <listitem>
              <para>All kinds of disks (IDE, floppy, SCSI, etc) are mapped
              into a block device.</para>
            </listitem>
          </itemizedlist>

          <para>A block device model any disk as a linear array of characters
          with a pointer that can be randomly moved to allow any block of
          characters to be read.</para>
        </listitem>

        <listitem>
          <para>The Second Extended File system (EXT2)</para>

          <para>EXT2 defines the file system topology by describing each file
          in the system with an inode data structure, it is the most used
          system in Linux.</para>

          <para><emphasis role="bold">inodes</emphasis> An inode describes
          which blocks the data within a file occupies as well as the access
          rights of the file, the file's modification times and the type of
          the file.</para>

          <itemizedlist>
            <listitem>
              <para>Every file in the EXT2 file system is described by a
              single inode and each inode has a single unique number
              identifying it.</para>
            </listitem>

            <listitem>
              <para>The inodes for the file system are all kept together in
              inode tables.</para>
            </listitem>
          </itemizedlist>

          <para><emphasis><emphasis><emphasis
          role="bold">Directories</emphasis></emphasis></emphasis> EXT2
          directories are simply special files (themselves described by
          inodes) which contain pointers to the inodes of their directory
          entries.</para>

          <para><emphasis role="bold">Blocks</emphasis> The EXT2 file system
          divides the logical partition that it occupies into Block
          Groups:</para>

          <figure>
            <title>Ext2 Blocks</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/ext2.gif" />
              </imageobject>
            </mediaobject>
          </figure>

          <para>Block devices are just a series of blocks that can be read and
          written. Each group duplicates information critical to the integrity
          of the file system as well as holding real files and directories as
          blocks of information and data. This duplication is necessary for
          file system recovering.</para>

          <para><emphasis role="bold">The EXT2 Inode</emphasis></para>

          <figure>
            <title>Ext2 Inode</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/ext2_inode.gif" />
              </imageobject>
            </mediaobject>
          </figure>

          <para>In the EXT2 file system, the inode is the basic building
          block; every file and directory in the file system is described by
          one and only one inode. The EXT2 inodes for each Block Group are
          kept in the inode table together with a bitmap that allows the
          system to keep track of allocated and unallocated inodes. It
          contains the following fields:</para>

          <para><emphasis role="bold">mode</emphasis> This holds two pieces of
          information; what this inode describes and the permissions that
          users have to it. For EXT2, an inode can describe one of file,
          directory, symbolic link, block device, character device or
          FIFO.</para>

          <para><emphasis role="bold">Owner Information</emphasis> The user
          and group identifiers of the owners of this file or
          directory.</para>

          <para><emphasis role="bold">Size</emphasis> The size of the file in
          bytes,</para>

          <para><emphasis role="bold">Timestamps</emphasis> The time that the
          inode was created and the last time that it was modified,</para>

          <para><emphasis role="bold">Datablocks</emphasis> Pointers to the
          blocks that contain the data that this inode is describing. The
          first twelve are pointers to the physical blocks containing the data
          described by this inode and the last three pointers contain more and
          more levels of indirection.</para>

          <para><emphasis role="bold">The EXT2 Superblock</emphasis> The
          Superblock contains a description of the basic size and shape of
          this file system. The information within it allows the file system
          manager to use and maintain the file system. Usually only the
          Superblock in Block Group 0 is read when the file system is mounted
          but each Block Group contains a duplicate copy in case of file
          system corruption.</para>

          <para><emphasis role="bold">Magic Number</emphasis> This allows the
          mounting software to check that this is indeed the Superblock for an
          EXT2 file system. For the current version of EXT2 this is
          0xEF53.</para>

          <para><emphasis role="bold">Revision Level</emphasis> The major and
          minor revision levels allow the mounting code to determine whether
          or not this file system supports features that are only available in
          particular revisions of the file system.</para>

          <para><emphasis role="bold">Mount Count and Maximum Mount
          Count</emphasis> Together these allow the system to determine if the
          file system should be fully checked.</para>

          <para><emphasis role="bold">Block Group Number </emphasis> The Block
          Group number that holds this copy of the Superblock,</para>

          <para><emphasis role="bold">Block Size</emphasis> The size of the
          block for this file system in bytes, for example 1024 bytes,</para>

          <para><emphasis role="bold">Blocks per Group </emphasis> The number
          of blocks in a group. Like the block size this is fixed when the
          file system is created,</para>

          <para><emphasis role="bold">Free Blocks </emphasis> The number of
          free blocks in the file system,</para>

          <para><emphasis role="bold">Free Inodes </emphasis> The number of
          free Inodes in the file system,</para>

          <para><emphasis role="bold">First Inode </emphasis> This is the
          inode number of the first inode in the file system. The first inode
          in an EXT2 root file system would be the directory entry for the '/'
          directory.</para>

          <para><emphasis role="bold">The EXT2 Group Descriptor</emphasis>
          Each Block Group has a data structure describing it. Like the
          Superblock, all the group descriptors for all of the Block Groups
          are duplicated in each Block Group in case of file system
          corruption.</para>

          <para><emphasis role="bold">Blocks Bitmap</emphasis> The block
          number of the block allocation bitmap for this Block Group.</para>

          <para><emphasis role="bold">Inode Bitmap</emphasis> The block number
          of the inode allocation bitmap for this Block Group.</para>

          <para><emphasis role="bold">Inode Table</emphasis> The block number
          of the starting block for the inode table for this Block Group. Each
          inode is represented by the EXT2 inode data structure described
          below.</para>

          <para><emphasis role="bold">Free blocks count, Free Inodes count,
          Used directory count</emphasis> The group descriptors are placed on
          after another and together they make the group descriptor table.
          Each Blocks Group contains the entire table of group descriptors
          after its copy of the Superblock. Only the first copy (in Block
          Group 0) is actually used by the EXT2 file system. The other copies
          are there, like the copies of the Superblock, in case the main copy
          is corrupted.</para>

          <para><emphasis role="bold">EXT2 Directories</emphasis></para>

          <figure>
            <title>Ext2 Directories</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/ext2_dir.gif" />
              </imageobject>
            </mediaobject>
          </figure>

          <para>In the EXT2 file system, directories are special files that
          are used to create and hold access paths to the files in the file
          system. A directory file is a list of directory entries, each one
          containing the following information:</para>

          <para><emphasis role="bold">inode</emphasis> The inode for this
          directory entry. This is an index into the array of inodes held in
          the Inode Table of the Block Group.</para>

          <para><emphasis role="bold">name length </emphasis> The length of
          this directory entry in bytes,</para>

          <para><emphasis role="bold">name </emphasis> The name of this
          directory entry.</para>
        </listitem>

        <listitem>
          <para>The Virtual File System (VFS)</para>

          <para>The VFS maintains data structures that describe the whole
          (virtual) file system and the real, mounted, file systems. The VFS
          describes the system's files in terms of superblocks and inodes in
          much the same way as the EXT2 file system uses superblocks and
          inodes.</para>

          <figure>
            <title>VFS - Virtual File System</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/vfs.gif" />
              </imageobject>
            </mediaobject>
          </figure>

          <para>The VFS inodes describe files and directories within the
          system; the contents and topology of the Virtual File System.</para>

          <itemizedlist>
            <listitem>
              <para>As each file system is initialised, it registers itself
              with the VFS.</para>
            </listitem>

            <listitem>
              <para>This happens as the operating system initialises itself at
              system boot time</para>
            </listitem>

            <listitem>
              <para>The real file systems are either built into the kernel
              itself or are built as loadable modules.</para>
            </listitem>
          </itemizedlist>

          <para>When a block device based file system is mounted, and this
          includes the root file system, the VFS must read its superblock.
          Each file system type's superblock read routine must work out the
          file system's topology and map that information onto a VFS
          superblock data structure. The VFS keeps a list of the mounted file
          systems in the system together with their VFS superblocks. Each VFS
          superblock contains information and pointers to routines that
          perform particular functions.</para>

          <itemizedlist>
            <listitem>
              <para>The superblock representing a mounted EXT2 file system
              contains a pointer to the EXT2 specific inode reading
              routine.</para>
            </listitem>

            <listitem>
              <para>This EXT2 inode read routine, like all of the file system
              specific inode read routines, fills out the fields in a VFS
              inode.</para>
            </listitem>

            <listitem>
              <para>Each VFS superblock contains a pointer to the first VFS
              inode on the file system. For the root file system, this is the
              inode that represents the ``/'' directory.</para>
            </listitem>

            <listitem>
              <para>This mapping of information is very efficient for the EXT2
              file system but moderately less so for other file
              systems.</para>
            </listitem>
          </itemizedlist>

          <para>As the system's processes access directories and files, system
          routines are called that traverse the VFS inodes in the
          system.</para>

          <para><emphasis role="bold">The VFS Inode</emphasis> Like the EXT2
          file system, every file, directory and so on in the VFS is
          represented by one and only one VFS inode. The information in each
          VFS inode is built from information in the underlying file system by
          file system specific routines. VFS inodes exist only in the kernel's
          memory and are kept in the VFS inode cache as long as they are
          useful to the system.</para>

          <para><emphasis role="bold">Mounting a File System</emphasis>
          Consider the following mount command:</para>

          <programlisting>$ mount -t iso9660 -o ro /dev/cdrom /mnt/cdrom
</programlisting>

          <para>This mount command will pass the kernel three pieces of
          information; the name of the file system, the physical block device
          that contains the file system and, thirdly, where in the existing
          file system topology the new file system is to be mounted.</para>

          <figure>
            <title>Mount Structure</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/mounted.gif" />
              </imageobject>
            </mediaobject>
          </figure>
        </listitem>

        <listitem>
          <para>The /proc File System</para>

          <para>The /proc file system really shows the power of the Virtual
          File System. It does not really exist, neither the /proc directory
          nor its subdirectories and its files actually exist:</para>

          <itemizedlist>
            <listitem>
              <para>The /proc file system, like a real file system, registers
              itself with the Virtual File System.</para>
            </listitem>

            <listitem>
              <para>When the VFS makes calls to it requesting inodes as its
              files and directories are opened, the /proc file system creates
              those files and directories from information within the
              kernel.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>
  </chapter>

  <chapter id="threads">
    <title>Threads</title>

    <section id="threads_introduction">
      <title>Introduction</title>

      <itemizedlist mark="bullet" spacing="normal">
        <listitem>
          <para>Threads</para>

          <itemizedlist>
            <listitem>
              <para>Definition:</para>

              <itemizedlist spacing="compact">
                <listitem>
                  <para>A thread is a single sequential flow of control within
                  a program.</para>
                </listitem>

                <listitem>
                  <para>A thread runs within the context of a program's
                  process and takes advantage of the resources allocated for
                  that process and its environment.</para>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para>Multiple threads:</para>

              <itemizedlist spacing="compact">
                <listitem>
                  <para>Multiple threads can run at the same time in the same
                  process performing different tasks.</para>
                </listitem>

                <listitem>
                  <para>Multiple threads can share the resources of the
                  process they share.</para>

                  <figure>
                    <title>Multiples Threads</title>

                    <mediaobject>
                      <imageobject>
                        <imagedata fileref="img/Parallel4.gif" />
                      </imageobject>
                    </mediaobject>
                  </figure>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Advantages of Multithreading</para>

          <itemizedlist>
            <listitem>
              <para>Improve applications responsiveness</para>
            </listitem>

            <listitem>
              <para>Use multiprocessors efficiently.</para>
            </listitem>

            <listitem>
              <para>Improve program structure.</para>
            </listitem>

            <listitem>
              <para>Use fewer system resources</para>
            </listitem>

            <listitem>
              <para>Improve performance.</para>

              <para><emphasis role="bold">Threads X
              Processes:</emphasis></para>
            </listitem>

            <listitem>
              <para>In traditional UNIX each process contains a single thread,
              so programming with multiple processes is programming with
              multiple threads.</para>
            </listitem>

            <listitem>
              <para>Because a process is also an address space creating a
              process is expensive, while creating a thread within an existing
              process is cheap.</para>
            </listitem>

            <listitem>
              <para>The time it takes to create a thread is on the order of a
              thousand times less than the time it takes to create a
              process.</para>
            </listitem>

            <listitem>
              <para>Communicating between the threads of one process is simple
              because the threads share everything-address space, in
              particular.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>User-level Threads</para>

          <para>User-level threads are handled in user space:</para>

          <itemizedlist>
            <listitem>
              <para>They reduce kernel context switching penalties.</para>
            </listitem>

            <listitem>
              <para>They are visible only from within the process, where they
              share all process resources like address space, open files, and
              so on.</para>
            </listitem>

            <listitem>
              <para>When a thread needs to interact with other threads in the
              same process, it can do so without involving the operating
              system, reducing context switching penalties.</para>
            </listitem>

            <listitem>
              <para>An application can have thousands of threads and still not
              consume many kernel resources.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>

    <section id="threads_lightweight_process">
      <title>Lightweight Process</title>

      <para><emphasis role="bold">Definition:</emphasis></para>

      <para>Threads are implemented by a library that utilizes underlying
      kernel-supported threads of control, called light-weight processes
      (LWPs).</para>

      <para>Each LWP can be thought of as a virtual CPU which is available for
      executing code or system calls. Each LWP:</para>

      <itemizedlist>
        <listitem>
          <para>is separately dispatched by the kernel.</para>
        </listitem>

        <listitem>
          <para>may perform independent system calls.</para>
        </listitem>

        <listitem>
          <para>incur independent page faults.</para>
        </listitem>

        <listitem>
          <para>may run in parallel on a multiprocessor.</para>
        </listitem>
      </itemizedlist>

      <para><emphasis role="bold">Note:</emphasis> Most programmers use
      threads without thinking about LWPs.</para>

      <figure>
        <title>Solaris LWPs</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="img/Parallel5.gif" />
          </imageobject>
        </mediaobject>
      </figure>

      <itemizedlist>
        <listitem>
          <para>Mapping threads to LWPs</para>

          <para>All the LWPs in the system are scheduled by the kernel onto
          the available CPUs according to their scheduling class and
          priority.</para>

          <itemizedlist>
            <listitem>
              <para>Each process contains one or more LWPs, each of which runs
              one or more user threads.</para>
            </listitem>

            <listitem>
              <para>There is no one-to-one mapping between user threads and
              LWPs.</para>
            </listitem>

            <listitem>
              <para>User-level unbound threads can freely migrate from one LWP
              to another.</para>
            </listitem>

            <listitem>
              <para>If there are available processors, the LWPs run in
              parallel.</para>
            </listitem>

            <listitem>
              <para>The OS has no knowledge about what user threads are or how
              many are active in each process.</para>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">Unbound Threads:</emphasis></para>

          <para>Threads that are scheduled on the LWP pool are called unbound
          threads. They float among the LWPs.</para>

          <itemizedlist>
            <listitem>
              <para>The library invokes LWPs as needed and assigns them to
              execute runnable threads.</para>
            </listitem>

            <listitem>
              <para>The LWP assumes the state of the thread and executes its
              instructions.</para>
            </listitem>

            <listitem>
              <para>If another thread should be run, the thread state is saved
              in process memory and the threads library assigns another thread
              to the LWP.</para>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">Bound Threads:</emphasis></para>

          <para>If needed, a thread can be permanently bonded to an
          LWP.</para>

          <para>For example, you can bind a thread to:</para>

          <itemizedlist>
            <listitem>
              <para>Have the thread scheduled globally (such as
              realtime)</para>
            </listitem>

            <listitem>
              <para>Give the thread an alternate signal stack</para>
            </listitem>

            <listitem>
              <para>Give the thread a unique alarm or timer</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>Threads Library Implementation</para>

          <para>Each thread is represented by a thread structure that
          contains:</para>

          <itemizedlist>
            <listitem>
              <para>The thread ID.</para>
            </listitem>

            <listitem>
              <para>An area to save the thread execution context.</para>
            </listitem>

            <listitem>
              <para>The thread signal mask</para>
            </listitem>

            <listitem>
              <para>The thread priority</para>
            </listitem>

            <listitem>
              <para>A pointer to the thread stack.</para>
            </listitem>
          </itemizedlist>

          <para>The storage for the stack is either automatically allocated by
          the library or it is passed in by the application on thread
          creation</para>

          <para>When a thread is created, a thread ID is assigned. The thread
          ID is used as an index in a table of pointers to thread
          structures.</para>

          <para><emphasis role="bold">Thread-local Storage:</emphasis></para>

          <para>Threads have some private storage (in addition to the stack)
          called thread-local storage (TLS).</para>

          <para>Most variables in the program are shared among all the threads
          executing it, but each thread has its own copy of thread-local
          variables.</para>

          <para>Conceptually, thread-local storage is</para>

          <itemizedlist>
            <listitem>
              <para>Unshared.</para>
            </listitem>

            <listitem>
              <para>Statically allocated data.</para>
            </listitem>

            <listitem>
              <para>Used for thread-private data that must be accessed
              quickly.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>

    <section id="threads_scheduling">
      <title>Scheduling</title>

      <itemizedlist>
        <listitem>
          <para>Thread Scheduling</para>

          <para>The threads library implements a thread scheduler that
          multiplexes thread execution across a pool of LWPs.</para>

          <figure>
            <title>Thread Scheduling</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/Parallel6.gif" />
              </imageobject>
            </mediaobject>
          </figure>

          <orderedlist>
            <listitem>
              <para>An LWP in the pool is either idling or running a
              thread.</para>
            </listitem>

            <listitem>
              <para>When a thread, T1 is made runnable, it is added to the
              dispatch queue.</para>
            </listitem>

            <listitem>
              <para>An idle LWP L1 in the pool is awakened by signalling the
              idle synchronization variable.</para>
            </listitem>

            <listitem>
              <para>LWP L1 wakes up and switches to the highest priority
              thread on the dispatch queue.</para>
            </listitem>

            <listitem>
              <para>If T1 blocks on a local synchronization object, L1 puts T1
              on a sleep queue and then switches to the highest priority
              thread on the dispatch queue.</para>
            </listitem>

            <listitem>
              <para>If the dispatch queue is empty, the LWP goes back to
              idling.</para>
            </listitem>

            <listitem>
              <para>If all LWPs in the pool are busy when T1 becomes runnable,
              T1 simply stays on the dispatch queue, waiting for an LWP to
              become available.</para>
            </listitem>
          </orderedlist>

          <para>An LWP becomes available either when a new one is added to the
          pool or when one of the running threads blocks on a process-local
          synchronization variable, exits or stops, freeing its LWP.</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>Thread States</para>

          <para>An unbound thread can be in one of five different
          states:</para>

          <itemizedlist>
            <listitem>
              <para>RUNNABLE</para>
            </listitem>

            <listitem>
              <para>ACTIVE</para>
            </listitem>

            <listitem>
              <para>SLEEPING</para>
            </listitem>

            <listitem>
              <para>STOPPED</para>
            </listitem>

            <listitem>
              <para>ZOMBIE</para>
            </listitem>
          </itemizedlist>

          <para>The transitions between these states and the events that cause
          these transitions are:</para>

          <figure>
            <title>Thread States</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/Parallel7.gif" />
              </imageobject>
            </mediaobject>
          </figure>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>Preemption</para>

          <para>Threads compete for LWPs based on their priorities.</para>

          <para>A queue of ACTIVE threads is maintained.</para>

          <para>If a RUNNABLE thread has a higher priority than that of some
          ACTIVE thread:</para>

          <orderedlist>
            <listitem>
              <para>This thread is removed from the ACTIVE queue and preempted
              from its LWP.</para>
            </listitem>

            <listitem>
              <para>This LWP then schedules the higher priority RUNNABLE
              thread which caused the preemption.</para>
            </listitem>
          </orderedlist>

          <para>There are basically two cases when the need to preempt
          arises:</para>

          <itemizedlist>
            <listitem>
              <para>When a newly RUNNABLE thread has a higher priority than
              that of the lowest priority ACTIVE thread.</para>
            </listitem>

            <listitem>
              <para>When the priority of an ACTIVE thread is lowered below
              that of the highest priority RUNNABLE thread.</para>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">Cleaning ZOMBIE
          Threads:</emphasis></para>

          <para>When a thread terminates, it is put on a deathrow queue and
          their state is set to ZOMBIE.</para>

          <para><emphasis role="bold">Note:</emphasis> The action of freeing a
          thread's stack is not done at thread exit time to minimize the cost
          of thread exit by deferring unnecessary and expensive work.</para>

          <para>A special thread called the reaper does this job
          periodically:</para>

          <itemizedlist>
            <listitem>
              <para>The reaper runs when there are idle LWPs, or when a reap
              limit is reached.</para>
            </listitem>

            <listitem>
              <para>The reaper traverses the deathrow list, freeing the stack
              for each thread.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>

    <section id="threads_synchronization">
      <title>Synchronization</title>

      <itemizedlist>
        <listitem>
          <para>Thread Synchronization</para>

          <para>Synchronization objects are variables in memory that you
          access just like data.</para>

          <para>The main types of synchronization objects are:</para>

          <itemizedlist>
            <listitem>
              <para>Mutex Locks</para>
            </listitem>

            <listitem>
              <para>Condition Variables</para>
            </listitem>

            <listitem>
              <para>Semaphores</para>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">Note: </emphasis>Synchronization is the
          only way to ensure consistency of shared data.</para>

          <para><emphasis role="bold">Synchronization
          Variables:</emphasis></para>

          <para>The default blocking behavior is to put a thread to
          sleep.</para>

          <para>Each synchronization variable has a sleep queue associated
          with it:</para>

          <orderedlist>
            <listitem>
              <para>The synchronization primitives put the blocking threads on
              the synchronization variable's sleep queue</para>
            </listitem>

            <listitem>
              <para>They surrenders the executing thread to the
              scheduler.</para>
            </listitem>

            <listitem>
              <para>The scheduler tries to execute another thread.</para>
            </listitem>
          </orderedlist>

          <para>Blocked threads are awakened when the synchronization
          variables become available:</para>

          <orderedlist>
            <listitem>
              <para>The synchronization primitives check if threads are
              waiting for the synchronization variables.</para>
            </listitem>

            <listitem>
              <para>The unblocked threads are removed from the synchronization
              variable's sleep queue.</para>
            </listitem>

            <listitem>
              <para>The scheduler places the threads on a run queue
              corresponding to their priority.</para>
            </listitem>

            <listitem>
              <para>The thread are then dispatched to execution in priority
              order.</para>
            </listitem>
          </orderedlist>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>Mutual Exclusion Locks</para>

          <para>Mutual exclusion locks (mutexes) are used to serialize thread
          execution, by ensuring that only one thread at a time executes a
          critical section of code.</para>

          <orderedlist>
            <listitem>
              <para>A thread acquires the lock.</para>
            </listitem>

            <listitem>
              <para>Executes critical section of code.</para>
            </listitem>

            <listitem>
              <para>Releases lock.</para>
            </listitem>
          </orderedlist>

          <para><emphasis role="bold">Note:</emphasis> Mutex locks can also
          preserve code that was written to run serially and thus is not
          thread safe.</para>

          <programlisting><emphasis role="bold">Basic Routines*         Operation </emphasis>
pthread_mutex_init      Initialize a Mutual Exclusion Lock 
pthread_mutex_lock      Lock a Mutex
pthread_mutex_unlock    Unlock a Mutex
pthread_mutex_destroy   Destroy Mutex State</programlisting>

          <para>Producer-Consumer Example:</para>

          <programlisting>pthread_mutex_t count_mutex;
int count;

increment_count() {
   <emphasis role="bold">pthread_mutex_lock(&amp;count_mutex);</emphasis>
   count = count + 1;
   <emphasis><emphasis role="bold">pthread_mutex_unlock(&amp;count_mutex);</emphasis>
}</emphasis>

int get_count() {
   int c;
   <emphasis role="bold">pthread_mutex_lock(&amp;count_mutex);</emphasis>
   c = count;
   <emphasis role="bold">mutex_unlock(&amp;count_mutex);</emphasis>
   return (c);
}</programlisting>

          <para>* The examples as implemented using the Linux threads library
          based on the POSIX 1003.c standard.</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>Condition Variables</para>

          <para>Condition variables atomically block threads until a
          particular condition is true.</para>

          <para>With a condition variable, a thread can atomically block until
          a condition is satisfied:</para>

          <itemizedlist>
            <listitem>
              <para>When the condition is false:</para>

              <orderedlist>
                <listitem>
                  <para>A thread acquires the mutex.</para>
                </listitem>

                <listitem>
                  <para>It blocks on the condition variable.</para>
                </listitem>

                <listitem>
                  <para>It atomically releases the mutex waiting for the
                  condition to change.</para>
                </listitem>
              </orderedlist>
            </listitem>

            <listitem>
              <para>When another thread changes the condition:</para>

              <orderedlist>
                <listitem>
                  <para>The associated condition variable is signaled to cause
                  waiting threads to wake up.</para>
                </listitem>

                <listitem>
                  <para>One of the threads reacquire the mutex, and
                  re-evaluate the condition.</para>
                </listitem>

                <listitem>
                  <para>It continues critical code execution.</para>
                </listitem>

                <listitem>
                  <para>It releases the mutex allowing other blocked threads
                  to proceed.</para>
                </listitem>
              </orderedlist>
            </listitem>
          </itemizedlist>

          <para>Note: Always test condition variables under the protection of
          a mutex lock.</para>

          <programlisting><emphasis role="bold">Basic Routines            Operation</emphasis>

pthread_cond_init         Initialize a Condition Variable
pthread_cond_wait         Block on a Condition Variable
pthread_cond_signal       Unblock a Specific Thread
pthread_cond_timedwait    Block Until a Specified Event
pthread_cond_broadcast    Unblock All Threads
pthread_cond_destroy      Destroy Condition Variable State</programlisting>

          <para>Producer-Consumer Example:</para>

          <programlisting>typedef struct {
    char buf[BSIZE];
    int occupied;
    int nextin;
    int nextout;
    pthread_mutex_t mutex;
    pthread_cond_t more;
    pthread_cond_t less;
} buffer_t;

buffer_t buffer;
void producer(buffer_t *b, char item) {
    <emphasis role="bold">pthread_mutex_lock(&amp;b-&gt;mutex);</emphasis>
    while (b-&gt;occupied == BSIZE)
        <emphasis role="bold">pthread_cond_wait(&amp;b-&gt;less, &amp;b-&gt;mutex);</emphasis>
    b-&gt;buf[b-&gt;nextin] = item;
    nextin++;
    b-&gt;nextin %= BSIZE; /* Makes nextin &lt; BSIZE or 0 */
    b-&gt;occupied++;
  
    <emphasis role="bold">pthread_cond_signal(&amp;b-&gt;more);</emphasis>
    <emphasis role="bold">pthread_mutex_unlock(&amp;b-&gt;mutex);</emphasis>
}
char consumer(buffer_t *b) {
    char item;
    <emphasis role="bold">pthread_mutex_lock(&amp;b-&gt;mutex);</emphasis>
    while(b-&gt;occupied == 0)
        <emphasis role="bold">pthread_cond_wait(&amp;b-&gt;more, &amp;b-&gt;mutex);</emphasis>
    item = b-&gt;buf[b-&gt;nextout];
    b-&gt;nextout++;
    b-&gt;nextout %= BSIZE;  /* Makes nextout &lt; BSIZE or 0 */
    b-&gt;occupied--;
    
    <emphasis role="bold">pthread_cond_signal(&amp;b-&gt;less);</emphasis>
    <emphasis role="bold">pthread_mutex_unlock(&amp;b-&gt;mutex);</emphasis>
    return(item);
}</programlisting>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>Semaphores</para>

          <para>Semaphores are modeled after the operation of single track
          railroads: A train must wait a semaphore signal before entering a
          single track.</para>

          <para>In the computer version, a semaphore uses a simple
          integer:</para>

          <para>Producer-Consumer Example:</para>

          <para>In the computer version, a semaphore uses a simple
          integer:</para>

          <orderedlist>
            <listitem>
              <para>A thread waits for permission to proceed (It waits until
              the semaphore value is positive).</para>
            </listitem>

            <listitem>
              <para>Then signals that it has proceeded by subtracting one from
              the semaphore.</para>
            </listitem>

            <listitem>
              <para>It executes some restricted code.</para>
            </listitem>

            <listitem>
              <para>When it is finished, the thread adds one to the
              semaphore's value.</para>
            </listitem>
          </orderedlist>

          <para><emphasis role="bold">Note: </emphasis>All these semaphore
          operations take place atomically, they cannot be subdivided into
          pieces between which other actions on the semaphore can take
          place.</para>

          <para>There are two basic sorts of semaphores:</para>

          <itemizedlist>
            <listitem>
              <para><emphasis role="bold">Binary semaphores</emphasis>, which
              never take on values other than zero or one (It is like a
              mutex).</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Counting semaphores</emphasis>,
              which can take on arbitrary nonnegative values.</para>
            </listitem>
          </itemizedlist>

          <para>Semaphores are typically used to coordinate access to
          resources, with the semaphore count initialized to the number of
          free resources:</para>

          <itemizedlist>
            <listitem>
              <para>Threads atomically increment the count when resources are
              added.</para>
            </listitem>

            <listitem>
              <para>Threads atomically decrement the count when resources are
              removed.</para>
            </listitem>

            <listitem>
              <para>Threads block when no resources are available.</para>
            </listitem>
          </itemizedlist>

          <programlisting><emphasis role="bold">Basic Routines   Operation</emphasis>
sem_init         Initialize a Semaphore
sem_post         Increment a Semaphore
sem_wait         Block on a Semaphore Count
sem_trywait      Decrement a Semaphore Count
sem_destroy      Destroy the Semaphore State
</programlisting>

          <para>Producer-Consumer Example:</para>

          <programlisting>typedef struct {
    char buf[BSIZE];
    sem_t occupied;
    sem_t empty;
    int nextin;
    int nextout;
    sem_t pmut;
    sem_t cmut;
} buffer_t;

buffer_t buffer;

<emphasis role="bold">sem_init(&amp;buffer.occupied, USYNC_THREAD, 0);
sem_init(&amp;buffer.empty, USYNC_THREAD, BSIZE);
sem_init(&amp;buffer.pmut, USYNC_THREAD, 1);
sem_init(&amp;buffer.cmut, USYNC_THREAD, 1);</emphasis>

buffer.nextin = buffer.nextout = 0;
void producer(buffer_t *b, char item) {
    <emphasis role="bold">sem_wait(&amp;b-&gt;empty);
    sem_wait(&amp;b-&gt;pmut);</emphasis>
    b-&gt;buf[b-&gt;nextin] = item;
    b-&gt;nextin++;
    b-&gt;nextin %= BSIZE;
    <emphasis role="bold">sem_post(&amp;b-&gt;pmut);
    sem_post(&amp;b-&gt;occupied);</emphasis>
}
char consumer(buffer_t *b) {
    char item;
 <emphasis role="bold">   sem_wait(&amp;b-&gt;occupied);
    sem_wait(&amp;b-&gt;cmut);</emphasis>
    item = b-&gt;buf[b-&gt;nextout];
    b-&gt;nextout++;
    b-&gt;nextout %= BSIZE;
 <emphasis>   sem_post(&amp;b-&gt;cmut);
    sem_post(&amp;b-&gt;empty);</emphasis>
    return(item);
}</programlisting>
        </listitem>
      </itemizedlist>
    </section>
  </chapter>

  <chapter id="distributed_programming">
    <title>Distribution Programming</title>

    <section id="distributed_programming_the_client_server_model">
      <title>The Client/Server Model</title>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">The Client/Server
          Model</emphasis></para>

          <para><emphasis role="bold">Distributed System:</emphasis></para>

          <para>A distributed computer system contains software programs and
          data resources dispersed across independent computers connected
          through a communication network.</para>

          <para><emphasis role="bold">Advantages:</emphasis></para>

          <para>It allows users of individual, networked computers to share
          data and processing power, often over long distances.</para>

          <para>Distribution can also enhance availability, reliability and
          performance.</para>

          <figure>
            <title>Heterogeneous Network</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/Servers1.gif" />
              </imageobject>
            </mediaobject>
          </figure>

          <para><emphasis role="bold">Coordination Models:</emphasis></para>

          <para>A coordination model establishes logical roles and associated
          behaviours (for applications that assume such roles) for executing
          distributed interactions.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Client/Server Model</emphasis></para>

          <para><emphasis role="bold">The client:</emphasis> requests an
          operation or service that some other application, the server,
          provides.</para>

          <para><emphasis role="bold">The server:</emphasis> receives a client
          request, performs the requested service and returns to the client
          any results.</para>

          <para><emphasis role="bold">Advantages:</emphasis></para>

          <itemizedlist>
            <listitem>
              <para>It offers simplicity in closely matching the flow of data
              with the control flow.</para>
            </listitem>

            <listitem>
              <para>It promotes modular, flexible, and extensive system
              designs.</para>
            </listitem>

            <listitem>
              <para>Data resources and computing services can be organized,
              integrated and used as a service.</para>
            </listitem>

            <listitem>
              <para>Widely used in distributed systems.</para>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">Communication:</emphasis></para>

          <itemizedlist>
            <listitem>
              <para>Servers communicate over a network.</para>
            </listitem>

            <listitem>
              <para>In Unix and Windows machines the network uses: TCP/IP
              &amp; UDP.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Networking Basics</emphasis></para>

          <para>TCP and UDP protocols:</para>

          <figure>
            <title>Network Layers</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/Servers2.gif" />
              </imageobject>
            </mediaobject>
          </figure>

          <itemizedlist>
            <listitem>
              <para><emphasis role="bold">TCP</emphasis></para>

              <para><emphasis role="bold">Definition:</emphasis></para>

              <para>TCP is a connection-based protocol that provides a
              reliable flow of data between two computers.</para>

              <para><emphasis role="bold">Examples:</emphasis> HTTP, ftp,
              Telnet</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">UDP</emphasis></para>

              <para><emphasis role="bold">Definition:</emphasis></para>

              <para>UDP is a protocol that sends independent packets of data,
              called datagrams from one computer to another with no guarantees
              about arrival.</para>

              <para><emphasis role="bold">Examples:</emphasis> ping</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Ports</emphasis></para>

              <para><emphasis role="bold">Definition:</emphasis></para>

              <para>The TCP and UDP protocols use ports to map incoming data
              to a particular process running on a computer.</para>

              <itemizedlist>
                <listitem>
                  <para><emphasis role="bold">Computers</emphasis> are
                  identified by a 32-bit IP address.</para>
                </listitem>

                <listitem>
                  <para><emphasis role="bold">IP</emphasis> uses to deliver
                  data to the right computer on the network.</para>
                </listitem>

                <listitem>
                  <para><emphasis role="bold">Ports</emphasis> are identified
                  by a 16-bit number.</para>
                </listitem>

                <listitem>
                  <para><emphasis role="bold">TCP and UDP</emphasis> use to
                  deliver the data to the right application.</para>

                  <figure>
                    <title>Ports</title>

                    <mediaobject>
                      <imageobject>
                        <imagedata fileref="img/Servers3.gif" />
                      </imageobject>
                    </mediaobject>
                  </figure>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Port Numbers</emphasis></para>

              <para><emphasis role="bold">Range:</emphasis> from 0 to
              65535</para>

              <para><emphasis role="bold">Reserved:</emphasis> 0 - 1023 are
              restricted--they are reserved for use by services such as HTTP
              and ftp and other system services.</para>

              <figure>
                <title>Port Numbers</title>

                <mediaobject>
                  <imageobject>
                    <imagedata fileref="img/Servers4.gif" />
                  </imageobject>
                </mediaobject>
              </figure>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Sockets</emphasis></para>

          <itemizedlist>
            <listitem>
              <para>Are the basic components of interprocess
              communication.</para>
            </listitem>

            <listitem>
              <para>Provide access to the network transport protocols.</para>
            </listitem>

            <listitem>
              <para>Are an endpoint of communication to which a name can be
              bound.</para>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">Stream Socket:</emphasis></para>

          <para>A stream socket provides bidirectional, reliable, sequential,
          and unduplicated flow of data with no record boundaries. It uses
          TCP/IP protocol.</para>

          <para><emphasis role="bold">Datagram Socket:</emphasis></para>

          <para>A datagram socket provides bidirectional flow of data, the
          data is divided in packages, the receiver can receive them in a
          different order from the sending sequence and may receive duplicated
          messages. It uses UDP protocol.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="distributed_programming_stream_sockets">
      <title>Stream Sockets</title>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">What is a Socket?</emphasis></para>

          <para><emphasis role="bold">Definition:</emphasis></para>

          <para>A socket is one end-point of a two-way communication link
          between two programs running on the network.</para>

          <para><emphasis role="bold">Stream Socket:</emphasis></para>

          <para>It provides bidirectional, reliable, sequenced, and
          unduplicated flow of data with no record boundaries.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Socket Creation</emphasis></para>

          <para>The socket() call creates a socket:</para>

          <programlisting>s= socket( domain, type, protocol);
</programlisting>

          <para><emphasis role="bold">Domain:</emphasis></para>

          <para>It is specified by one of the constants defined in
          &lt;sys/socket.h&gt;.</para>

          <itemizedlist>
            <listitem>
              <para>For the UNIX domain: AF_UNIX</para>
            </listitem>

            <listitem>
              <para>For the Internet domain: AF_INET.</para>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">Type:</emphasis></para>

          <para>Socket types are defined in &lt;sys/socket.h&gt;. Three types
          are supported by AF_UNIX and AF_INET domains:</para>

          <para>- SOCK_STREAM for stream sockets.</para>

          <para>- SOCK_DGRAM for datagram sockets.</para>

          <para>- SOCK_RAW for row sockets.</para>

          <para><emphasis role="bold">Protocol:</emphasis></para>

          <para>The argument 0 should be used in most cases. The system will
          select a protocol that supports the requested socket type.</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Binding</emphasis></para>

          <para>A socket is created with no name. A remote process has no way
          to refer to a socket until an address is bound to it.</para>

          <para>In the Internet domain a connection is composed of &lt;local
          address, local port, foreign address foreign port&gt;.</para>

          <para>The bind() call allows a process to specify half of an
          association, such as &lt;local address, local port&gt;:</para>

          <programlisting>bind (s, name, namelen);</programlisting>

          <simpara>- s is the socket handle.</simpara>

          <simpara>- name is a byte string that is interpreted by the
          supporting protocol. Internet domain names contain an Internet
          address and port number.</simpara>

          <para><emphasis role="bold">Internet binding:</emphasis></para>

          <programlisting>struct sockaddr_in name;
...
name.sin_family = AF_INET;
name.sin_addr.s_addr = INADDR_ANY;
name.sin_port = 0;
bind (sock, (struct sockaddr *)&amp;name, sizeof(name));</programlisting>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Connection
          Establishment</emphasis></para>

          <para>Connection establishment is usually asymmetric, with one
          process acting as the client and the other as the server:</para>

          <orderedlist>
            <listitem>
              <para>The server binds a socket to a well known address.</para>
            </listitem>

            <listitem>
              <para>It blocks on its socket for a connect request.</para>
            </listitem>

            <listitem>
              <para>An unrelated process can connect to the server.</para>
            </listitem>
          </orderedlist>

          <para><emphasis role="bold">Listening and
          Communicating:</emphasis></para>

          <orderedlist>
            <listitem>
              <para><emphasis role="bold">Request channel:</emphasis> Server
              do the listening.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Communication channel:</emphasis>
              Created for each connection</para>
            </listitem>
          </orderedlist>

          <figure>
            <title>Stream Sockets - Port Numbers</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/Servers4.gif" />
              </imageobject>
            </mediaobject>
          </figure>

          <para><emphasis role="bold">Client side:</emphasis></para>

          <para>On the client side the connect() call initiates a
          connection:</para>

          <programlisting>struct sockaddr_in server;
struct hostent *hp;
...
server.sin_family= AF_INET;
hp= gethostbyname( "host name");
memcpy( (char*) &amp;server.sin_addr, (char*) hp-&gt;h_addr, 
        hp-&gt;h_length);
server.sin_port= htons( port_number );
...
connect( s, (struct sockaddr*) &amp;server, sizeof server);</programlisting>

          <para>gethostbyname() returns a structure including the network
          address of the specified host.</para>

          <para>If the client's socket is unbound at the time of the connect
          call, the system automatically selects and bind a name to the
          socket.</para>

          <para><emphasis role="bold">Server side:</emphasis></para>

          <para>To receive a client's connection , a server must perform two
          steps after binding:</para>

          <orderedlist>
            <listitem>
              <para>Indicate how many connections can be queued using the
              listen() call.</para>
            </listitem>

            <listitem>
              <para>Accept the connection using the accept() call.</para>
            </listitem>
          </orderedlist>

          <programlisting>struct sockaddr_in from;
...
listen(s, 5);
fromlen= sizeof( from );
newsock= accept( s, (struct sockaddr *) &amp;from, &amp;fromlen);</programlisting>

          <para><emphasis>listen() call:</emphasis></para>

          <para>s is the socket bound to the address to which the connection
          request is sent. The second parameter specifies the maximum number
          of outstanding connections that may be queued.</para>

          <para><emphasis>accept() call:</emphasis></para>

          <para>from is a structure that is filled with the address of a
          client. It can be a NULL pointer. accept() normally blocks.</para>

          <para><emphasis role="bold">Note:</emphasis></para>

          <para>accept() returns a <emphasis role="bold">new socket</emphasis>
          descriptor that is connected to the requesting client.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Data Transfer</emphasis></para>

          <para>There are several functions to send and receive data. The
          socket() call returns a file descriptor that can be used with many
          I/O Unix calls like:</para>

          <programlisting>write( s, buf, sizeof buf):
read( s, buf, sizeof buf);</programlisting>

          <para>Or the calls send() and recv() can be used (they include a
          flag argument):</para>

          <programlisting>send( s, buf, sizeof buf, flags);
recv( s, buf, sizeof buf, flags);</programlisting>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Closing Sockets</emphasis></para>

          <para>Sockets can be closed using the close() system call (because
          they are referenced by file descriptors).</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Client Example</emphasis></para>
        </listitem>
      </itemizedlist>

      <programlisting>#include &lt;sys/types.h&gt; 
      #include &lt;sys/socket.h&gt;
      #include &lt;netinet/in.h&gt; 
      #include &lt;netdb.h&gt; 
      #include &lt;stdio.h&gt; 

      #define DATA "1 2 3 TESTING ... " 

      
      main (int argc, char* argv[]) 
      { 
        int sock; 
        struct sockaddr_in server; 
        struct hostent *hp, *gethostbyname(); 

        sock = socket (AF_INET, SOCK_STREAM, 0); 
        if (sock == -1) { 
          perror ("Opening stream socket"); 
          exit (1);
        }
       
        hp = gethostbyname(argv[1]); 

        memcpy ((char*)&amp;server.sin_addr, (char*) hp-&gt;h_addr, hp-&gt;h_length);

        server.sin_family = AF_INET; 
        server.sin_port = htons(atoi(argv[2]));

        if ( connect(sock, (struct sockaddr *)&amp;server, sizeof server) == -1) {
          perror("Connecting stream socket"); 
          exit(1); 
        }

        if (write(sock, DATA, sizeof DATA) == -1) 
          perror("Writing data to stream socket"); 

        close (sock); 
        exit (0); 
      } </programlisting>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Server Example</emphasis></para>
        </listitem>
      </itemizedlist>

      <programlisting>#include
      &lt;sys/types.h&gt; 
      #include &lt;sys/socket.h&gt; 
      #include &lt;netinet/in.h&gt; 
      #include &lt;netdb.h&gt; 
      #include &lt;stdio.h&gt; 

      #define TRUE 1 main() 

      { 

        int sock, length; struct
        sockaddr_in server; 
        int msgsock; 
        char buf[1024]; 
        int rval; 

        sock = socket (AF_INET, SOCK_STREAM, 0); 
        if (sock==-1) { 
          perror( "Opening stream socket"); 
          exit(1); 
        }

        server.sin_family = AF_INET;
        server.sin_addr.s_addr = INADDR_ANY; 
        server.sin_port = 0; 
        if (bind (sock, (struct sockaddr *)&amp;server, sizeof(server)) == -1){
          perror("Binding stream socket"); 
          exit (1); 
        } 
        length = sizeof server; 
        if (getsockname (sock, (struct sockaddr *)&amp;server,&amp;length) == -1){ 
          perror("Getting socket name"); 
          exit (1); 
        }
        printf("Socket port # %d\n", ntohs(server.sin_port)); 
        /* Start accepting connections */ 
        listen( sock, 5); 
        do { 
          msgsock = accept( sock, (struct sockaddr *) 0, (int*) 0); 
          if (msgsock==-1)
            perror("accept"); 
          else do { 
            memset( buf, 0, sizeof buf);
            if ((rval= read( msgsock, buf, 1024)) == -1) 
              perror("Reading data stream"); 
            if (rval == 0) 
              printf("Ending connection\n");
            else
              printf( "--&gt;%s\n", buf);
          } while (rval!=0); 
          close(msgsock);
        } while (TRUE); 
        exit(0); 
    }</programlisting>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Supporting Multiple Clients</emphasis>
          <itemizedlist>
              <listitem>
                <para><emphasis role="bold">Requests treated by one execution
                thread.</emphasis></para>
              </listitem>

              <listitem>
                <para><emphasis role="bold">Individual communication treated
                by: </emphasis><itemizedlist>
                    <listitem>
                      <para>Another process</para>
                    </listitem>

                    <listitem>
                      <para>Another thread in the same process.</para>

                      <figure>
                        <title>Stream Sockets - Multiple Clients</title>

                        <mediaobject>
                          <imageobject>
                            <imagedata fileref="img/Servers6.gif" />
                          </imageobject>
                        </mediaobject>
                      </figure>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
            </itemizedlist></para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="distributed_programming_datagram_sockets">
      <title>Datagram Sockets</title>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Datagram</emphasis></para>

          <para>The UDP protocol provides a mode of network communication
          whereby applications send packets of data, called datagrams to one
          another:</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">What is a Datagram?</emphasis></para>

          <para><emphasis role="bold">Definition:</emphasis></para>

          <para>A datagram is an independent, self-contained message sent over
          the network whose arrival, arrival time, and content are not
          guaranteed.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Data Transfer</emphasis></para>

          <para>Datagram sockets are created in the same way as stream sockets
          (using the SOCK_DGRAM flag). They can use the same calls as stream
          sockets to send and receive data, except for the accept() and
          listen() calls.</para>

          <para>The calls sendto() and recvfrom() are very useful to transfer
          data on datagram sockets:</para>

          <programlisting>sendto( s, buf, buflen, flags, &amp;to, tolen);</programlisting>

          <para>It sends the content of buf to the address indicated in
          &amp;to.</para>

          <programlisting>recvfrom( s, buf, buflen,flags, &amp;from, &amp;fromlen);</programlisting>

          <para>It receives a package and writes it to buf. The address of the
          sender is written to &amp;from.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Writing a Datagram Client and
          Server</emphasis></para>

          <para><emphasis role="bold">The Quote server</emphasis></para>

          <para>It waits for Datagram requests for quotes and servers them in
          Datagram packets.</para>

          <para><emphasis role="bold">Setting up the
          sockets:</emphasis></para>

          <programlisting>sock = socket (AF_INET, SOCK_DGRAM, 0);
   if (sock==-1) { ... }

   server.sin_family = AF_INET;
   server.sin_addr.s_addr = INADDR_ANY; 
   server.sin_port = 0;
   if (bind (sock, (struct sockaddr *)&amp;server, sizeof(server))
       == -1){ perror("Binding datagram socket");...}
   
   length = sizeof server;
   if (getsockname (sock, (struct sockaddr *)&amp;server, &amp;length)
       == -1){ perror("Getting socket name"); ... }
   printf("Socket port # %d\n", ntohs(server.sin_port));</programlisting>

          <para><emphasis role="bold">The infinite loop:</emphasis></para>

          <para>- Section that receives the requests:</para>

          <programlisting>if ( <emphasis role="bold">recvfrom( sock, buf, 16, 0,
                    (struct sockaddr *) &amp;client, &amp;length</emphasis><emphasis
              role="bold">)</emphasis>
         == -1){
        perror("Reading packet");
        exit(1);
     }</programlisting>

          <para>- Section that constructs the responses:</para>

          <programlisting>quote= getquote();
      if ( <emphasis role="bold">sendto( sock, quote, strlen(quote)+1, 0,
                   (struct sockaddr *) &amp;client, sizeof client)</emphasis>
          == -1) {
         perror("Writing quota");
         exit(0);
      }</programlisting>

          <para><emphasis role="bold">The Client Application</emphasis></para>

          <para><emphasis role="bold">Setting up sockets:</emphasis></para>

          <programlisting>sock = <emphasis role="bold">socket (AF_INET, SOCK_DGRAM, 0)</emphasis>;
   if (sock == -1) { perror ("Opening Datagram socket");...}</programlisting>

          <para><emphasis role="bold">The client program sends a request to
          the server:</emphasis></para>

          <programlisting>hp = gethostbyname(argv[1]);
   if (hp == (struct hostent *) 0) {
      perror("Unknown Host");
      exit(0);
   }

   memcpy ((char*)&amp;server.sin_addr, (char*) hp-&gt;h_addr, 
           hp-&gt;h_length);
   server.sin_family = AF_INET;
   server.sin_port = htons(atoi(argv[2]));

   if( <emphasis role="bold">sendto( sock, DATA, sizeof DATA, 0, 
              (struct sockaddr *) &amp;server, sizeof server)</emphasis> 
      == -1) { perror("Sending datagram message"); ... }</programlisting>

          <para><emphasis role="bold">The client gets a response from the
          server:</emphasis></para>

          <programlisting>if (<emphasis role="bold">read( sock, buf, 1024)</emphasis> == -1)
      perror("Receiving quotation");
      exit(1);
   }
   printf("Quote of the Moment: %s\n", buf);
   close(sock);</programlisting>

          <para><emphasis role="bold">Running the Client</emphasis></para>

          <para>Quote of the Moment: Life is wonderful. Without it we'd all be
          dead.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="distributed_programming_rpc_remote_procedure_calls">
      <title>RPC - Remote Procedure Calls</title>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Remote Procedure Calls</emphasis></para>

          <para><emphasis role="bold">Definition:</emphasis></para>

          <para>RPCs translate local procedure calls to remote procedure calls
          in a way transparent to the calling procedure.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Transparency</emphasis></para>

          <para>To be transparent to client and servers routines, RPCs use
          stubs:</para>

          <para><emphasis role="bold">Client Stubs</emphasis> are local
          procedures that are called by clients and handle all packaging of
          arguments and server communication.</para>

          <para><emphasis>It appears to the client that the client stub's
          procedure is the actual server procedure it wants to
          call.</emphasis></para>

          <para><emphasis role="bold">Server Stubs</emphasis> are local
          procedures that wait for client requests, handle packaging of
          arguments and call servers' local procedures (that implement the
          server's service).</para>

          <para><emphasis>It appears to the server that the server stub's call
          is the actual client call it needs to serve.</emphasis></para>

          <para><emphasis role="bold">Parameter Passing:</emphasis></para>

          <para>To make transparent parameter passing between client and
          servers procedures, stubs need to:</para>

          <para>- Pack and unpack procedures parameters for transmission over
          the network.</para>

          <para>- Convert the representation of parameters from one machine to
          another.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">A Remote Procedure
          Call</emphasis></para>

          <figure>
            <title>RPC</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/Servers12.gif" />
              </imageobject>
            </mediaobject>
          </figure>

          <para>Steps of a RPC:</para>

          <orderedlist>
            <listitem>
              <para><emphasis role="bold">Client procedure</emphasis> calls
              the client stub in the normal way.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Client stub</emphasis> builds a
              message and calls the kernel.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Kernel</emphasis> sends the message
              to the kernel in a remote machine.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Remote kernel</emphasis> passes the
              message to the server stub.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Server stub</emphasis> unpacks the
              parameters and calls the server procedure.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Server procedure</emphasis> does the
              work and returns the results to the stub.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold"><emphasis role="bold">Server
              stu</emphasis>b</emphasis> packs it in a message and calls the
              remote kernel.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Remote kernel</emphasis> sends the
              message to the client's kernel.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Kernel</emphasis> passes the message
              to the client stub.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Client stub</emphasis> unpack the
              result and returns it to the client procedure.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Client procedure</emphasis> gets the
              result in the normal way.</para>
            </listitem>
          </orderedlist>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Sun RPC</emphasis></para>

          <para>Sun RPC is the most used implementation of RPCs.</para>

          <para>It has four parts:</para>

          <para>â rpcgen - A compiler that takes the definition of a remote
          procedure interface, and generates the client and server
          stubs.</para>

          <para>â XDR (eXternal Data Representation), a standard way of
          encoding data in a portable fashion between different
          systems.</para>

          <para>â A daemon to bind program numbers and versions to UDP
          ports.</para>

          <para>â A run-time library to handle all the details.</para>

          <para><emphasis role="bold"> ârpcgen</emphasis></para>

          <para>operation:</para>

          <programlisting>      +------------+                                                 +-----------+
      | dateproc.c |-------------------------------------------&gt;cc--&gt;| date_svc  | 
      +------------+                                         /  |    +-----------+
                                                           /    |
                                       server stub       /      |         
                                      +-------------+  /        |
                                      | date_svc.c  |/          |
                                    / +-------------+           |
                                   /                            |
                                  /                         +--------+
      specification RPC          /                          |        |
       +------------+           /     +-------------+       |  RPC   |
       |   date.x   |--&gt; rpcgen -----&gt;|   date.h    |       |run-time|
       +------------+           \     +-------------+       |library |
                                 \                          |        |
                                  \                         +--------+
                                   \                            |
                                    \ +-------------+           |
                                      | date_clnt.c |\          |
                                      +-------------+  \        |
                                       client  stub      \      |
         client                                            \    |      client prg.
       +------------+                                        \  |      +----------+
       |   rdate.c  |------------------------------------------&gt; cc --&gt;|  rdate   |
       +------------+                                                  +----------+</programlisting>

          <para><emphasis role="bold">Example:</emphasis></para>

          <programlisting>program DATE_PROG {
    version DATE_VERS {
        long BIN_DATE(void) = 1;   /* Procedure number 1 */
        string STR_DATE(long) = 2; /* Procedure number 2 */
    } = 1;                         /* Version number 1   */
} = 0x31234567;                    /* Program number 0x31234567 */</programlisting>

          <para>The program numbers are 32-bit integers assigned as
          follows:</para>

          <para><emphasis role="bold">Program number:</emphasis></para>

          <programlisting>0x00000000 - 0x1fffffff  defined by Sun
0x20000000 - 0x3fffffff  defined by users
0x40000000 - 0x5fffffff  transient
0x60000000 - 0xffffffff  reserved</programlisting>

          <para><emphasis role="bold">Note:</emphasis></para>

          <para>Procedure numbers start at 0. Every remote program and version
          must define procedure number 0 as the "null procedure".</para>

          <para>It is automatically generated by the rpcgen compiler to allow
          a client to call it, to verify that a particular program version
          exist.</para>

          <para><emphasis role="bold">âBinding</emphasis></para>

          <para>The portmapper daemon on the remote server is contacted to
          locate a specific program and version:</para>

          <figure>
            <title>RPC Binding</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/Servers13.gif" />
              </imageobject>
            </mediaobject>
          </figure>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Writing a RPC Client and
          Server</emphasis></para>

          <para><emphasis role="bold">The Time Server</emphasis></para>

          <para>The Time server serves the computer's local time to RPC
          requests.</para>

          <para>It has two procedures:</para>

          <itemizedlist>
            <listitem>
              <para>bin_time - Returns the current time as a long int.</para>
            </listitem>

            <listitem>
              <para>str_time - Convert the time from long int to
              string.</para>
            </listitem>
          </itemizedlist>

          <para>rpcgen can generate all the necessary files to compile a RPC
          application. Using the -a flag, rpcgen will generate sample files
          and a makefile for the application.</para>

          <para>The time.xdr file describes the procedures:</para>

          <programlisting>program TIME_PROG {
    version TIME_VERS {
        long BIN_TIME(void) = 1;   /* Procedure number 1 */
        string STR_TIME(long) = 2; /* Procedure number 2 */
    } = 1;                         /* Version number 1   */
} = 0x31234567;                    /* Program number 0x31234567 */</programlisting>

          <para>The following command does the compilation (the -C flag
          generates ANSI C code):</para>

          <programlisting>rpcgen -a -C time.xdr</programlisting>

          <para>rpcgen generates 6 files:</para>

          <orderedlist>
            <listitem>
              <para>time.h - To be included by all files.</para>
            </listitem>

            <listitem>
              <para>time_clnt.c - Stubs for the client.</para>
            </listitem>

            <listitem>
              <para>time_client.c - Sample file for the client.</para>
            </listitem>

            <listitem>
              <para>time_svc.c - Stubs for the server.</para>
            </listitem>

            <listitem>
              <para>time_server.c - Sample file for the server.</para>
            </listitem>

            <listitem>
              <para>makefile.time - Makefile to compile the
              application.</para>
            </listitem>
          </orderedlist>

          <para><emphasis role="bold">â Writing the server
          procedures:</emphasis></para>

          <para><emphasis role="bold">This is the sample generated by
          rpcgen:</emphasis></para>

          <programlisting>long * bin_time_1_svc(void *argp, struct svc_req *rqstp)
{
        static long  result;
        /* insert server code here */
        return (&amp;result);
}

char ** str_time_1_svc(long *argp, struct svc_req *rqstp)
{
        static char * result;
        /* insert server code here*/
        return (&amp;result);
}</programlisting>

          <para><emphasis role="bold">This is the modified
          program:</emphasis></para>

          <programlisting>long * bin_time_1_svc(void *argp, struct svc_req *rqstp)
{
        static long  result;

        <emphasis role="bold">result= time((time_t *) 0);</emphasis>

        return (&amp;result);
}

char ** str_time_1_svc(long *argp, struct svc_req *rqstp)
{
        static char * result;

        <emphasis role="bold">static tstr[128];
        long t;

        t= *argp;
        sec= t % 60;   t /= 60;
        min= t % 60;   t /= 60;
        hour= t % 24;
        sprintf(tstr, "Time %u:%u:%u", hour, min, sec);
        result= tstr;</emphasis>

        return (&amp;result);
}</programlisting>

          <para><emphasis role="bold">âThe Time client</emphasis></para>

          <para><emphasis role="bold">This is the sample from
          rpcgen:</emphasis></para>

          <programlisting>void time_prog_1(char *host)
{
    ...
    clnt = clnt_create(host, TIME_PROG, TIME_VERS, "netpath");
    ...
    result_1 = bin_time_1((void *)&amp;bin_time_1_arg, clnt);
    if (result_1 == (long *) NULL) 
        clnt_perror(clnt, "call failed");
    result_2 = str_time_1(&amp;str_time_1_arg, clnt);
    if (result_2 == (char **) NULL) 
       clnt_perror(clnt, "call failed");
    clnt_destroy(clnt);
}

main(int argc, char *argv[])
{
    time_prog_1(argv[1]);
}</programlisting>

          <para><emphasis role="bold">This is the modified
          program:</emphasis></para>

          <programlisting>void time_prog_1(char *host)
{
    ...
    result_1 = bin_date_1((void *)&amp;bin_date_1_arg, clnt);
    if (result_1 == (long *) NULL) 
        clnt_perror(clnt, "call failed");
    result_2 = str_date_1( <emphasis role="bold">(long *) result_1</emphasis>, clnt);
    if (result_2 == (char **) NULL)
        clnt_perror(clnt, "call failed");
    <emphasis role="bold">printf("Time: %u %s\n", *result_1, *result_2);</emphasis>
}
 ...</programlisting>

          <para><emphasis role="bold">â Running the client:</emphasis></para>

          <programlisting>Time: 862359655 0:20:55</programlisting>
        </listitem>

        <listitem>
          <para><emphasis role="bold">RPC call interface</emphasis></para>

          <para>RPC has multiple levels of interface to its services. These
          levels provide different degrees of control balanced with different
          levels of complexity:</para>

          <itemizedlist>
            <listitem>
              <para>Simplified interface.</para>
            </listitem>

            <listitem>
              <para>Top level.</para>
            </listitem>

            <listitem>
              <para>Intermediate level.</para>
            </listitem>

            <listitem>
              <para>Expert level.</para>
            </listitem>

            <listitem>
              <para>Bottom level.</para>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">Simplified Interface:</emphasis></para>

          <para>The simplified interface (the highest application level) is
          very simple, but limits control of the underlying communications
          mechanisms. It specifies only the type of transport to use.</para>

          <para><emphasis role="bold">Advantages:</emphasis></para>

          <itemizedlist>
            <listitem>
              <para>Simplicity.</para>
            </listitem>

            <listitem>
              <para>Program development can be rapid.</para>
            </listitem>

            <listitem>
              <para>It is directly supported by the rpcgen compiler.</para>
            </listitem>

            <listitem>
              <para>It is sufficient for most applications.</para>
            </listitem>
          </itemizedlist>

          <para>RPC routines:</para>

          <para>rpc_reg(): Registers a procedure as an RPC program on all
          transports.</para>

          <para>rpc_call(): Remote calls the specified procedure on the
          specified remote host.</para>

          <para>rpc_broadcast(): Broadcasts a call message across all
          transports of the specified type.</para>

          <para>svc_run(): RPC library's remote procedure dispatcher.</para>
        </listitem>
      </itemizedlist>
    </section>
  </chapter>

  <chapter id="distributed_applications">
    <title>Distributed Applications</title>

    <section id="distributed_applications_applications">
      <title>Applications</title>

      <section>
        <title>Traditional Client/Server applications</title>

        <section>
          <title>Characteristics</title>

          <itemizedlist>
            <listitem>
              <para>Just one server and many clients.</para>
            </listitem>

            <listitem>
              <para>Fixed addresses servers.</para>
            </listitem>

            <listitem>
              <para>Each kind of server has its own communication
              protocol.</para>
            </listitem>
          </itemizedlist>
        </section>

        <section>
          <title>Examples</title>

          <para>File Servers: NFS</para>

          <para>File Transfer Servers: FTP</para>

          <para>Remote login Servers: Telnet</para>
        </section>
      </section>

      <section>
        <title>New Client/Server applications</title>

        <section>
          <title>Characteristics</title>

          <itemizedlist>
            <listitem>
              <para>Many servers and many clients</para>
            </listitem>

            <listitem>
              <para>Location transparency.</para>
            </listitem>

            <listitem>
              <para>Unified protocols for groups of applications.</para>
            </listitem>

            <listitem>
              <para>Secure access.</para>
            </listitem>

            <listitem>
              <para>Administrative tools</para>
            </listitem>
          </itemizedlist>
        </section>

        <section>
          <title>Examples</title>

          <para>RDB Servers: Sybase</para>

          <para>Groupware: World Wide Web.</para>

          <para>Object Oriented: CORBA.</para>
        </section>
      </section>

      <section>
        <title>The Client/Server Infrastructure</title>

        <section>
          <title>Graphic View</title>

          <figure>
            <title>Client/Server Infrastructure</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/Servers7.gif" />
              </imageobject>
            </mediaobject>
          </figure>
        </section>

        <section>
          <title>Client</title>

          <itemizedlist>
            <listitem>
              <para>GUI - Graphic User Interface</para>
            </listitem>

            <listitem>
              <para>OOUI - Object Oriented User Interface</para>
            </listitem>

            <listitem>
              <para>DSM - Distributed System Management (Client side)</para>
            </listitem>
          </itemizedlist>
        </section>

        <section>
          <title>Middleware</title>

          <itemizedlist>
            <listitem>
              <para>Service Specific</para>

              <para>SQL middleware</para>

              <para>ODBC (Open Database Connectivity)</para>

              <para>ORB (Object Request Broker)</para>
            </listitem>

            <listitem>
              <para>NOS - Network Operating System</para>

              <para>RPC (Remote Procedure Calls)</para>

              <para>Security</para>

              <para>Distributed File System</para>
            </listitem>

            <listitem>
              <para>Transport Stack</para>

              <para>TCP/IP</para>

              <para>NetBIOS</para>

              <para>IPX/SPX</para>
            </listitem>

            <listitem>
              <para>DSM - Distributed System Management (Middleware)</para>
            </listitem>
          </itemizedlist>
        </section>

        <section>
          <title>Server</title>

          <itemizedlist>
            <listitem>
              <para>DBMS</para>
            </listitem>

            <listitem>
              <para>TP (Transaction Processing) Monitors</para>
            </listitem>

            <listitem>
              <para>Groupware</para>
            </listitem>

            <listitem>
              <para>Objects</para>
            </listitem>

            <listitem>
              <para>DSM - Distributed System Management (Server side)</para>
            </listitem>
          </itemizedlist>
        </section>
      </section>

      <section>
        <title>Client/Server Application Models</title>

        <section>
          <title>Requirements</title>

          <itemizedlist>
            <listitem>
              <para>Rich transaction processing</para>

              <itemizedlist>
                <listitem>
                  <para>Nested transactions that can span servers</para>
                </listitem>

                <listitem>
                  <para>Transactions that execute over long periods of
                  time</para>
                </listitem>

                <listitem>
                  <para>Secure transactions.</para>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para>Roaming agents</para>

              <itemizedlist>
                <listitem>
                  <para>Personal and Dealer agents.</para>
                </listitem>

                <listitem>
                  <para>Sniffer agents (to search for information).</para>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para>Rich data management</para>

              <itemizedlist>
                <listitem>
                  <para>Create, store, view and edit compound documents from
                  anywhere on the network.</para>
                </listitem>

                <listitem>
                  <para>Compound document technology (like OLE or
                  OpenDoc).</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist>
        </section>

        <section>
          <title>The models</title>

          <itemizedlist>
            <listitem>
              <para>SQL databases</para>
            </listitem>

            <listitem>
              <para>TP Monitors</para>
            </listitem>

            <listitem>
              <para>Groupware</para>
            </listitem>

            <listitem>
              <para>Distributed Objects</para>
            </listitem>
          </itemizedlist>
        </section>
      </section>
    </section>

    <section id="distributed_applications_sql_databases">
      <title>SQL Databases</title>

      <section>
        <title>SQL</title>

        <section>
          <title>Definition</title>

          <para>Structured Query Language (SQL) is a standardized language for
          defining and manipulating data in a relational database.</para>
        </section>

        <section>
          <title>The relational model of a database</title>

          <itemizedlist>
            <listitem>
              <para>Set of tables</para>
            </listitem>

            <listitem>
              <para>Relationships are represented by values in tables.</para>
            </listitem>

            <listitem>
              <para>Data is retrieved by specifying a result table that can be
              derived from one or more tables.</para>
            </listitem>
          </itemizedlist>
        </section>
      </section>

      <section>
        <title>Stored Procedures</title>

        <section>
          <title>Definition</title>

          <para>A stored procedure is a named collection of SQL statements and
          procedure logic that is compiled, verified, and stored in a server
          database.</para>
        </section>

        <section>
          <title>Applications</title>

          <itemizedlist>
            <listitem>
              <para>Enforce data integrity</para>
            </listitem>

            <listitem>
              <para>Perform system maintenance</para>
            </listitem>

            <listitem>
              <para>Implement the server side of an application's
              logic.</para>
            </listitem>
          </itemizedlist>
        </section>
      </section>

      <section>
        <title>Main points</title>

        <section>
          <title>Good points</title>

          <itemizedlist>
            <listitem>
              <para>SQL dominates the client/server market today.</para>
            </listitem>

            <listitem>
              <para>It is easy to create applications in
              single-vendor/single-server environments.</para>
            </listitem>

            <listitem>
              <para>There is a wealth GUI tools to create SQL
              applications.</para>
            </listitem>

            <listitem>
              <para>SQL is familiar to millions of programmers and
              users.</para>
            </listitem>
          </itemizedlist>
        </section>

        <section>
          <title>Bad Points</title>

          <itemizedlist>
            <listitem>
              <para>SQL standards lag vendor implementations.</para>
            </listitem>

            <listitem>
              <para>Incompatible vendors implementations.</para>
            </listitem>

            <listitem>
              <para>Difficult in mount heterogeneous database
              environments.</para>
            </listitem>
          </itemizedlist>
        </section>
      </section>
    </section>

    <section id="distributed_applications_tp_monitors">
      <title>TP Monitors</title>

      <section>
        <title>Transaction Processing Monitors</title>

        <section>
          <title>Definition</title>

          <para>TP monitors manage processes and coordinate programs by
          breaking complex applications into pieces of code called
          transactions.</para>
        </section>

        <section>
          <title>Monitoring</title>

          <para>A transaction can be managed from its point of origin across
          one or more servers and back to the originating client.</para>
        </section>

        <section>
          <title>Transaction model defines</title>

          <itemizedlist>
            <listitem>
              <para>Transaction's start.</para>
            </listitem>

            <listitem>
              <para>Transaction's end.</para>
            </listitem>

            <listitem>
              <para>Appropriate units of recovery (in case of failure).</para>
            </listitem>
          </itemizedlist>
        </section>
      </section>

      <section>
        <title>Large systems</title>

        <section>
          <title>TPs in systems with large number of clients</title>

          <itemizedlist>
            <listitem>
              <para>Manage Transactions.</para>
            </listitem>

            <listitem>
              <para>Route Transactions across systems.</para>
            </listitem>

            <listitem>
              <para>load-balance execution</para>
            </listitem>

            <listitem>
              <para>Restart then after failure.</para>
            </listitem>
          </itemizedlist>
        </section>
      </section>

      <section>
        <title>Nested Transactions</title>

        <figure>
          <title>Nested Transactions</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="img/Servers8.gif" />
            </imageobject>
          </mediaobject>
        </figure>

        <section>
          <title>Main points</title>

          <para>Good points:</para>

          <itemizedlist>
            <listitem>
              <para>TP monitors help the operating system and servers to deal
              with large numbers of clients.</para>
            </listitem>

            <listitem>
              <para>TP monitors can cooperate with other TP monitors in
              federated arrangements.</para>
            </listitem>

            <listitem>
              <para>TP monitors can manage process failures across
              systems.</para>
            </listitem>
          </itemizedlist>

          <para>Bad points:</para>

          <itemizedlist>
            <listitem>
              <para>TP monitors are overkill in single-server, single-vendor
              applications.</para>
            </listitem>

            <listitem>
              <para>TP monitors add unnecessary complexity in small
              systems.</para>
            </listitem>
          </itemizedlist>
        </section>
      </section>

      <section id="distributed_applications_groupware">
        <title>Groupware</title>

        <bridgehead>Definition:</bridgehead>

        <para>Technologies to support collaborative work and information
        dissemination.</para>

        <bridgehead>Foundation technologies:</bridgehead>

        <itemizedlist spacing="compact">
          <listitem>
            <para>Multimedia documents</para>
          </listitem>

          <listitem>
            <para>Word Wide Web</para>
          </listitem>

          <listitem>
            <para>E-mail</para>
          </listitem>

          <listitem>
            <para>Conferencing</para>
          </listitem>

          <listitem>
            <para>Lotus Notes</para>
          </listitem>
        </itemizedlist>

        <bridgehead>Work flow model:</bridgehead>

        <para>Data passes from one program to the next in client/server
        environment, simulating real-world collaborative activity.</para>

        <bridgehead>Goals:</bridgehead>

        <itemizedlist spacing="compact">
          <listitem>
            <para>To bring the information to the people and programs who can
            act on it.</para>
          </listitem>

          <listitem>
            <para>To coordinate existing software processes.</para>
          </listitem>

          <listitem>
            <para>To track processes to make sure the work gets done.</para>
          </listitem>
        </itemizedlist>

        <bridgehead>Example Lotus-Notes:</bridgehead>

        <itemizedlist spacing="compact">
          <listitem>
            <para>A reliable, scaleable and secure distributed document
            database. The database-centric model gives users the ability to
            assemble, share, and manage the rich variety of documents vital to
            conducting business.</para>
          </listitem>

          <listitem>
            <para>An integrated messaging system. Groupware users must be able
            to take advantage of a messaging infrastructure to send and
            receive electronic mail and move documents through a workflow
            process.</para>
          </listitem>

          <listitem>
            <para>A rich application development environment. Developers must
            be able to rapidly build portable and scaleable strategic
            applications which span document-oriented and structured database
            information</para>
          </listitem>
        </itemizedlist>
      </section>

      <section id="distributed_applications_distributed_objects">
        <title>Distributed Objects</title>

        <bridgehead>Definition:</bridgehead>

        <para>Distributed objects are the middleware that establishes
        client-server relationships between objects. A client can
        transparently invoke a method on a server object, which can be on the
        same machine or across a network.</para>

        <section>
          <title>ORB - Object Request Broker</title>

          <bridgehead>Function:</bridgehead>

          <para>The ORB intercepts requests to objects, finds an object that
          can implement this request, passes it the parameters, invokes its
          method, and returns the results of the request.</para>

          <bridgehead>Advantages:</bridgehead>

          <itemizedlist>
            <listitem>
              <para>The client does not have to be aware of where the object
              is located, its programming language, its operating system, or
              any other system aspects that are not part of an object's
              interface.</para>
            </listitem>

            <listitem>
              <para>The ORB provides interoperability between applications on
              different machines in heterogeneous distributed environments and
              seamlessly interconnects multiple object systems</para>
            </listitem>
          </itemizedlist>

          <bridgehead>Request sent through a ORB:</bridgehead>

          <figure>
            <title>ORB Request</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/Servers9.gif" />
              </imageobject>
            </mediaobject>
          </figure>
        </section>

        <section>
          <title>CORBA</title>

          <bridgehead>Definition:</bridgehead>

          <para>The Common Object Request Broker Architecture (CORBA) is a
          standard ORB architecture defined by the Object Management Group (An
          international consortium to develop ORB technology).</para>
        </section>

        <section>
          <title>ORG Interfaces</title>

          <bridgehead>Structure of ORB Interfaces:</bridgehead>

          <figure>
            <title>CORBA Interface</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/Servers10.gif" />
              </imageobject>
            </mediaobject>
          </figure>

          <bridgehead>The client side:</bridgehead>

          <para>OMG IDL stub</para>

          <blockquote>
            <para>Stubs generated from an IDL specification depending on the
            interface of the target object. They make calls on the rest of the
            ORB .</para>
          </blockquote>

          <para>Dynamic Invocation interface</para>

          <blockquote>
            <para>Interface independent of the target object's interface. It
            allows the dynamic construction of object invocations.</para>
          </blockquote>

          <para>ORB Interface</para>

          <blockquote>
            <para>The interface that goes directly to the ORB which is the
            same for all ORBs and does not depend on the object's interface or
            object adapter.</para>
          </blockquote>

          <bridgehead>The server side (or the Object
          Implementation):</bridgehead>

          <para>IDL Generated Skeleton</para>

          <blockquote>
            <para>A skeleton generated from an IDL specification that is
            specific to a particular language mapping.</para>
          </blockquote>

          <para>Dynamic Skeleton Interface</para>

          <blockquote>
            <para>A skeleton interface is available which allows dynamic
            handling of object invocations analogous to the client side's
            Dynamic Invocation Interface.</para>
          </blockquote>

          <para>Object Adapters</para>

          <blockquote>
            <para>Adapters are the primary means for an object implementation
            to access ORB services such as object reference generation.</para>
          </blockquote>

          <para>ORB Interface</para>

          <blockquote>
            <para>Same as the client's implementation to access ORB services
            such as object reference generation.</para>
          </blockquote>

          <bridgehead>The Interface Definition Language (OMG IDL)</bridgehead>

          <blockquote>
            <para>IDL defines the types of objects by specifying their
            interfaces. An interface consists of a set of named operations and
            the parameters to those operations.</para>
          </blockquote>

          <bridgehead>Interoperation with other object systems:</bridgehead>

          <figure>
            <title>ORB Interoperation</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/Servers11.gif" />
              </imageobject>
            </mediaobject>
          </figure>

          <para>The interoperation between system is handed by the ORB of each
          system.</para>
        </section>
      </section>
    </section>
  </chapter>

  <chapter id="nos_network_operating_systems">
    <title>Network Operating Systems</title>

    <section id="nos_network_operating_systems_introduction">
      <title>Introduction</title>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Introduction</emphasis></para>

          <para><emphasis role="bold">Definition:</emphasis></para>

          <para>Distributed computer systems contain software programs and
          data resources dispersed across different computers. To operate as a
          system, there should be certain system-wide standards for
          interoperability.</para>

          <para>This set of standards composes a <emphasis role="bold">Network
          Operating System</emphasis>.</para>

          <para><emphasis role="bold">Characteristics:</emphasis></para>

          <itemizedlist>
            <listitem>
              <para>It does not depend upon a particular Operational
              System.</para>
            </listitem>

            <listitem>
              <para>It is used in low coupled parallel machines, like the
              computers in a local network.</para>
            </listitem>

            <listitem>
              <para>It establishes the interoperability rules between
              applications, but not the implementation of such
              applications.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Collection of services</emphasis></para>

          <para>A Network Operating System is composed by a collection of well
          established services. They usually were created independently and
          bundled together to form a system.</para>

          <para>NOS services are targeted to a specific network. For the
          Internet there are:</para>

          <itemizedlist>
            <listitem>
              <para>DNS - Domain Name Server.</para>
            </listitem>

            <listitem>
              <para>NFS - Network File System.</para>
            </listitem>

            <listitem>
              <para>RSH - Remote Shell.</para>
            </listitem>

            <listitem>
              <para>RLOGIN - Remote login.</para>
            </listitem>

            <listitem>
              <para>FTP - File Transfer Protocol.</para>
            </listitem>
          </itemizedlist>

          <para>There can be other services, but those are common ones.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Is there a real NOS?</emphasis></para>

          <para>You can not find a NOS in a box from a vendor. Usually the
          services of a NOS are sold as applications or bundled with the
          machine OS. Why?</para>

          <para>Maybe just Operational System isn't the best paradigm to
          describe network services, as it is machine rather network
          centred.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="nos_network_operating_systems_dns_domain_name_server">
      <title>DNS - Domain Name Server</title>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Hostname Resolution</emphasis></para>

          <para>Hosts are generally known by "ordinary" names such as gauss or
          strange.</para>

          <para>It is the application's duty to find the IP-address
          corresponding to this name. This process is called host name
          resolution.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">DNS</emphasis></para>

          <para>DNS organizes host names in a hierarchy of domains.</para>

          <para><emphasis role="bold">Domain:</emphasis></para>

          <para>Domain is a collection of sites that are related in some
          sense:</para>

          <itemizedlist>
            <listitem>
              <para>Because they form a proper network (e.g. all machines on a
              campus).</para>
            </listitem>

            <listitem>
              <para>Because they all belong to a certain organization (like
              the U.S. government).</para>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">FQDN:</emphasis></para>

          <para>A fully qualified domain name, or FQDN, uniquely identifies a
          host world-wide:</para>

          <figure>
            <title>Section of The Name Space</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/Nos1.gif" />
              </imageobject>
            </mediaobject>
          </figure>

          <para><emphasis role="bold">Top-level domains:</emphasis></para>

          <para>These are a couple of top-level domains you may see
          frequently:</para>

          <para><emphasis role="bold">edu</emphasis> (Mostly US) educational
          institutions like universities, etc.</para>

          <para><emphasis role="bold">com</emphasis> Commercial organizations,
          companies.</para>

          <para><emphasis role="bold">org</emphasis> Non-commercial
          organizations.</para>

          <para><emphasis role="bold">net</emphasis> Gateways and other
          administrative host on a network.</para>

          <para><emphasis role="bold">mil</emphasis> US military
          institutions.</para>

          <para><emphasis role="bold">gov</emphasis> US government
          institutions.</para>

          <para>Outside the US, each country generally uses a top-level domain
          of its own named after the two-letter country code defined in
          ISO-3166.</para>

          <para><emphasis role="bold">Note:</emphasis></para>

          <para>National domains do not imply that a host below that domain is
          actually located in that country; it only signals that the host has
          been registered with that country's NIC.</para>

          <para><emphasis role="bold">Advantages:</emphasis></para>

          <itemizedlist>
            <listitem>
              <para>It solves the problem of name uniqueness; with DNS, a host
              name has to be unique only within its domain to give it a name
              different from all other hosts world-wide.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Name Lookups with DNS </emphasis></para>

          <para><emphasis role="bold">An DNS query:</emphasis></para>

          <orderedlist>
            <listitem>
              <para>When an application wants to look up information on
              erdos.maths.groucho.edu, it contacts a local DNS.</para>
            </listitem>
          </orderedlist>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Types of DNSs:</emphasis></para>

          <para><emphasis role="bold">Authoritative Servers:</emphasis></para>

          <para>Name servers that hold all information on hosts within a zone
          are called authoritative for this zone. There are at least
          two:</para>

          <orderedlist>
            <listitem>
              <para>One <emphasis role="bold">primary</emphasis> server, that
              loads its zone information from data files.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Secondary</emphasis> servers, that
              transfer the zone data from the primary server at regular
              intervals.</para>
            </listitem>
          </orderedlist>

          <para><emphasis role="bold">Caching-only Servers:</emphasis></para>

          <para>A name server that is not authoritative for any domain. This
          type of server conducts DNS queries for applications and caches the
          information.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">The DNS Database</emphasis></para>

          <para><emphasis role="bold">Resource Record:</emphasis></para>

          <para>A single piece of information from the DNS database is called
          a resource record, or RR.</para>

          <para><emphasis role="bold">Each record has:</emphasis></para>

          <itemizedlist>
            <listitem>
              <para>A class specifying the type of network it applies
              to:</para>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">Database file:</emphasis></para>

          <programlisting>... 
            ; Name servers
                                  IN    NS       neils
                                  IN    NS       gauss.groucho.edu.
            gauss.groucho.edu.    IN    A        149.76.4.23

            ;
            ; Theoretical Physics (subnet 12)
            niels                 IN    A        149.76.12.1
                                  IN    A        149.76.1.12
            nameserver            IN    CNAME    niels
            otto                  IN    A        149.76.12.2
            quark                 IN    A        149.76.12.4
            strange               IN    A        149.76.12.6
            ...
            ; Collider Lab. (subnet 14)
            boson                 IN    A        149.76.14.1
            muon                  IN    A        149.76.14.7
            bogon                 IN    A        149.76.14.12
            ...</programlisting>
        </listitem>
      </itemizedlist>
    </section>

    <section id="nos_network_operating_systems_nfs_network_file_system">
      <title>NFS - Network File System</title>

      <itemizedlist>
        <listitem>
          <para>The Network File System</para>

          <para>NFS allows to access files on remote hosts in exactly the same
          way as a user would access any local files.</para>

          <para><emphasis role="bold">Advantages:</emphasis></para>

          <itemizedlist>
            <listitem>
              <para>Data accessed by all users can be kept on a central host,
              with clients mounting this directory at boot time.</para>
            </listitem>

            <listitem>
              <para>Data consuming large amounts of disk space may be kept on
              a single host.</para>
            </listitem>

            <listitem>
              <para>Administrative data may be kept on a single host.</para>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">Architecture:</emphasis></para>

          <itemizedlist>
            <listitem>
              <para>A collection of clients and servers can share a file
              system.</para>
            </listitem>

            <listitem>
              <para>A machine can be at the same time a NFS client and a NFS
              server.</para>
            </listitem>

            <listitem>
              <para>A server makes a directory available to clients by
              exporting it.</para>
            </listitem>

            <listitem>
              <para>Clients can access remote file system by mounting then
              through a NFS.</para>
            </listitem>

            <listitem>
              <para>A diskless client can mount a remote file system as its
              root directory, making a completely remote file system.</para>
            </listitem>

            <listitem>
              <para>NFS was invented by Sun Microsystems and adopted by all
              other Unix vendors.</para>
            </listitem>

            <listitem>
              <para>NFS is the most important networking service using
              RPCs.</para>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">Mounting directories:</emphasis></para>

          <para>A client can mount the directories and files from the file
          server anywhere in its file system, and use then in the same way as
          local files.</para>

          <programlisting>mount -t nfs oca:/games /games</programlisting>
        </listitem>

        <listitem>
          <para><emphasis role="bold">File Sharing</emphasis></para>

          <para>Two or more clients can mount and share the same files from
          the file server. They can even mount then in different
          places:</para>

          <figure>
            <title>File Sharing</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/Nos2.gif" />
              </imageobject>
            </mediaobject>
          </figure>

          <para>Client 1:</para>

          <programlisting>mount -t nfs oca:/games /games
mount -t nfs oca:/work /work</programlisting>

          <para>Client 2:</para>

          <programlisting>mount -t nfs oca:/games /games
mount -t nfs oca:/work /games/work</programlisting>

          <figure>
            <title>Mount Example</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/Nos3.gif" />
              </imageobject>
            </mediaobject>
          </figure>
        </listitem>

        <listitem>
          <para><emphasis role="bold">NFS Daemons</emphasis></para>

          <para>To provide NFS service to other hosts, you have to run the
          RPC-based daemons:</para>

          <itemizedlist>
            <listitem>
              <para>nfsd - Provide the file services.</para>
            </listitem>

            <listitem>
              <para>mountd - Provides the mounting services.</para>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">NFS Protocols:</emphasis></para>

          <para>NFS uses two protocols:</para>

          <itemizedlist>
            <listitem>
              <para>For mounting (using mountd).</para>
            </listitem>

            <listitem>
              <para>For accessing directories and files (using nfsd).</para>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">Mounting directories:</emphasis></para>

          <orderedlist>
            <listitem>
              <para>A client may request to mount a directory from a remote
              host on a local directory just the same way it can mount a
              physical device:</para>

              <programlisting>mount -t nfs oca:/home/tcl /users</programlisting>
            </listitem>

            <listitem>
              <para>mount will then try to connect to the mountd mount daemon
              on oca via RPC.</para>
            </listitem>

            <listitem>
              <para>The server will check if vale is permitted to mount the
              directory in question, and if so, return it a file
              handle.</para>
            </listitem>

            <listitem>
              <para>This file handle will be used in all subsequent requests
              to files below /users.</para>

              <para>The file handle holds:</para>

              <orderedlist>
                <listitem>
                  <para>The file system type.</para>
                </listitem>

                <listitem>
                  <para>The directory disk.</para>
                </listitem>

                <listitem>
                  <para>The directory i-node.</para>
                </listitem>

                <listitem>
                  <para>Security information.</para>
                </listitem>
              </orderedlist>

              <para>Directories are generally mounted during boot time using
              the /etc/rc script.</para>
            </listitem>
          </orderedlist>

          <para><emphasis role="bold">Accessing files and
          directories</emphasis></para>

          <para>When a file is accessed over NFS, the kernel places an RPC
          call to nfsd daemon on the server machine.</para>

          <para><emphasis role="bold">Commands to change directory
          entries:</emphasis></para>

          <itemizedlist>
            <listitem>
              <para>read.</para>
            </listitem>

            <listitem>
              <para>write.</para>
            </listitem>

            <listitem>
              <para>access attributes:</para>

              <itemizedlist>
                <listitem>
                  <para>mode</para>
                </listitem>

                <listitem>
                  <para>size</para>
                </listitem>

                <listitem>
                  <para>time of last modification</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">Commands to change
          files:</emphasis></para>

          <itemizedlist>
            <listitem>
              <para>lookup</para>

              <para>Client sends file name and gets file handle.</para>
            </listitem>

            <listitem>
              <para>read</para>

              <para>To get the data, the client sends:</para>

              <itemizedlist>
                <listitem>
                  <para>File handle.</para>
                </listitem>

                <listitem>
                  <para>Offset to read point.</para>
                </listitem>

                <listitem>
                  <para>Number of bytes.</para>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para>write</para>

              <para>Similar to read.</para>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">Note:</emphasis></para>

          <para>The NFS servers don't keep any information about the status of
          client operations. When a RPC call finishes all the information
          about its status disappears. For this reason the server does not
          open or closes files, it just read or write peaces of them. NFS
          servers are <emphasis role="bold">stateless</emphasis>.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Virtual File System</emphasis></para>

          <para>The virtual file system (VFS) layer of the OS keeps the
          information, at the client's side, about the NFS operations.</para>

          <para><emphasis role="bold">Mount operation:</emphasis></para>

          <orderedlist>
            <listitem>
              <para>The mount programs receives the remote directory (host
              name + path) and local directories.</para>
            </listitem>

            <listitem>
              <para>It finds the correct machine.</para>
            </listitem>

            <listitem>
              <para>It gets from the NFS servers a file handle for the
              directory.</para>
            </listitem>

            <listitem>
              <para>It does a mount system call.</para>
            </listitem>

            <listitem>
              <para>The kernel makes a v-node for the remote directory.</para>
            </listitem>

            <listitem>
              <para>The NFS client makes a r-node to save the file handle (the
              v-node points to the r-node).</para>
            </listitem>
          </orderedlist>

          <para><emphasis role="bold">File operation:</emphasis></para>

          <orderedlist>
            <listitem>
              <para>The kernel finds the r-node (through the v-node).</para>
            </listitem>

            <listitem>
              <para>It asks the NFS client to open the file.</para>
            </listitem>

            <listitem>
              <para>The NFS client gets the file handle for the remote
              directory.</para>
            </listitem>

            <listitem>
              <para>It asks the NFS server for a file handle to the file and
              makes a r-node for it.</para>
            </listitem>

            <listitem>
              <para>It sends the r-node to the VFS.</para>
            </listitem>

            <listitem>
              <para>The VFS makes a v-node for the r-node.</para>
            </listitem>

            <listitem>
              <para>The program that asked to open the file receives a file
              descriptor (fd) for the remote file. This fd points to the
              v-node.</para>
            </listitem>
          </orderedlist>

          <para>When the fd is used in a system call (read(), for instance),
          the VFS finds the v-node and finds out if the file is local (it uses
          a i-node) or is remote (it uses a r-node).</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="nos_network_operating_systems_nis-network_information_system">
      <title>NIS - Network Information System</title>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Network Information
          System</emphasis></para>

          <para><emphasis role="bold">Definition:</emphasis></para>

          <para>NIS provides generic database access facilities that can be
          used to distribute information such as that contained in the passwd
          and groups files to all hosts on your network.</para>

          <para><emphasis role="bold">Objectives:</emphasis></para>

          <itemizedlist>
            <listitem>
              <para>To make the network appear just as a single system, with
              the same accounts on all hosts.</para>
            </listitem>

            <listitem>
              <para>To provide an environment to your users that makes the
              network transparent.</para>
            </listitem>

            <listitem>
              <para>To keep vital data such as user account information
              synchronized between all hosts.</para>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">NIS comprises:</emphasis></para>

          <itemizedlist>
            <listitem>
              <para>A RPC server.</para>
            </listitem>

            <listitem>
              <para>A client-side library.</para>
            </listitem>

            <listitem>
              <para>Several administrative tools.</para>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">Note:</emphasis></para>

          <para>Originally, NIS was called Yellow Pages, or YP, which is still
          widely used to informally refer this service. Yellow Pages is a
          trademark of British Telecom, which required Sun to drop that
          name.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Maps</emphasis></para>

          <para>NIS keeps database information is in so-called maps containing
          key-value pairs.</para>

          <para>Maps are stored on a central host running the NIS server, from
          which clients may retrieve the information through various RPC
          calls.</para>

          <para><emphasis role="bold">Creation:</emphasis></para>

          <para>The maps are usually generated from master text files such as
          /etc/hosts or /etc/passwd.</para>

          <para>For some files, several maps are created, one for each search
          key type:</para>

          <programlisting><emphasis role="bold">Master File</emphasis>                                      <emphasis
              role="bold">Maps </emphasis>
/etc/hosts                                       <emphasis>hosts.byname, hosts.byaddr</emphasis> 
/etc/networks                                    <emphasis>networks.byname, netwosks.byaddr </emphasis>
/etc/passwd                                      <emphasis>passwd.byname, passwd.byuid</emphasis> 
/etc/group                                       <emphasis>group.byname, group.bygid</emphasis> 
/etc/services                                    <emphasis>services.byname, services.bynumber</emphasis> 
/etc/rpc                                         <emphasis>rpc.byname, rpc.bynumber</emphasis> 
/etc/protocols                                   <emphasis>protocols.byname, protocols.bynumber</emphasis> 
/usr/lib/aliases                                 <emphasis>mail.aliases</emphasis></programlisting>

          <para><emphasis role="bold">ypcat:</emphasis></para>

          <para>The command ypcat lists the maps in the same way the command
          cat would list the master files:</para>

          <programlisting>% ypcat passwd</programlisting>
        </listitem>

        <listitem>
          <para><emphasis role="bold">NIS servers</emphasis></para>

          <para>The NIS server is traditionally called ypserv.</para>

          <para><emphasis role="bold">Types:</emphasis></para>

          <itemizedlist>
            <listitem>
              <para><emphasis role="bold">For an average network</emphasis>: a
              single server usually suffices.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">For big networks</emphasis>: Many
              servers synchronized servers in a master-slave scheme:</para>

              <itemizedlist>
                <listitem>
                  <para>Maps will be created only on the master server's
                  host.</para>
                </listitem>

                <listitem>
                  <para>From there, they are distributed to all slaves.</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para><emphasis role="bold">NIS domains</emphasis></para>

          <para><emphasis role="bold">Definition:</emphasis></para>

          <para>NIS domains are the collection of all hosts that share part of
          their system configuration data through NIS.</para>

          <para><emphasis role="bold">Characteristics:</emphasis></para>

          <itemizedlist>
            <listitem>
              <para>NIS domains have a purely administrative function
              only.</para>
            </listitem>

            <listitem>
              <para>They are mostly invisible to users, except for the sharing
              of passwords between all machines in the domain.</para>
            </listitem>

            <listitem>
              <para>The name given to a NIS domain is relevant only to the
              administrators.</para>
            </listitem>

            <listitem>
              <para>NIS domains determine which NIS server an application will
              query.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Finding a NIS server:</emphasis></para>

          <para><emphasis role="bold">Configuration file:</emphasis></para>

          <para>A file that names the host on which to find the server.</para>

          <para><emphasis role="bold">Disadvantage:</emphasis> This approach
          is inflexible, because it doesn't allow clients to use different
          servers, depending on their availability.</para>

          <para><emphasis role="bold">ybbind:</emphasis></para>

          <para>ypbind probes for servers by broadcasting to the local
          IP-network; the first to respond is assumed to be the potentially
          fastest one and will be used in all subsequent NIS queries.</para>

          <para><emphasis role="bold">Disadvantage</emphasis>: ypbind blindly
          believes whoever answers, which could be a humble NIS server as well
          as a malicious intruder.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">The Client Side of NIS
          </emphasis></para>

          <para><emphasis role="bold">Without NIS:</emphasis></para>

          <para>Functions like:</para>

          <itemizedlist>
            <listitem>
              <para>getpwnam(3), which return the account information
              associated with the given user name.</para>
            </listitem>

            <listitem>
              <para>getpwuid(3), which return the account information
              associated with the given user id.</para>
            </listitem>
          </itemizedlist>

          <para>Perform the requested lookup on the standard file, such as
          /etc/passwd.</para>

          <para><emphasis role="bold">With NIS:</emphasis></para>

          <para>There is a NIS-aware implementation of these functions in the
          C-library.</para>

          <para>They place RPC calls to have the NIS server look up the user
          name or id.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="nos_network_operating_systems_email">
      <title>Electronic Mail</title>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Electronic Mail</emphasis></para>

          <para>One of the most prominent uses of networking since the first
          networks were devised, has been electronic mail.</para>

          <para>It started as a simple service that copied a file from one
          machine to another, and appended it to the recipient's mailbox
          file.</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Mail Message</emphasis></para>

          <para><emphasis role="bold">A Mail message consists
          of:</emphasis></para>

          <itemizedlist>
            <listitem>
              <para>message body, which is the text the sender wrote.</para>
            </listitem>

            <listitem>
              <para>special data specifying recipients, transport medium,
              etc...</para>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">This special data falls into two
          categories:</emphasis></para>

          <itemizedlist>
            <listitem>
              <para>Any data that is specific to the transport medium, like
              the address of sender and recipient.</para>

              <itemizedlist>
                <listitem>
                  <para>It is therefore called the envelope.</para>
                </listitem>

                <listitem>
                  <para>It may be transformed by the transport software as the
                  message is passed along.</para>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para>Any data necessary for handling the mail message, which is
              not particular to any transport mechanism, such as the message's
              subject line, a list of all recipients.</para>

              <itemizedlist>
                <listitem>
                  <para>It has become standard to prepend this data to the
                  mail message, forming the so-called mail header. It is
                  offset from the mail body by an empty line.</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">Standards:</emphasis></para>

          <itemizedlist>
            <listitem>
              <para>RFC-822 - Standard used by sites on the Internet.</para>
            </listitem>

            <listitem>
              <para>MIME - New standard for multi-media mail, it deals with
              including pictures and sound in mail messages.</para>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">Common header fields:</emphasis></para>

          <para><emphasis role="bold">From</emphasis>: This contains the
          sender's email address.</para>

          <para><emphasis role="bold">To</emphasis>: This is the recipient's
          email address.</para>

          <para><emphasis role="bold">Subject</emphasis>: Describes the
          content of the mail in a few words.</para>

          <para><emphasis role="bold">Date</emphasis>: The date the mail was
          sent.</para>

          <para><emphasis role="bold">Reply-To</emphasis>: Specifies the
          address the sender wants the recipient's reply directed to.</para>

          <para><emphasis role="bold">Organization</emphasis>: The
          organization that owns the machine from which the mail
          originates.</para>

          <para><emphasis role="bold">Message-ID</emphasis>: A string
          generated by mail transport on the originating system. It is unique
          to this message.</para>

          <para><emphasis role="bold">Received</emphasis>: Every site that
          processes your mail inserts such a field into the header, giving its
          site name, a message id, time and date it received the message,
          which site it is from, and which transport software was used. This
          is so that you can trace which route the message took.</para>

          <para><emphasis role="bold">X-anything</emphasis>: No mail-related
          programs should complain about any header which starts with X. It is
          used to implement additional features that have not yet made it into
          an RFC, or never will.</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Mail Delivering</emphasis></para>

          <para><emphasis role="bold">MUA - Mail User
          Agents:</emphasis></para>

          <para>Mailer interface like elm, pine, Netscape Mail, that can
          compose mail messages.</para>

          <para><emphasis role="bold">MTA - Mail Transport
          Agents:</emphasis></para>

          <para>The program that the MUA hands the e-mail for delivery, like
          sendmail, smail.</para>

          <para><emphasis role="bold">Kinds of delivery:</emphasis></para>

          <itemizedlist>
            <listitem>
              <para><emphasis role="bold">Local:</emphasis></para>

              <para>The local MTA will process the mail and append it to the
              incoming message to the recipient's mailbox.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Remote by
              Internet:</emphasis></para>

              <para>The mail is delivered over a network using TCP/IP, SMTP is
              commonly used:</para>

              <itemizedlist>
                <listitem>
                  <para>SMTP stands for Simple Mail Transfer Protocol, and is
                  defined in RFC-788 and RFC-821.</para>
                </listitem>

                <listitem>
                  <para>SMTP usually connects to the recipient's machine
                  directly, negotiating the message transfer with the remote
                  side's SMTP daemon.</para>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Remote by UUCP:</emphasis></para>

              <para>In UUCP networks, mail will usually not be delivered
              directly, but rather be forwarded to the destination host by a
              number of intermediate systems.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Email Addresses</emphasis></para>

          <para>For electronic mail, an address is made up:</para>

          <itemizedlist>
            <listitem>
              <para>the name of a machine handling the person's mail,</para>
            </listitem>

            <listitem>
              <para>and a user identification recognized by this
              system.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Mail Routing on the
          Internet</emphasis></para>

          <para>The default is to deliver the message to the destination host
          directly by looking up its IP address, and leave the actual routing
          of the data to the IP transport layer.</para>

          <para><emphasis role="bold">Mail Exchanger:</emphasis></para>

          <para>Most sites will usually direct all in-bound mail to a highly
          available mail server that can act as a mail forwarder for all
          machines in this domain.</para>

          <para>Mail Exchangers may also be used to handle traffic for hosts
          that are not connected to the Internet themselves, like UUCP
          networks, or company networks with hosts carrying confidential
          information.</para>

          <para><emphasis role="bold">Example:</emphasis></para>

          <para>An organization, say Foobar Inc., want all their mail handled
          by their machine called mailhub. They will then have an MX (Mail
          Exchanger) record like this in the DNS database:</para>

          <programlisting>foobar.com IN MX 5 mailhub.foobar.com</programlisting>

          <para>This announces mailhub.foobar.com as a mail exchanger for
          foobar.com . A host that wishes to deliver a message to
          joe@greenhouse.foobar.com will check DNS for foobar.com, and finds
          the MX record pointing at mailhub. The message will be delivered to
          mailhub, which then dispatches it to greenhouse.</para>
        </listitem>
      </itemizedlist>
    </section>
  </chapter>

  <chapter id="parallel_machines">
    <title>Parallel Machines</title>

    <section id="parallel_machines_introduction">
      <title>Introduction</title>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Introduction</emphasis></para>

          <para><emphasis role="bold">Definition:</emphasis></para>

          <para>Parallel machines are computers that can execute more than one
          program instruction at the same time.</para>

          <para><emphasis role="bold">Types of parallel
          hardware:</emphasis></para>

          <itemizedlist>
            <listitem>
              <para><emphasis role="bold">SISD</emphasis> <emphasis
              role="bold">S</emphasis>ingle <emphasis
              role="bold">I</emphasis>nstruction <emphasis
              role="bold">S</emphasis>ingle <emphasis
              role="bold">D</emphasis>ata
              <emphasis>(mainframes)</emphasis></para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">SIMD </emphasis><emphasis
              role="bold">S</emphasis>ingle <emphasis
              role="bold">I</emphasis>nstruction <emphasis
              role="bold">M</emphasis>ultiple <emphasis
              role="bold">D</emphasis>ata <emphasis>(array
              processors)</emphasis></para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">MISD</emphasis> <emphasis
              role="bold">M</emphasis>ultiple <emphasis
              role="bold">I</emphasis>nstruction <emphasis
              role="bold">S</emphasis>ingle <emphasis
              role="bold">D</emphasis>ata <emphasis>(none)</emphasis></para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">MIMD</emphasis> <emphasis
              role="bold">M</emphasis>ultiple <emphasis
              role="bold">I</emphasis>nstruction <emphasis
              role="bold">M</emphasis>ultiple <emphasis
              role="bold">D</emphasis>ata <emphasis>(transputers)
              </emphasis></para>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">MIMD</emphasis>: It is the most used
          parallel system.</para>

          <figure>
            <title>MIMD</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/Parallel1.gif" />
              </imageobject>
            </mediaobject>
          </figure>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Tightly Coupled
          Systems</emphasis></para>

          <para>CPUs share the same memory.</para>

          <itemizedlist>
            <listitem>
              <para>High bandwidth.</para>
            </listitem>

            <listitem>
              <para>Close integration.</para>
            </listitem>

            <listitem>
              <para>Used in main stream market (Intel, Sparcs, Power PC,
              etc).</para>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">Bus systems:</emphasis></para>

          <figure>
            <title>Bus System</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/Parallel2.gif" />
              </imageobject>
            </mediaobject>
          </figure>

          <para>The CPUs are connected to the shared memory through a
          bus.</para>

          <para><emphasis role="bold">Advantages:</emphasis></para>

          <itemizedlist>
            <listitem>
              <para>Most used configuration (off the shelf chips).</para>
            </listitem>

            <listitem>
              <para>Low cost.</para>
            </listitem>

            <listitem>
              <para>Simpler software design.</para>
            </listitem>

            <listitem>
              <para>Unified main memory.</para>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">Disadvantages:</emphasis></para>

          <itemizedlist>
            <listitem>
              <para>Number of CPUs is limited by bus bandwidth.</para>
            </listitem>

            <listitem>
              <para>Requires an expensive bus (wide and fast) for great
              numbers of CPUs.</para>
            </listitem>

            <listitem>
              <para>Cache coherence problems.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>

    <section id="parallel_machines_mach_kernel">
      <title>Mach Kernel</title>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Mach Main Abstractions</emphasis></para>

          <orderedlist>
            <listitem>
              <para>Processes</para>
            </listitem>

            <listitem>
              <para>Threads</para>
            </listitem>

            <listitem>
              <para>Memory Objects</para>
            </listitem>

            <listitem>
              <para>Ports</para>
            </listitem>

            <listitem>
              <para>Messages</para>
            </listitem>
          </orderedlist>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Unix Servers </emphasis></para>

          <itemizedlist>
            <listitem>
              <para>Resource Management (Kernel).</para>
            </listitem>

            <listitem>
              <para>Handler for system calls (Server).</para>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">Advantages:</emphasis></para>

          <orderedlist>
            <listitem>
              <para>OS becomes simpler.</para>
            </listitem>

            <listitem>
              <para>OS becomes more machine independent.</para>
            </listitem>

            <listitem>
              <para>Multiple OSs can run at the same time.</para>
            </listitem>
          </orderedlist>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Processes</emphasis></para>

          <itemizedlist>
            <listitem>
              <para>Address Space</para>
            </listitem>

            <listitem>
              <para>Threads</para>

              <figure>
                <title>Mach Processes</title>

                <mediaobject>
                  <imageobject>
                    <imagedata fileref="img/parallelfig2_1.gif" />
                  </imageobject>
                </mediaobject>
              </figure>

              <para>Bootstrap port - initialization</para>

              <para>Exception port - report errors to processes</para>

              <para>Registered port - communication with standard server (like
              DNS)</para>

              <para>Process port - process related information</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Threads</emphasis></para>

          <itemizedlist>
            <listitem>
              <para>Thread port</para>
            </listitem>

            <listitem>
              <para>Commands FORK, EXIT, JOIN, DETACH, YIELD, SELF</para>
            </listitem>

            <listitem>
              <para>Scheduling done by the kernel.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Memory Management</emphasis></para>

          <itemizedlist>
            <listitem>
              <para><emphasis role="bold">Virtual Memory </emphasis></para>

              <figure>
                <title>Mach Virtual Memory</title>

                <mediaobject>
                  <imageobject>
                    <imagedata fileref="img/parallelfig2_2.gif" />
                  </imageobject>
                </mediaobject>
              </figure>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Memory Sharing </emphasis></para>

              <figure>
                <title>Meteorological/Agricultural Environmental</title>

                <mediaobject>
                  <imageobject>
                    <imagedata fileref="img/parallelfig2_3.gif" />
                  </imageobject>
                </mediaobject>
              </figure>
            </listitem>

            <listitem>
              <para><emphasis role="bold">External Memory
              Manager</emphasis></para>

              <para><emphasis role="bold">external pager</emphasis></para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Communication</emphasis></para>

          <itemizedlist>
            <listitem>
              <para>Ports</para>

              <figure>
                <title>Ports</title>

                <mediaobject>
                  <imageobject>
                    <imagedata fileref="img/parallelfig2_4.gif" />
                  </imageobject>
                </mediaobject>
              </figure>
            </listitem>

            <listitem>
              <para>UNIX Emulation Mach</para>

              <figure>
                <title>Unix Emulation</title>

                <mediaobject>
                  <imageobject>
                    <imagedata fileref="img/parallelfig2_5.gif" />
                  </imageobject>
                </mediaobject>
              </figure>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>

    <section id="parallel_machines_windows_31_e_95">
      <title>Windows 3.1 &amp; Windows 95</title>

      <itemizedlist>
        <listitem>
          <para>Windows 3.1</para>

          <itemizedlist>
            <listitem>
              <para>Protected mode.</para>
            </listitem>

            <listitem>
              <para>32 bit VMM (Virtual Machine Manager).</para>
            </listitem>

            <listitem>
              <para>Win386.exe.</para>

              <figure>
                <title>Windows 3.1</title>

                <mediaobject>
                  <imageobject>
                    <imagedata fileref="img/parallelfig3_1.gif" />
                  </imageobject>
                </mediaobject>
              </figure>
            </listitem>

            <listitem>
              <para>VxVs Virtual device drivers</para>
            </listitem>

            <listitem>
              <para>GDI Graphical Devices Interface</para>
            </listitem>

            <listitem>
              <para>User Windows Management</para>
            </listitem>
          </itemizedlist>

          <para>DLLs that provide OS services run in this same memory
          space.</para>

          <para>If one App crashes all system crashes.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Windows 95</emphasis></para>

          <para>1 sample</para>

          <para>protected mode</para>

          <para>32 bit VMM (Virtual Machine Manager)</para>

          <figure>
            <title>Windows 95</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="img/parallelfig3_2.gif" />
              </imageobject>
            </mediaobject>
          </figure>

          <itemizedlist>
            <listitem>
              <para>Win 32 App Run preemptive in private address space.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Differences form Windows
          3.1</emphasis></para>

          <itemizedlist>
            <listitem>
              <para>Provides address space for Win 32 process</para>
            </listitem>

            <listitem>
              <para>Add support for threads within Win 32 Apps</para>

              <itemizedlist>
                <listitem>
                  <para>It loads each win 32 App into System VM</para>
                </listitem>

                <listitem>
                  <para>Win 32 can write to critical areas of the OS (upper
                  2GB lower 1MB)</para>
                </listitem>

                <listitem>
                  <para>VMM schedule is preemptive but calls to 16 bit can
                  block the system</para>
                </listitem>

                <listitem>
                  <para>16 bit App run cooperatively</para>
                </listitem>

                <listitem>
                  <para>When a 16 bit program executes all other programs
                  can't run 16 bit code calls until it "yields" control. Win
                  32 apps will block if they need Win 16 calls.</para>
                </listitem>

                <listitem>
                  <para>Apps run in user mode kernel runs in kernel mode but
                  sensitive areas can not be protected to allow writes by 16
                  bit win apps.</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>

    <section id="parallel_machines_windows_nt">
      <title>Windows NT</title>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Windows NT</emphasis></para>

          <itemizedlist>
            <listitem>
              <para>uses a client/server architecture</para>
            </listitem>

            <listitem>
              <para>Apps invoke services via local procedure calls</para>
            </listitem>

            <listitem>
              <para>uses a microkernel model</para>

              <figure>
                <title>Windows NT</title>

                <mediaobject>
                  <imageobject>
                    <imagedata fileref="img/parallelfig3_3.gif" />
                  </imageobject>
                </mediaobject>
              </figure>
            </listitem>

            <listitem>
              <para>Each process is isolated in a 32bit Virtual Machine</para>
            </listitem>

            <listitem>
              <para>API calls are intercepted by subsystems stubs in the upper
              2 GB</para>
            </listitem>

            <listitem>
              <para>Each VM works as a Win32 computer</para>
            </listitem>

            <listitem>
              <para>VMs can work as other OSs machine: DOS, OS2, Win 3.1
              etc.</para>
            </listitem>

            <listitem>
              <para>VM machines communicate with the NT executive or other VMs
              by a message-passing procedure call similar to RPCs.</para>
            </listitem>
          </itemizedlist>

          <para>HAL - Hardware Abstraction Layer</para>
        </listitem>
      </itemizedlist>
    </section>
  </chapter>

  <chapter id="udf">
    <title>UDF</title>

    <section id="udf_unit_development_folder">
      <title>Unit Development Folder</title>

      <itemizedlist>
        <listitem>
          <para>UDF</para>

          <para><emphasis role="bold">Definition:</emphasis></para>

          <para>It is a specific form of development notebook which has proven
          useful and effective in collecting and orginizing software products
          as they are produced.</para>

          <para><emphasis role="bold">Purposes:</emphasis></para>

          <orderedlist>
            <listitem>
              <para>Provide an ordely and consistent approach in the
              development of each of the units of a program or project.</para>
            </listitem>

            <listitem>
              <para>Provide an uniform and visible collection point for all
              unit documentation and code.</para>
            </listitem>

            <listitem>
              <para>Aid individual discipline in the establishment and
              attainment of scheduled unit-level milestones.</para>
            </listitem>

            <listitem>
              <para>Provide low-level management visibility and control over
              the development process.</para>
            </listitem>

            <listitem>
              <para>Management can easily access the status of the
              unit.</para>
            </listitem>

            <listitem>
              <para>Much of the unit's deliverable documentation can be
              constructed from the UDF, when development is nearing
              completion.</para>
            </listitem>

            <listitem>
              <para>Most of the information necessary for post-delivery
              maintenance will be assembled in one place.</para>
            </listitem>
          </orderedlist>

          <para><emphasis role="bold">Main Points:</emphasis></para>

          <itemizedlist>
            <listitem>
              <para>The UDF is established in skeletal form prior to the start
              of design.</para>
            </listitem>

            <listitem>
              <para>The UDF becomes the primary tool for monitoring progress
              during software development and testing activities.</para>
            </listitem>

            <listitem>
              <para>All UDFs are controlled by a Project Engineer, who assigns
              a UDF Custodian for each UDF.</para>
            </listitem>

            <listitem>
              <para>The UDF can be audited at periodic intervals during the
              development process.</para>
            </listitem>

            <listitem>
              <para>The UDF Custodians are responsible for assuring that their
              UDFs are properly prepared and maintained.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>

    <section id="udf_unit_development_folder_guide">
      <title>Unit Development Folder Guide</title>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Overview</emphasis></para>

          <para>The purpose of this guide is to define and require a standard
          format for writing Unit Development Folders (UDF. There are several
          purposes which are served by Unit Development Folders:</para>

          <orderedlist>
            <listitem>
              <para>Provide an ordely and consistent approach in the
              development of each of the units of a program or project.</para>
            </listitem>

            <listitem>
              <para>Provide an uniform and visible collection point for all
              unit documentation and code.</para>
            </listitem>

            <listitem>
              <para>Aid individual discipline in the establishment and
              attainment of scheduled unit-level milestones.</para>
            </listitem>

            <listitem>
              <para>Provide low-level management visibility and control over
              the development process.</para>
            </listitem>

            <listitem>
              <para>Management can easily access the status of the unit</para>
            </listitem>

            <listitem>
              <para>Much of the unit's deliverable documentation can be
              constructed from the UDF, when development is nearing
              completion.</para>
            </listitem>

            <listitem>
              <para>Most of the information necessary for post-delivery
              maintenance will be assembled in one place.</para>
            </listitem>
          </orderedlist>

          <para>The UDF is established in skeletal form prior to the start of
          design and becomes the primary tool for monitoring progress during
          software development and testing activities. All UDFs are controlled
          by a Project Engineer, who assigns a UDF Custodian (responsible
          designer) for each UDF. The UDF will be audited at periodic
          intervals during the development process by the responsible Project
          Engineer to assure that the required format of the UDF is maintained
          and to allow complete assessment of unit status to be made.</para>

          <para>The UDF will be maintained in a binder with tabbed sections.
          Each UDF will be externally identified by a unique name, descriptive
          of the unit contained therein. Each UDF contains directly or
          provides a reference to the current documentation for each of its
          required items.</para>

          <para>The UDF Custodians are responsible for assuring that their
          UDFs are properly prepared and maintained. The Project Engineers are
          charged with assuring that the UDFs are structured uniformly to
          provide clarity and ease of inspection. The Project Engineer is also
          responsible for performing audits of the UDFs to verify adherence to
          the standards and requirements established by this guide.</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">UDF Organization and
          Content</emphasis></para>

          <para>The organization and contents of a UDF can be adapted to
          reflect local conditions or individual projects requirements. The
          important considerations in the structuring of a UDF are:</para>

          <orderedlist>
            <listitem>
              <para>The number of subdivisions is not so large as to be
              confusing or unmanageable.</para>
            </listitem>

            <listitem>
              <para>Each of the sections contributes to the management and
              visibility of the development process.</para>
            </listitem>

            <listitem>
              <para>The content and format of each section are afequately and
              unambiguosly defined.</para>
            </listitem>

            <listitem>
              <para>The subdivisions are suficiently flexible to be applicable
              to a variety of software types.</para>
            </listitem>

            <listitem>
              <para>The individual sections are chronologically ordered as
              nearly as possible.</para>
            </listitem>
          </orderedlist>

          <para>The development of the UDF is geared to proceed logically and
          sequentially, and each section should be as complete as possible
          before proceeding to the next section. This is not always possible,
          and software development is usually an interative rather than
          sequencial process. These situations only serve to reinforce the
          need for an ordered process that can be understood and tracked even
          under adverse conditions.</para>

          <para>A UDF should contain the following sections:</para>

          <itemizedlist>
            <listitem>
              <para><emphasis role="bold">Introduction</emphasis></para>

              <para>This section contains a UDF cover sheet (figure 1) for the
              unit and identifies the status of the components of the UDF. The
              cover sheet delineates, for each of the sections, the start and
              completion dates, responsible originators, and reviewer
              sign-offs and dates.</para>

              <para>Following the cover sheet is a description of the unit,
              system overview, and how the unit fits into the system. A top
              level structure diagram of the units components will be
              provided. Also provide naming conventions used, plus any unique
              system capabilities required by the unit.</para>

              <para>Following this description, a unit schedule will be
              included. This schedule will show the state of all the unit's
              components. Each component will be listed along with start date,
              percent complete, and completion date for each of the following
              functions: Design, Code, and Test.</para>

              <para>Following each cover sheet, a UDF Change Log should be
              included to document all UDF changes subsequent to the time when
              the unit is put into a controlled test or maintenance
              environment.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Requirements</emphasis></para>

              <para>This section will contain as separately tabbed subsections
              program requirements specification documentation and the program
              operating environment. The program requirements specification
              subsection will contain a copy of any current requirements
              documentation applicable to the unit. The program operating
              environment subsection will contain the hardware and operating
              system configurations required for the operation of the
              unit.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">External
              Interfaces</emphasis></para>

              <para>This section contains a detailed data description for all
              external interfaces either required or generated by this
              unit.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Design Description</emphasis></para>

              <para>This section will contain as subsections the design
              description for each unit component. Each subsection will
              contain the component functional description, the interfaces,
              the data organization (data dictionary, data flows), control
              flows, state diagrams, and PDL describing the process flow.
              Throughout the development and maintenance process, each Design
              subsection represents the current working version of the design,
              and therefore will be maintained and annotated as changes occur
              to the initial design. The information presented here should
              reflect the component's header.</para>

              <para>If you are doing development in an object oriented
              language (such as Java), add the Class Diagrams (UML) of your
              program as pictures. If you used other UML diagrams, add them
              also.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Code</emphasis></para>

              <para>As the unit components are modified, this section contains
              the listing for unit component.</para>

              <para>Do not forget to document the specification of every
              method (or procedure) of your program, a specification of a
              method (or procedure) consists of several clauses:</para>

              <itemizedlist>
                <listitem>
                  <para>a precondition, indicated by the keyword
                  requires;</para>
                </listitem>

                <listitem>
                  <para>a postcondition, indicated by the keyword
                  effects;</para>
                </listitem>

                <listitem>
                  <para>a frame condition, indicated by the keyword
                  modifies.</para>
                </listitem>
              </itemizedlist>

              <para>Remember: not all clauses have to be present in all
              specifications; in Java, use the javadoc utility to generate
              documentation.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Unit Test Plan</emphasis></para>

              <para>This section contains a test plan for the unit and
              identifies the individual tests described. A description of each
              test case will be included. Whenever possible use a xUnit test
              framework. In Java, use the jUnit test framework.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Test Results</emphasis></para>

              <para>This section contains a compilation of all current
              successful test case results and analyses necessary to
              demonstrate that the unit has been tested as described in the
              test plan. Test output should be identified by test case numbers
              and results should be annotated to facilitate reviews of this
              results by other qualified individuals.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Build Procedures</emphasis></para>

              <para>This section will include a list of all the names of all
              the appropriate files (e.g., source and object) as well as their
              locations for system development, modification, and maintenance.
              This section will also include the detailed steps sufficient to
              supply an operator with the procedures necessary to produce the
              executable software.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Problems Reports</emphasis></para>

              <para>This section contains status logs and copies of all Design
              Problems Reports, Design Analysis Reports and Discrepancy
              Reports (as required) which document all design and code
              problems and changes experienced by the unit. This ensures a
              clear and documented traceability for all problems and changes
              incurred.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Notes</emphasis></para>

              <para>This section may be composed of any item pertaining to the
              unit that the UDF Custodian wishes to include.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Audits/Reviews</emphasis></para>

              <para>This section will contain copies of all audit/reviews
              reports applicable to the UDF. This includes PDL and Code
              walkthroughs and UDF audits. Include all notes pertaining to
              those audits and reviews.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">UDF Maintenance</emphasis></para>

          <para>After code development and initial baselining, the design
          responsibility is unchanged. All changes made to the UDF will be as
          described in section 2, UDF Organization and Contents, of this
          guide.</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Summary</emphasis></para>

          <para>The UDF concept has evolved into a pratical, efective and
          valuable tool not only for the management of software development
          but also for imposing a structured approach on the total software
          development process. The structure and content of the UDF are
          designed to create a set of milestones at the unit leval, each of
          which can be easily observed and reviewed.</para>

          <para>PROGRAM NAME:
          __________________________________________________</para>

          <para>UNIT NAME:______________________________
          CUSTODIAN:______________</para>

          <para>ROUTINES
          INCLUDED:______________________________________________</para>

          <table>
            <title>UDF Cover Page</title>

            <tgroup cols="6">
              <tbody>
                <row>
                  <entry><emphasis role="bold">Section No.</emphasis></entry>

                  <entry><emphasis role="bold">Description</emphasis></entry>

                  <entry><emphasis role="bold">Due Date</emphasis></entry>

                  <entry><emphasis role="bold">Date
                  Completed</emphasis></entry>

                  <entry><emphasis role="bold">Originator</emphasis></entry>

                  <entry><emphasis
                  role="bold">Reviewer/Date</emphasis></entry>
                </row>

                <row>
                  <entry>1</entry>

                  <entry>Requirements</entry>

                  <entry>.</entry>

                  <entry>.</entry>

                  <entry>.</entry>

                  <entry>.</entry>
                </row>

                <row>
                  <entry>2</entry>

                  <entry>External Interfaces</entry>

                  <entry>.</entry>

                  <entry>.</entry>

                  <entry>.</entry>

                  <entry>.</entry>
                </row>

                <row>
                  <entry>3</entry>

                  <entry>Design Description</entry>

                  <entry>.</entry>

                  <entry>.</entry>

                  <entry>.</entry>

                  <entry>.</entry>
                </row>

                <row>
                  <entry>4</entry>

                  <entry>Unit Code</entry>

                  <entry>.</entry>

                  <entry>.</entry>

                  <entry>.</entry>

                  <entry>.</entry>
                </row>

                <row>
                  <entry>5</entry>

                  <entry>Unit Test Plan</entry>

                  <entry>.</entry>

                  <entry>.</entry>

                  <entry>.</entry>

                  <entry>.</entry>
                </row>

                <row>
                  <entry>6</entry>

                  <entry>Test Results</entry>

                  <entry>.</entry>

                  <entry>.</entry>

                  <entry>.</entry>

                  <entry>.</entry>
                </row>

                <row>
                  <entry>7</entry>

                  <entry>Build Procedures</entry>

                  <entry>.</entry>

                  <entry>.</entry>

                  <entry>.</entry>

                  <entry>.</entry>
                </row>

                <row>
                  <entry>8</entry>

                  <entry>Problems Reports</entry>

                  <entry></entry>

                  <entry></entry>

                  <entry></entry>

                  <entry>.</entry>
                </row>

                <row>
                  <entry>9</entry>

                  <entry>Notes</entry>

                  <entry></entry>

                  <entry></entry>

                  <entry></entry>

                  <entry></entry>
                </row>

                <row>
                  <entry>10</entry>

                  <entry>Reviewers</entry>

                  <entry></entry>

                  <entry></entry>

                  <entry></entry>

                  <entry></entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </listitem>
      </itemizedlist>
    </section>
  </chapter>

  <chapter id="exercises">
    <title>Exercises</title>

    <section id="exercises_list_1">
      <title>List 1</title>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">List 1</emphasis></para>

          <orderedlist>
            <listitem>
              <para>Quais sÃ£o as principais atividades de um sistema
              operacional em relaÃ§Ã£o ao gerenciamento: de memÃ³ria e de
              processos.</para>
            </listitem>

            <listitem>
              <para>Diferencie os termos processos, threads e
              programas.</para>
            </listitem>

            <listitem>
              <para>Explique a diferenÃ§a entre criar um processo e criar um
              thread. O que Ã© compartilhado entre os threads de um
              processo.</para>
            </listitem>

            <listitem>
              <para>Descreva as aÃ§Ãµes realizadas pelo nÃºcleo de um SO para uma
              mudanÃ§a de contexto: Â· entre threads e entre processos.</para>
            </listitem>

            <listitem>
              <para>Um programa pode gerar mÃºltiplos processos. DÃª um exemplo
              de um problema que pode ser resolvido fazendo-se vÃ¡rias
              computaÃ§Ãµes independentemente.</para>
            </listitem>

            <listitem>
              <para>FaÃ§a um esquema que represente os estados de um processo e
              explique como cada estado pode ocorrer.</para>
            </listitem>

            <listitem>
              <para>Cite e explique os estados dos threads.</para>
            </listitem>

            <listitem>
              <para>Para que servem as âsystems callsâ?</para>
            </listitem>

            <listitem>
              <para>Qual a funÃ§Ã£o do gerenciamento de memÃ³ria em um sistema
              operacional?</para>
            </listitem>

            <listitem>
              <para>Quais sÃ£o as vantagens do uso de threads sobre o uso de
              mÃºltiplos processos? Qual a maior desvantagem que apresentam?
              Sugira uma aplicaÃ§Ã£o que se beneficiaria do uso de threads e uma
              que nÃ£o se beneficiaria.</para>
            </listitem>

            <listitem>
              <para>Qual Ã© a diferenÃ§a fundamental entre escalonamento
              preemptivo e escalonamento nÃ£o preemptivo?</para>
            </listitem>

            <listitem>
              <para>Qual o tipo de escalonamento feito nos sistemas Linux e
              Solaris?</para>
            </listitem>

            <listitem>
              <para>Como funciona o escalonamento Round Robin?</para>
            </listitem>

            <listitem>
              <para>A maioria dos escalonadores Round Robin usa um quantum de
              tamanho fixo. Pense em algum argumento em favor de um quantum
              pequeno. Agora pense em um argumento que justifique um quantum
              grande.</para>
            </listitem>

            <listitem>
              <para>Explique o que Ã© race condition.</para>
            </listitem>

            <listitem>
              <para>O que Ã© deadlock? Quais sÃ£o as quatro condiÃ§Ãµes
              necessÃ¡rias para que o deadlock ocorra? Como ele pode ser
              evitado?</para>
            </listitem>

            <listitem>
              <para>Explique o que Ã© busy wait (espera ocupada) e por que os
              algoritmos que empregam essa tÃ©cnica sÃ£o considerados
              ineficientes. Qual a diferenÃ§a com bloqueio?</para>
            </listitem>

            <listitem>
              <para>Explique cada um dos mecanismos de sincronizaÃ§Ã£o abaixo
              apontando vantagens e desvantagens: - exclusÃ£o mÃºtua - variÃ¡veis
              de condiÃ§Ã£o - semÃ¡foros</para>
            </listitem>

            <listitem>
              <para>Utilizando o programa do exercÃ­cio 3 da prÃ¡tica 4
              (produtor/consumidor), faÃ§a a implementaÃ§Ã£o utilizando
              semÃ¡foros.</para>
            </listitem>

            <listitem>
              <para>Explique o conceito de atomicidade de uma transaÃ§Ã£o.
              Mostre que, se as operaÃ§Ãµes wait e signal nÃ£o forem executadas
              atomicamente, nÃ£o se pode garantir a exclusÃ£o mÃºtua.</para>
            </listitem>

            <listitem>
              <para>O problema do Barbeiro Dorminhoco. Uma barbearia consiste
              de uma sala de espera com N cadeiras, e a sala do barbeiro com a
              cadeira do mesmo. Se nÃ£o hÃ¡ clientes a serem servidos, o
              barbeiro vai dormir. Se um cliente entra na barbearia e todas as
              cadeiras estÃ£o ocupadas, entÃ£o o cliente deixa a barbearia. Se o
              barbeiro estÃ¡ ocupado, mas hÃ¡ cadeiras disponÃ­veis, entÃ£o o
              cliente senta em uma das cadeiras livres. Se o barbeiro estÃ¡
              dormindo, entÃ£o o cliente acorda o barbeiro. Escreva um programa
              que represente a situaÃ§Ã£o acima, coordenando o barbeiro e os
              clientes. Dicas: crie um processo barbeiro e um cliente e use
              semÃ¡foros na sincronizaÃ§Ã£o.</para>
            </listitem>

            <listitem>
              <para>A soluÃ§Ã£o adotada no exercÃ­cio anterior pode ser
              generalizada para o caso de mais de um barbeiro? Se sim, mostre
              como.</para>
            </listitem>

            <listitem>
              <para>Considere 5 (cinco) filÃ³sofos que passam a vida comendo e
              pensando. Eles ficam todos em uma mesa circular com cinco
              cadeiras, sendo cada cadeira pertencente ao um filÃ³sofo. Uma
              travessa de espaguete fica no cento da mesa, que Ã© posta com
              cinco pratos e cinco garfos usados pelos filÃ³sofos para comer o
              espaguete. Quando fica pensando, um filÃ³sofo nÃ£o interage com
              seus colegas. De vez em quando, um filÃ³sofo fica com fome e
              tenta pegar dois garfos prÃ³ximos a ele (que estÃ£o entre ele e
              seus vizinhos Ã  direita e Ã  esquerda). Um filÃ³sofo pode pegar
              apenas um garfo por vez. Obviamente, ele nÃ£o pode pegar um garfo
              que jÃ¡ esteja na mÃ£o de outro filÃ³sofo. Quando um filÃ³sofo
              consegue pegar os dois garfos, ele come sem largÃ¡-los. Quando
              termina de comer, ele coloca os garfos nos seus lugares e volta
              a pensar. FaÃ§a o algoritmo para resolver o problema dos
              filÃ³sofos usando semÃ¡foros.</para>
            </listitem>

            <listitem>
              <para>Mostre que as quatro condiÃ§Ãµes necessÃ¡rias Ã  ocorrÃªncia de
              deadlocks estÃ£o presentes no problema do jantar dos
              filÃ³sofos.</para>
            </listitem>

            <listitem>
              <para>Suponha que dois processos P1 e P2 contenham, cada qual,
              os seguintes comandos de linguagem de alto nÃ­vel em um loop: Num
              = Num + 1</para>

              <para>if Num = 50 then</para>

              <para>Num = 0</para>

              <para>Suponha tambÃ©m que ambos compartilham a variÃ¡vel Num e
              estejam ativos. Mesmo com apenas uma CPU, explique como Num pode
              nunca ser igual a 0 (zero).</para>
            </listitem>

            <listitem>
              <para>Quais as vantagens na utilizaÃ§Ã£o de sockets? Explique as
              diferenÃ§as entre stream sockets e datagram sockets. DÃª exemplos
              de onde cada tipo pode ser melhor aplicado.</para>
            </listitem>
          </orderedlist>
        </listitem>
      </itemizedlist>
    </section>

    <section id="exercises_list_2">
      <title>List 2</title>

      <orderedlist>
        <listitem>
          <para>Quais sÃ£o as principais caracterÃ­sticas das aplicaÃ§Ãµes
          distribuÃ­das?</para>
        </listitem>

        <listitem>
          <para>Na infraestrutura Cliente/Servidor, qual a importÃ¢ncia da
          camada Midleware?</para>
        </listitem>

        <listitem>
          <para>Quais sÃ£o os requisitos necessÃ¡rios para uma boa aplicaÃ§Ã£o
          cliente/servidor?</para>
        </listitem>

        <listitem>
          <para>No contexto de aplicaÃ§Ãµes cliente/servidor, explique a funÃ§Ã£o
          dos servidores de arquivos, servidores de base de dados, servidores
          de transaÃ§Ã£o, servidores de groupware, servidores de objetos
          distribuÃ­dos e servidores de aplicaÃ§Ãµes web.</para>
        </listitem>

        <listitem>
          <para>Quais as vantagens na utilizaÃ§Ã£o de objetos
          distribuÃ­dos?</para>
        </listitem>

        <listitem>
          <para>Descreva, de forma resumida, qual Ã© o processo de
          desenvolvimento de uma aplicaÃ§Ã£o cliente/servidor utilizando objetos
          distribuÃ­dos e Corba.</para>
        </listitem>

        <listitem>
          <para>Descreva sobre Sistemas Operacionais de Rede destacando suas
          caracterÃ­sticas e tipos de serviÃ§os que podem realizar.</para>
        </listitem>

        <listitem>
          <para>Qual Ã© a funÃ§Ã£o do DNS? Qual a sua importÃ¢ncia?</para>
        </listitem>

        <listitem>
          <para>Qual Ã© o processo para que uma aplicaÃ§Ã£o possa descobrir o
          endereÃ§o IP de uma mÃ¡quina na rede utilizando o DNS?</para>
        </listitem>

        <listitem>
          <para>Diferencie domÃ­nio de zona. O que Ã© um servidor de domÃ­nios
          autoritativo para a zona?</para>
        </listitem>

        <listitem>
          <para>Quais sÃ£o as vantagens oferecidas pelo NFS? Qual a relaÃ§Ã£o
          entre NFS e VFS?</para>
        </listitem>

        <listitem>
          <para>Quais Ã© a funÃ§Ã£o do NIS? Qual a sua importÃ¢ncia?</para>
        </listitem>

        <listitem>
          <para>Existe alguma relaÃ§Ã£o entre NIS e DNS? Explique.</para>
        </listitem>

        <listitem>
          <para>Os domÃ­nios NIS podem ser comparados aos domÃ­nios do DNS?
          Explique.</para>
        </listitem>

        <listitem>
          <para>Por que um NOS nÃ£o Ã© um sistema operacional real?</para>
        </listitem>

        <listitem>
          <para>Por que se diz que o NFS Ã© stateless? Isto Ã© uma vantagem? Se
          sim, por quÃª?</para>
        </listitem>

        <listitem>
          <para>Tanto NIS quanto NFS sÃ£o baseados em RPC. Usando seus
          conhecimentos, explique como o RPC Ã© utilizado nesses dois
          serviÃ§os.</para>
        </listitem>

        <listitem>
          <para>Qual a implicaÃ§Ã£o em se alterar o endereÃ§o (IP) dos servidores
          autoritativos do domÃ­nio .com ? O endereÃ§o do (.) poderia ser
          alterado?</para>
        </listitem>
      </orderedlist>
    </section>

    <section id="exercises_answers_1">
      <title>Answers 1</title>

      <itemizedlist>
        <listitem>
          <para>Answers 1</para>

          <orderedlist>
            <listitem>
              <para>Processos: Â· CriaÃ§Ã£o e remoÃ§Ã£o de processos (do sistema e
              dos usuÃ¡rios) Â· SuspensÃ£o e ativaÃ§Ã£o de processos Â·
              SincronizaÃ§Ã£o de processos Â· ComunicaÃ§Ã£o entre processos Â·
              Tratamento de deadlock entre os processos MemÃ³ria: Â· Manter
              informaÃ§Ã£o sobre quais partes da memÃ³ria estÃ£o sendo usadas no
              instante atual e por quem Â· Decidir quais processos devem ser
              carregados na memÃ³ria quando algum espaÃ§o de memÃ³ria se torna
              disponÃ­vel Â· Alocar espaÃ§o e remover programas e dados da
              memÃ³ria quando necessÃ¡rio</para>
            </listitem>

            <listitem>
              <para>Um processo corresponde a um programa em execuÃ§Ã£o.
              Normalmente o termo programa Ã© utilizado para definir o cÃ³digo
              do mesmo e o termo processo para se referir Ã  ativaÃ§Ã£o do mesmo,
              incluindo cÃ³digo, dados, arquivos e outros recursos necessÃ¡rios
              Ã  sua execuÃ§Ã£o. Em alguns casos, um mesmo programa pode fazer
              parte de vÃ¡rios processos. Um processo pode conter um Ãºnico
              thread (processo pesado) ou vÃ¡rios (processo leve). Cada thread
              compartilhando o mesmo cÃ³digo mas executando
              "paralelamente".</para>
            </listitem>

            <listitem>
              <para>Na criaÃ§Ã£o de novos processos, para que haja
              compartilhamento de todos os recursos alocados para o processo
              pai, o processo filho deve ser uma cÃ³pia do pai. Isso implica em
              armazenar todas as informaÃ§Ãµes, que estÃ£o armazenadas no espaÃ§o
              de endereÃ§amento do processo pai, no espaÃ§o de endereÃ§amento do
              processo filho. Cada processo consiste de contador de programas,
              seÃ§Ã£o de dados e cÃ³digo, ponteiro de pilha de execuÃ§Ã£o e
              registradores. Todos esses dados sÃ£o copiados para o novo
              processo. Na criaÃ§Ã£o de uma thread, Ã© criado um espaÃ§o de
              endereÃ§amento (dentro do espaÃ§o do processo) com um contador de
              instruÃ§Ãµes, registradores e um espaÃ§o de pilha para aquela
              thread. Todas as outras informaÃ§Ãµes existentes no espaÃ§o de
              endereÃ§amento do processo (que Ã© comum para todas as threads)
              nÃ£o precisam ser replicadas e podem ser utilizadas por todas as
              threads que fazem parte do processo. Ou seja, o tempo de criaÃ§Ã£o
              e alocaÃ§Ã£o de espaÃ§o para criar a thread Ã© menor do que para
              criar o processo, fazendo c/ que a criaÃ§Ã£o de threads seja mais
              barata do que a de processos. As thread compartilham a seÃ§Ã£o de
              dados e de cÃ³digo e os recursos do sistema operacional com as
              demais threads do processo.</para>
            </listitem>

            <listitem>
              <para>Cada processo Ã© descrito no SO por um Bloco de controle de
              processos (BCP) e cada thread Ã© descrita no processo por um
              bloco de controle prÃ³prio (BCT). No BCP hÃ¡ informaÃ§Ãµes:
              compartilhadas (espaÃ§o de endereÃ§amento, variÃ¡veis globais,
              arquivos abertos, temporizadores, sinais, semÃ¡foros e
              contabilizaÃ§Ã£o de recursos) e especÃ­ficas (processos filhos,
              contador de programa, pilha, conjunto de registradores e
              informaÃ§Ãµes sobre o estado do processo). No BCT, hÃ¡ informaÃ§Ãµes:
              especÃ­ficas (contador de programa, pilha, conjunto de
              registradores e informaÃ§Ãµes sobre o estado do thread). Na troca
              de contextos entre processos, o SO armazena o estado do processo
              atual e recupera o estado do processo que serÃ¡ executado
              realizando as seguintes operaÃ§Ãµes: Â· atualiza o estado do
              processo, o contador de programa e outras informaÃ§Ãµes do BCP Â·
              salva registradores da CPU nos registradores do processo Â·
              recupera as informaÃ§Ãµes do BCP do novo processo e grava os
              valores dos registradores do novo processo nos registradores da
              CPU Â· comeÃ§a a execuÃ§Ã£o do novo processo Entre threads, nÃ£o
              existe uma troca de contexto propriamente dita. O SO salva as
              informaÃ§Ãµes especÃ­ficas da thread e recupera as informaÃ§Ãµes
              especÃ­ficas da outra thread que deverÃ¡ entrar em execuÃ§Ã£o. O
              contexto do processo continua o mesmo, ocorrendo apenas a troca
              entre contador de programa, pilha e registradores da
              thread.</para>
            </listitem>

            <listitem>
              <para></para>
            </listitem>

            <listitem>
              <para>1) processo que estava executando Ã© bloqueado pelo SO
              (entrada de dados)</para>

              <para>2) processo que estava executando Ã© suspenso pelo SO
              (troca entre processos)</para>

              <para>3) processo suspenso entra novamente em execuÃ§Ã£o (processo
              escalonado)</para>

              <para>4) processo bloqueado fica pronto para ser executado
              (liberaÃ§Ã£o de entrada de dados)</para>
            </listitem>

            <listitem>
              <para>Runnable: pronta para executar Active: executando
              Sleeping: dormindo (esperando recurso) Stopped: parada Zombie:
              finalizada</para>
            </listitem>

            <listitem>
              <para>As system calls servem para que o usuÃ¡rio possa interagir
              com as funÃ§Ãµes do sistema operacional. A chamada a uma system
              call Ã© semelhante Ã  chamada de uma funÃ§Ã£o em um programa, com a
              diferenÃ§a que as funÃ§Ãµes realizadas atravÃ©s da chamada de uma
              system call sÃ£o realizadas (e implementadas) pelo kernel do
              sistema operacional (interrupÃ§Ã£o de software).</para>
            </listitem>

            <listitem>
              <para>Â· Gerenciar as Ã¡reas de memÃ³ria que estÃ£o sendo usadas e
              as que estÃ£o livres</para>

              <para>Â· Alocar e desalocar memÃ³ria para os processos</para>

              <para>Â· Alocar espaÃ§o em disco quando a memÃ³ria principal nÃ£o
              for suficiente (gerenciar swapping)</para>
            </listitem>

            <listitem>
              <para>Vantagens:</para>

              <para>Â· criar threads Ã© mais rÃ¡pido e mais barato</para>

              <para>Â· NÃ£o Ã© necessÃ¡ria a troca de todo o contexto para trocar
              o thread que estÃ¡ em execuÃ§Ã£o por outro que estÃ¡ esperando para
              ser executado</para>

              <para>Â· Pode fornecer respostas mais rÃ¡pidas</para>

              <para>Â· Recursos podem ser compartilhados</para>

              <para>Desvantagem: necessidade de sincronizaÃ§Ã£o</para>

              <para>Beneficiada: aplicaÃ§Ãµes sem dependÃªncia de dados</para>

              <para>NÃ£o beneficiada: aplicaÃ§Ãµes com dependÃªncia de
              dados</para>
            </listitem>

            <listitem>
              <para>Preemptivo: um processo em execuÃ§Ã£o pode ser suspenso para
              dar lugar Ã  execuÃ§Ã£o de outro processo que estÃ¡ esperando para
              ser executado</para>

              <para>NÃ£o preemptivo: uma vez alocada a CPU a um processo, esse
              Ã© executado atÃ© o fim ou quando o processo aguarda por algum
              recurso bloqueado.</para>
            </listitem>

            <listitem>
              <para>Linux: Round Robin com prioridade Solaris:</para>
            </listitem>

            <listitem>
              <para>Uma pequena unidade de tempo, denominada timeslice ou
              quantum, Ã© definida. Todos os processos sÃ£o armazenados em uma
              fila circular. O escalonador da CPU percorre a fila, alocando a
              CPU para cada processo durante um quantum. Mais precisamente, o
              escalonador retira o primeiro processo da fila e procede Ã  sua
              execuÃ§Ã£o. Se o processo nÃ£o termina apÃ³s um quantum, ocorre uma
              preempÃ§Ã£o, e o processo Ã© inserido no fim da fila. Se o processo
              termina antes de um quantum, a CPU Ã© liberada para a execuÃ§Ã£o de
              novos processos. Em ambos os casos, apÃ³s a liberaÃ§Ã£o da CPU, um
              novo processo Ã© escolhido na fila. Novos processos sÃ£o inseridos
              no fim da fila. Quando um processo Ã© retirado da fila para a
              CPU, ocorre uma troca de contexto, o que resulta em um tempo
              adicional na execuÃ§Ã£o do processo.</para>
            </listitem>

            <listitem>
              <para></para>
            </listitem>

            <listitem>
              <para>SituaÃ§Ã£o na qual vÃ¡rios threads acessam e manipulam os
              mesmos dados de forma concorrente. Quando ocorre race condition,
              o resultado da execuÃ§Ã£o do processo depende da ordem especÃ­fica
              em que o acesso aos dados acontece.</para>
            </listitem>

            <listitem>
              <para>Deadlock Ã© a situaÃ§Ã£o na qual dois ou mais processos
              competem por um recurso sendo que, em um dado instante, um
              processo solicita um recurso que nÃ£o estÃ¡ disponÃ­vel e fica
              bloqueado esperando pela liberaÃ§Ã£o do recurso. Pode ser que, por
              algum motivo, o recurso nunca seja liberado, fazendo com que o
              processo que o estÃ¡ esperando nunca seja desbloqueado e
              conseqÃ¼entemente nÃ£o termine sua execuÃ§Ã£o.</para>

              <para>As condiÃ§Ãµes seguintes devem ser satisfeitas num dado
              instante para que o deadlock ocorra: Â· ExclusÃ£o mÃºtua: apenas um
              processo por vez pode utilizar um dado recurso; Â· Uso e espera:
              pelo menos um processo utilizando um recurso e esperando pela
              liberaÃ§Ã£o de outro Â· InexistÃªncia de preempÃ§Ã£o: um recurso sÃ³
              pode ser liberado pelo processo que o alocou Â· Espera circular:
              um conjunto de processos espera por recursos alocados por outros
              processos de forma circular (um depende do outro imediatamente
              anterior). Deadlocks sÃ£o evitados quando pelo menos uma das
              quatro condiÃ§Ãµes nÃ£o Ã© verdade. AtravÃ©s da sincronizaÃ§Ã£o, o
              deadlock Ã© evitado.</para>
            </listitem>

            <listitem>
              <para>Busy wait Ã© quando um conjunto de instruÃ§Ãµes Ã© executado
              infinitamente atÃ© que uma dada condiÃ§Ã£o seja satisfeita, por
              exemplo, enquanto um thread estÃ¡ executando a seÃ§Ã£o crÃ­tica, os
              outros que tentarem acessa-la deverÃ£o executar um laÃ§o atÃ© que a
              seÃ§Ã£o crÃ­tica seja liberada. Os algoritmos que empregam busy
              wait sÃ£o ineficientes porque consomem tempo de CPU enquanto
              outros threads poderiam ser executados. No bloqueio, o thread
              que chega Ã  seÃ§Ã£o crÃ­tica, que estÃ¡ sendo utilizada por outro
              thread, Ã© colocado em estado de espera e sÃ³ volta Ã  execuÃ§Ã£o
              quando a regiÃ£o for liberada e ele for escalonado para ser
              executado.</para>
            </listitem>

            <listitem>
              <para>ExclusÃ£o mÃºtua: proÃ­be que mais de um thread acesse o dado
              compartilhado ao mesmo tempo vantagem: resolve o problema de
              vÃ¡rios threads alterarem o valor de um dado de forma desordenada
              desvantagem: nÃ£o garante a seqÃ¼Ãªncia das instruÃ§Ãµes
              (sincronizaÃ§Ã£o) VariÃ¡veis de condiÃ§Ã£o: bloqueia um thread atÃ©
              que uma dada condiÃ§Ã£o seja verdadeira Vantagem: resolve o
              problema de sincronizaÃ§Ã£o Desvantagem: sinais podem ser perdidos
              e quando Ã© necessÃ¡rio controlar mais de uma condiÃ§Ã£o, a
              implementaÃ§Ã£o fica complicada SemÃ¡foros: um thread espera por um
              semÃ¡foro para realizar determinada regiÃ£o crÃ­tica (atomicidade
              na adiÃ§Ã£o, remoÃ§Ã£o do recurso e bloqueio do thread). Vantagem:
              nÃ£o perde sinais e permite controlar grande variedade de
              recursos e condiÃ§Ãµes de forma mais simplificada.
              Desvantagem:</para>
            </listitem>

            <listitem>
              <para></para>
            </listitem>

            <listitem>
              <para>Atomicidade de uma transaÃ§Ã£o significa que uma dado
              operaÃ§Ã£o ou Ã© executada atÃ© o seu fim, ou nÃ£o Ã© executada, ou
              seja, uma transaÃ§Ã£o atÃ´mica garante a execuÃ§Ã£o da operaÃ§Ã£o por
              inteira. Se as operaÃ§Ãµes de wait e signal nÃ£o forem atÃ´micas, ou
              seja, nÃ£o garantirem a execuÃ§Ã£o do restante do cÃ³digo do thread,
              o programa nÃ£o funcionarÃ¡ porque um thread ficarÃ¡ esperando pelo
              sinal que nÃ£o vai ser enviado pelo outro thread.</para>
            </listitem>

            <listitem>
              <para></para>
            </listitem>

            <listitem>
              <para></para>
            </listitem>

            <listitem>
              <para></para>
            </listitem>

            <listitem>
              <para></para>
            </listitem>

            <listitem>
              <para></para>
            </listitem>
          </orderedlist>
        </listitem>
      </itemizedlist>
    </section>

    <section id="exercises_answers_2">
      <title>Answers 2</title>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">Answers 2</emphasis></para>

          <orderedlist>
            <listitem>
              <para>As aplicaÃ§Ãµes distribuÃ­das tem como caracterÃ­sticas: Â·
              PresenÃ§a de pelo menos um cliente e um servidor Â·
              Compartilhamento de recursos Â· TransparÃªncia de localizaÃ§Ã£o Â·
              Clientes e servidores independentes de plataforma de software e
              hardware</para>
            </listitem>

            <listitem>
              <para>Um middleware Ã© um software que executa entre a aplicaÃ§Ã£o
              cliente e servidora, ou seja, o middleware Ã© um conjunto de APIs
              que sÃ£o usadas para invocar um serviÃ§o, transmitir o pedido pela
              rede e devolver a resposta ao solicitante. O middleware nÃ£o
              inclui o software que provÃª o serviÃ§o e nem bases de dados e nem
              interfaces de usuÃ¡rio. No middleware hÃ¡ uma sÃ©rie de serviÃ§os de
              comunicaÃ§Ã£o que nÃ£o precisam ser reimplementados quando se
              desenvolve uma aplicaÃ§Ã£o cliente/ servidor, sendo que elas podem
              ser diretamente utilizadas para facilitar o processo de
              desenvolvimento.</para>
            </listitem>

            <listitem>
              <para>Suportar vÃ¡rios clientes e vÃ¡rios servidores, gerenciar de
              forma eficiente os recursos, ser o mais transparente possÃ­vel,
              ser independente de plataforma, hardware e rede, ser escalÃ¡vel,
              e manter integridade entre as transaÃ§Ãµes.</para>
            </listitem>

            <listitem>
              <para>Servidores de arquivos: compartilhamento de arquivos entre
              clientes e servidores (criaÃ§Ã£o de repositÃ³rios compartilhados)
              Servidores de base de dados: compartilhamento de dados entre os
              clientes, sendo que eles ficam armazenados no servidor e toda
              busca e atualizaÃ§Ã£o dos dados Ã© requisitada atravÃ©s de uma
              mensagem do cliente para o servidor e a operaÃ§Ã£o Ã© realizada no
              servidor. Servidores de transaÃ§Ã£o: Servidores de groupware:
              troca de informaÃ§Ãµes nÃ£o estruturadas entre aplicaÃ§Ãµes
              distribuÃ­das que gerenciam diferentes tipos de informaÃ§Ã£o como
              textos, imagens, email, workflow... Os servidores de workflow
              oferecem os recursos para buscar, organizar, distribuir, alterar
              estas informaÃ§Ãµes que sÃ£o chamadas de documentos. Servidores de
              objetos distribuÃ­dos: compartilhamento de objetos entre as
              aplicaÃ§Ãµes cliente e servidoras. Os objetos sÃ£o usados nas
              aplicaÃ§Ãµes ora como clientes, ora como servidores, dependendo da
              sua utilizaÃ§Ã£o. Servidores de aplicaÃ§Ã£o web: apresentaÃ§Ã£o de
              documentos requisitados pelos clientes ???</para>
            </listitem>

            <listitem>
              <para>Â· A lÃ³gica de negÃ³cio Ã© encapsulada dentro do
              objeto</para>

              <para>Â· InstrospeÃ§Ã£o permite descobrir facilmente o que tem
              dentro do objeto (ferramentas visuais)</para>

              <para>Â· Pode ser transportado pela rede</para>

              <para>Â· Ã multiplataforma</para>

              <para>Â· Sistemas mais flexÃ­veis em funÃ§Ã£o do
              encapsulamento</para>

              <para>Â· Permite reutilizaÃ§Ã£o e agrupamento de objeto</para>

              <para>Â· controle centralizado de versÃµes de objeto,</para>

              <para>Â· distribuiÃ§Ã£o de carga</para>
            </listitem>

            <listitem>
              <para>Um objeto, seja cliente ou servidor, Ã© definido em uma
              IDL, que Ã© a linguagem padrÃ£o entendida pelo ORB. Cada linguagem
              possui um engine responsÃ¡vel por gerar os stubs (cliente) e
              skeletons (implementaÃ§Ã£o de objeto) correspondentes Ã quela
              linguagem a partir da IDL que foi definida. Uma vez gerados os
              stubs e skeletons, e depois que o objeto tiver sido
              implementado, um cliente faz uma requisiÃ§Ã£o de um mÃ©todo de um
              objeto que pode estar local ou remoto. O acesso ao objeto Ã©
              feito via ORB.</para>
            </listitem>

            <listitem>
              <para></para>
            </listitem>

            <listitem>
              <para>Organizar (centralizar/agrupar) nomes de hosts (associados
              a endereÃ§os IPs) em uma hierarquia de domÃ­nios para permitir a
              localizaÃ§Ã£o de servidores atravÃ©s da rede. Sem o DNS, nÃ£o seria
              possÃ­vel identificar um servidor atravÃ©s de seu nome. Isso sÃ³
              seria possÃ­vel atravÃ©s do nÃºmero IP do mesmo.</para>
            </listitem>

            <listitem>
              <para>A aplicaÃ§Ã£o solicita o endereÃ§o IP de um servidor ao DNS
              local. Se este souber o ip, ele lhe devolve, senÃ£o, ele faz uma
              requisiÃ§Ã£o ao servidor autoritativo do domÃ­nio. Esse pode
              conhecer o servidor procurado e devolver o endereÃ§o IP, ou
              fornecer o endereÃ§o de alguÃ©m que o conheÃ§a. Quando o endereÃ§o
              for localizado o DNS local o envia Ã  aplicaÃ§Ã£o que o
              solicitou.</para>
            </listitem>

            <listitem>
              <para>domÃ­nio: todas as mÃ¡quinas que estÃ£o abaixo do servidor de
              DNS</para>

              <para>Autoritativo para a zona: conhece os IPs de todas as
              mÃ¡quinas da zona para qual ele Ã© autoritarivo</para>
            </listitem>

            <listitem>
              <para>Vantagens:</para>

              <para>Â· Possibilidade de montar um sistema de arquivos via rede
              de maneira transparente como se fosse local.</para>

              <para>Â· DiretÃ³rios podem ser montados no momento do boot</para>

              <para>Â· Dados ficam centralizados em um Ãºnico host</para>

              <para>O VFS Ã© uma camada de abstracao de "alto-nÃ­vel" onde
              sistemas de arquivos de diferentes tipos sÃ£o montados sob uma
              mesma Ã¡rvore (ext3, reiser, iso9660, vfat, ntfs, hfs e qualquer
              outro suportado pelo kernel). NFS Ã© montado transparentemente
              como se fosse um sistema de arquivos local, basta que ele
              implemente a API do VFS.</para>
            </listitem>

            <listitem>
              <para>O NIS Ã© uma base de dados que armazena informaÃ§Ãµes
              compartilhadas dentro de uma rede local como usuÃ¡rios, senhas,
              hosts que fazem parte da rede, etc. O NIS faz com que a rede
              seja vista como um sistema Ãºnico onde todas as contas de usuÃ¡rio
              sÃ£o as mesmas em todos os hosts, mantÃ©m a sincronizaÃ§Ã£o das
              informaÃ§Ãµes compartilhadas entre os hosts e provÃª transparÃªncia
              da rede para os usuÃ¡rios.</para>
            </listitem>

            <listitem>
              <para>A relaÃ§Ã£o Ã© que ambos sÃ£o serviÃ§os de um sistema
              operacional de rede, mas o NIS contÃ©m informaÃ§Ãµes relacionadas Ã 
              configuraÃ§Ã£o do sistema da rede local, enquanto o DNS contÃ©m
              informaÃ§Ãµes sobre uma hierarquia de hosts (e IPS). A filosofia
              de uso de cada um Ã© diferente.</para>
            </listitem>

            <listitem>
              <para>NÃ£o. Os domÃ­nios NIS exportam uma coleÃ§Ã£o de informaÃ§Ãµes
              de configuraÃ§Ã£o do sistema para um conjunto de mÃ¡quinas. Eles
              tÃªm funÃ§Ã£o puramente administrativa, nÃ£o sÃ£o organizados
              hierarquicamente, nÃ£o sÃ£o compartilhados e nÃ£o podem ser vistos
              por usuÃ¡rios que nÃ£o pertenÃ§am ao domÃ­nio.</para>
            </listitem>

            <listitem>
              <para>Porque nÃ£o Ã© possÃ­vel encontrar um sistema operacional de
              rede para ser comprado como um pacote fechado, como acontece com
              os sistemas operacionais comuns. O NOS Ã© um conjunto de serviÃ§os
              que formam um sistema operacional mais complexo que pode ser
              executado em sistemas distribuÃ­dos.</para>
            </listitem>

            <listitem>
              <para>Ã implementado atravÃ©s de chamadas RPC o que o torna
              stateless (nÃ£o mantÃ©m estados entre as requisiÃ§Ãµes. Vantagem:
              menos overhead de comunicaÃ§Ã£o (UDP), e resolve problemas de
              sincronizaÃ§Ã£o (p/. ex. caso um cliente ou servidor tenha
              problemas).</para>
            </listitem>

            <listitem>
              <para>O cliente NIS faz uma chamada a um procedimento, por
              exemplo para listar um diretÃ³rio. Para o cliente NIS, esse
              procedimento estÃ¡ local, mas a requisiÃ§Ã£o Ã© passada para o
              servidor NIS que executa o pedido e devolve a resposta ao
              cliente.</para>
            </listitem>

            <listitem>
              <para>Os servidores de domÃ­nio precisam teoricamente consultar o
              .com para resolver um domÃ­nio .com que nÃ£o esteja cacheado ou
              nÃ£o seja conhecido de outra forma. Para isto precisam recorrer
              algumas vezes ao servidor autoritativo .com e para tal, precisam
              encontrÃ¡-lo como uma entrada no DNS. Se esta entrada for
              alterada, Ã© necessÃ¡rio que ela seja atualizada (automaticamnente
              ou nÃ£o) nos servidores de DNS locais. NÃ£o Ã© usual, mas o ".com"
              e o "." mudam de IP em caso excepcionais como aconteceu mÃªs
              passado quando houve um ataque de DOS (denial of service) na
              rede onde fica o servidor primÃ¡rio de DNS do "." (lembrar que
              para todo e qualquer domÃ­nio hÃ¡ pelo menos um servidor primÃ¡rio
              e um secundÃ¡rio).</para>
            </listitem>
          </orderedlist>
        </listitem>
      </itemizedlist>
    </section>
  </chapter>

  <chapter id="individual_assignments" role="assignments">
    <title>Individual Assignments - Laboratory</title>

    <section id="individual_assignments_trying_sunos">
      <title>Trying the SunOS</title>

      <orderedlist>
        <listitem>
          <para>FaÃ§a boot local no micro.</para>
        </listitem>

        <listitem>
          <para>Rode telnet e log numa mÃ¡quina Unix</para>
        </listitem>

        <listitem>
          <para>Rode o X server no micro. No Unix set a variÃ¡vel DISPLAY para
          a sua mÃ¡quina:</para>

          <programlisting>&gt; setenv DISPLAY "IP da sua mÃ¡quina": 0
&gt; xterm&amp;</programlisting>

          <para>Para descobrir o IP da sua mÃ¡quina olhe em Start -&gt;
          Settings -&gt; Control Panel.</para>

          <para>Click em Network , Double Click em TCP/IP e vocÃª verÃ¡ endereÃ§o
          NÃO MODIFIQUE!</para>

          <para>Qual a vantagem de se usar um X server sobre o programa
          telnet?</para>
        </listitem>

        <listitem>
          <para>Navegue no File System Unix.</para>
        </listitem>

        <listitem>
          <para>Marque os FS que estÃ£o sendo montados remotamente na oca e na
          ceci. Olhe em /etc/fstab.</para>
        </listitem>

        <listitem>
          <para>Identifique um link. Anote-o e explique o que m link.</para>
        </listitem>

        <listitem>
          <para>Verifique os processos que estÃ£o rodando ( ps -aux ).
          Identifique os seus.</para>
        </listitem>

        <listitem>
          <para>Tente localizar e logar em outras mÃ¡quinas na rede.</para>
        </listitem>

        <listitem>
          <para>Verifique o arquivo de passwords em duas mÃ¡quinas diferentes
          (/etc/passwd). Responda: Qual o formato do arquivo /etc/passwd
          ?</para>
        </listitem>

        <listitem>
          <para>FaÃ§a uma descriÃ§Ã£o do ambiente definido para sua Ã¡rea ( env
          ).</para>
        </listitem>

        <listitem>
          <para>O que Ã© um Ã¡lias? Insira um Ã¡lias diferente (com o nome de um
          membro do grupo) no seu de ambiente.</para>
        </listitem>

        <listitem>
          <para>Identifique cada um dos arquivos de definiÃ§Ã£o de ambiente
          (.login e .cshrc). Explique a funÃ§Ã£o de cada um.</para>
        </listitem>
      </orderedlist>
    </section>

    <section id="individual_assignments_pipes">
      <title>Pipes</title>

      <itemizedlist>
        <listitem>
          <para>Pipes</para>
        </listitem>
      </itemizedlist>

      <orderedlist>
        <listitem>
          <para>O exemplo abaixo ilustra a utilizaÃ§Ã£o de pipes dentro de um
          mesmo processo. Rode-o e explique o seu funcionamento.</para>

          <programlisting>main()
{
   int pipefd[2], n;
   char buff[100];
   
   if (pipe(pipefd) &lt; 0)
      printf("pipe error");

   printf("read fd = %d, write fd = %d\n", pipefd[0], pipefd[1]);
   if (write(pipefd[1], "hello world\n", 12) != 12)
      printf("write error");

   if ((n = read(pipefd[0], buff, sizeof(buff))) &lt;= 0)
      printf("read error");

   write(1, buff, n);      /* fd 1 = stdout */

   exit(0);
}</programlisting>
        </listitem>

        <listitem>
          <para>Exemplo abaixo mostra um sistema produtor/consumidor.
          Compile-o e rode. Explique o funcionamento do sistema, detalhando as
          aÃ§Ãµes do pai e do filho. FaÃ§a um diagrama (edite o desenho com
          caracteres ASCII) explicando o funcionamento.</para>

          <programlisting>
#include stdio.h
#include errno.h 
#include sys/errno.h 
#define MAXBUFF 1024 main() 
{
    int childpid, pipe1[2], pipe2[2]; 
    printf("Inicio do programa Client_Server\n\n");
    if (pipe(pipe1) menor 0 || pipe(pipe2) &lt; 0)
    { 
       perror("can't create pipes");
       exit(0); 
    } 
    printf("Os pipes foram criados corretamente\n"); 
    if ((childpid = fork()) &lt; 0) 
    {
       perror("can't fork"); 
    } 
    else if (childpid &gt; 0) 
    { 
      /* parent */
      close(pipe1[0]); 
      close(pipe2[1]); 
      client(pipe2[0], pipe1[1]); 
      while (wait((int *) 0) != childpid); 
      /* wait for child */ 
      close(pipe1[1]); 
      close(pipe2[0]); 
      exit(0); 
    } 
    else 
   {
     /* child */ 
     close(pipe1[1]); 
     close(pipe2[0]); 
     server(pipe1[0], pipe2[1]); 
     close(pipe1[0]); 
     close(pipe2[1]); 
     exit(0); 
   }
}
 /* Esta e' a funcao cliente */ 

client(int readfd, intwritefd) 
{ 
   char buff[MAXBUFF];  
   int n;       
/* 
* Read the filename from standard input, 
* write it to the IPC descriptor. 
*/ 
   if (fgets(buff, MAXBUFF, stdin) == NULL) 
      perror("client: filename read error"); 

   n = strlen(buff); 
   if (buff[n-1] == '\n') 
      n--;     /* ignore newline from fgets() */ 

   if (write(writefd, buff, n) != n) 
      perror("client: filename write error"); 

/* 
* Read the data from the IPC descriptor and write 
* to standard output. 
*/ 

   while ((n = read(readfd, buff, MAXBUFF)) &gt; 0) 
   if (write(1, buff, n) != n)             /* fd 1 = stdout */ 
      perror("client: data write error"); 
   if (n m &lt; 0) 
   { 
      perror("client: data read error"); 
   } 
} 

/* Esta e' a funcao servidor */ 
server(int readfd, int writefd) 
{ 
    char buff[MAXBUFF]; 
    char errmesg[256]; 
    int n; 
    long int fd; 
    extern int errno; 
    extern char *sys_errlist[]; 

/* 
* Read the filename from the IPC descriptor. 
*/

    if ((n = read(readfd, buff, MAXBUFF)) &lt; = 0) 
       perror("server: filename read error"); 
    buff[n] = '\0';      /* null terminate filename */ 
    if ((fd = open(buff, 0)) &lt; 0) 
    { 
      /* 
       * Error. Format an error message and send it back 
       * to the client.
       */ 
       sprintf(errmesg, ":can't open.\n"); 
       strcat(buff, errmesg); 
       n = strlen(buff); 
       if (write(writefd, buff, n) != n) 
         perror("server: errmesg write error"); 
    } 
    else 
    { 
      /* 
       * Read the data from the file and write to 
       * the IPC descriptor. 
       */ 
       while ((n = read(fd, buff, MAXBUFF)) &gt; 0) 
       if (write(writefd, buff, n) != n) 
          perror("server: data write error"); 
       if (n &lt; 0) 
       {
          perror("server: read error"); 
       } 
    } 
} </programlisting>
        </listitem>

        <listitem>
          <para>Quais as limitaÃ§Ãµes deste mecanismo de comunicaÃ§Ã£o entre
          processos para a implementaÃ§Ã£o de pares servidor/cliente?</para>
        </listitem>

        <listitem>
          <para>Modifique o exemplo de modo que o servidor seja uma
          calcuradora com as 4 operaÃ§Ãµes aritmÃ©ticas bÃ¡sicas. Projete um
          sistema de entrada/saÃ­da adequado.</para>
        </listitem>
      </orderedlist>
    </section>

    <section id="individual_assignments_threads">
      <title>Threads</title>

      <itemizedlist>
        <listitem>
          <para>Threads</para>

          <para>The following functions are from the Linux threads library
          based on the POSIX 1003.b standard:</para>

          <programlisting>
  pthread_create - Adds a new thread of control to the current process.

  sched_yield - Causes the current thread to yield its execution in 
                favor of another thread with the same or greater priority.

  pthread_exit - Terminates a thread.

  pthread_join - Blocks the calling thread until a specified thread
                terminates.
          </programlisting>
        </listitem>
      </itemizedlist>

      <orderedlist>
        <listitem>
          <para>The following program creates two threads. Each prints the
          name of a city a number of times, with a random delay between the
          prints. Run it a number of times.</para>

          <programlisting>#include &lt;pthread.h&gt;
/* 
* Code of the threads 
*/ 
  void* printPlace(void* name) 
  { 
     int aux1, aux2, aux3, count; 
    /* Find number of loops */ 
     if (strcmp(name, "Jamaica")==0) 
        count= 5; 
     else count=10; 
        /* Main loop */ 
        for (aux1=0; aux1 &lt; count; aux1++) 
        { 
            /* Print Name */ 
            printf("%d %s\n", aux1, name); 
            /* Create a variable delay */ 
            for (aux2= rand()/10000; aux2 &gt; 0; aux2--) 
                for(aux3=10; aux3 &gt; 0; aux3--); 
            /* Yields control */ 
            /* sched_yield(); */ 
        } pthread_exit(0); 
  }
  
  void main()
  { 
      /* Variables that keep the threads ids */ 
         pthread_t simpleThread1, simpleThread2; 
      /* Maximum concurrence level */ 
         pthread_setconcurrency(100); 
         printf("Concurrency %d\n", pthread_getconcurrency()); 
      /* Create first thread */ 
         pthread_create(&amp;simpleThread1, 0, printPlace, "Java"); 
      /* Create second thread */ 
         pthread_create(&amp;simpleThread2, 0, printPlace, "Fiji"); 
      /* Wait until all threads stop */ 
         pthread_join(simpleThread1, 0); pthread_join(simpleThread2, 0); 
      /* Wait until a specific thread stops */ 
      /* pthread_join(simpleThread1, 0); */ 
  } 

          </programlisting>

          <para>To compile the program:</para>

          <programlisting>cc threads.c -o threads -lpthread</programlisting>
        </listitem>

        <listitem>
          <para>Each time you run the program it prints out a random list with
          the cities. Explain how it works What is the function of
          lines:</para>

          <programlisting>pthread_join(simpleThread1, 0);
pthread_join(simpleThread2, 0);          </programlisting>
        </listitem>

        <listitem>
          <para>Uncomment the line:</para>

          <programlisting>/* sched_yield(); */          </programlisting>

          <para>Run the program. What happens? Why?</para>

          <para>Undo the change you have done.</para>
        </listitem>

        <listitem>
          <para>Change the name "Java" on the following line for
          "Jamaica":</para>

          <programlisting>pthread_create(simpleThread1, 0, printPlace,"Java");</programlisting>

          <para>Run the program. Now comment the lines:</para>

          <programlisting>pthread_join(simpleThread1, 0);
pthread_join(simpleThread2, 0);         </programlisting>

          <para>And uncomment the line:</para>

          <programlisting>/*   pthread_join(simpleThread1, 0);       */</programlisting>

          <para>Run the program. What happens to simpleThread1?</para>
        </listitem>
      </orderedlist>
    </section>

    <section id="individual_assignments_threads_synchronization">
      <title>Threads Synchronization</title>

      <itemizedlist>
        <listitem>
          <para>Threads Synchronization</para>
        </listitem>
      </itemizedlist>

      <orderedlist>
        <listitem>
          <para>Compile the following program, explain it. Is it working
          well?</para>

          <programlisting>
        include pthread.h

          float hole= 0;
          int flag=0;

          /*
           *      Code of the threads
           */
          void delay() {
             int aux2;

             for (aux2=600000; aux2&gt;0; aux2--);
             return;
          }

          void delay2() {
             int aux2;

             for (aux2=100000; aux2&gt;0; aux2--);

            return;
          }

          double get() {
             double aux1;

             aux1= hole;
             return aux1;
          }

          double inc() {

             int aux1;
             for (aux1=0;aux1&lt;10;aux1++) {
                hole= hole + 0.100000000;
                delay2();
             }
             return hole;
          }

          void* producer(int* name) {

             int aux1, aux2, aux3, count;


             /*   Main loop       */
             for (aux1=0; aux1&lt;20; aux1++) {

                /*        Print name      */

                printf("Producer inc: %.3f\n", inc());

             }
             pthread_exit(0);
          }

          void* consumer(int* name) {

             int aux1, aux2, aux3;

             /*   Main loop       */
             for (aux1=0; aux1&lt;10; aux1++) {

                /*        Print name      */
                printf("Consumer got: %.3f\n", get());

                /*        Create delay    */
                delay();

             }

            pthread_exit(0);
          }


          void main(){

             /*   Variables that keep the threads ids     */
             pthread_t simpleThread1, simpleThread2;

             int status, aux1, priority;

             int pro1= 0;
             int pro2= 1;


             /*  Maximum concurrence level */
             pthread_setconcurrency(100);
             printf("Concurrency %d\n", pthread_getconcurrency());

             /*   Create first thread     */
             pthread_create(&amp;simpleThread1, 0, producer, (void*) &amp;pro1);

             /*   Create first thread     */
             pthread_create(&amp;simpleThread2, 0, consumer, (void*) 0);

             /*   Wait until all threads stop     */
             pthread_join(simpleThread1, 0);
             pthread_join(simpleThread2, 0);
   }
          </programlisting>

          <para>To compile the program:</para>

          <programlisting>cc threads.c -o threads -lpthread</programlisting>
        </listitem>

        <listitem>
          <para>Add the following lines to the program. What happens?
          Explain.</para>

          <programlisting>#include &lt;pthread.h&gt; 
float hole= 0; 
int flag=0; 
                      <emphasis> pthread_mutex_t lock_hole;</emphasis>
 ..
 double get() 
{
 int aux1;
                      <emphasis> pthread_mutex_lock(&amp;lock_hole);</emphasis>
 aux1= hole; 
                     <emphasis>  pthread_mutex_unlock(&amp;lock_hole); </emphasis>
return aux1; 
} 
double inc() 
{
 int aux1; 
                     <emphasis>  pthread_mutex_lock(&amp;lock_hole);</emphasis> 
for (aux1=0;aux1&lt;10;aux1++) 
{ 
hole= hole + 0.100000000; 
delay2(); 
} 
                  <emphasis>     pthread_mutex_unlock(&amp;lock_hole);</emphasis> 
return hole; 
} 
... void main()
{ 
/* Variables that keep the threads ids */ 
pthread_t simpleThread1, simpleThread2; 
int status, aux1, priority; 
int pro1= 0; 
int pro2= 1; 
                    <emphasis>   pthread_mutex_init(&amp;lock_hole, 0);</emphasis> 

          </programlisting>
        </listitem>

        <listitem>
          <para>Now add the following lines and explain what happens:</para>

          <programlisting>#include &lt;pthread.h&gt; 
float hole= 0;
int flag=0; 
pthread_mutex_t lock_hole; 
                      <emphasis>pthread_cond_t cond_hole;</emphasis>
 ... 
double get() 
{ 
int aux1; 
pthread_mutex_lock(&amp;lock_hole); 
                      <emphasis>pthread_cond_wait(&amp;cond_hole, &amp;lock_hole); </emphasis>
aux1= hole; 
pthread_mutex_unlock(&amp;lock_hole); 
return aux1; 
} 

double inc() 
{ 
int aux1; 
pthread_mutex_lock(&amp;lock_hole); 
for (aux1=0;aux1&lt;10;aux1++) 
{
 hole= hole + 0.100000000; 
delay2(); 
}
                     <emphasis>pthread_cond_signal(&amp;cond_hole); </emphasis>
pthread_mutex_unlock(&amp;lock_hole); 
return hole; 
} 
... 
void main()
{
 /* Variables that keep the threads ids */ 
pthread_t simpleThread1, simpleThread2; 
int status, aux1, priority; 
int pro1= 0; 
int pro2= 1; 
pthread_mutex_init(&amp;lock_hole, 0); 
                     <emphasis>pthread_cond_init(&amp;cond_hole, 0); 
</emphasis>
          </programlisting>
        </listitem>

        <listitem>
          <para>Run the following program and explain it:</para>

          <programlisting>#include &lt;pthread.h&gt;

                float hole= 0;
                int flag=0;
                pthread_mutex_t lock_hole;
                pthread_cond_t  cond_hole;

                /*
                 *      Code of the threads
                 */
                void delay() {
                   int aux2;

                   for (aux2=1000000; aux2&gt;0; aux2--);
                   return;
                }

                void delay2() {
                   int aux2;

                   for (aux2=300000; aux2 &gt; 0; aux2--);
                   return;
                }

                double get() {
                   int aux1;

                   pthread_mutex_lock(&amp;lock_hole);
                   pthread_cond_wait(&amp;cond_hole, &amp;lock_hole);

                   aux1= hole;
                   pthread_mutex_unlock(&amp;lock_hole);
                   return aux1;
                }

                double inc() {

                   int aux1;
                   pthread_mutex_lock(&amp;lock_hole);
                   for (aux1=0;aux1&lt;10;aux1++) {

                      hole= hole + 0.100000000;
                      delay2();
                   }
                   pthread_cond_signal(&amp;cond_hole);
                   pthread_mutex_unlock(&amp;lock_hole);
                   return hole;
                }

                void* producer(int* name) {

                   int aux1, aux2, aux3, count;


                   /*   Main loop       */
                   for (aux1=0; aux1&lt;20; aux1++) {

                      /*        Print name      */
                      printf("Producer%u inc: %.3f\n", *name, inc());

                   }
                   pthread_exit(0);
                }

                void* consumer(int* name) {

                   int aux1, aux2, aux3;

                   /*   Main loop       */
                   for (aux1=0; aux1&lt;10; aux1++) {

                      /*        Print name      */
                      printf("Consumer got: %.3f\n", get());

                      /*        Create delay    */
                      delay();

                   }
                   pthread_exit(0);
                }

                void main(){

                   /*   Variables that keep the threads ids     */
                   pthread_t simpleThread1, simpleThread2;

                   int status, aux1, priority;
                   int pro1= 0;
                   int pro2= 1;

                   pthread_mutex_init(&amp;lock_hole, 0);
                   pthread_cond_init(&amp;cond_hole, 0);

                   /*  Maximum concurrence level */
                   printf("Concurrency %d\n", PTHREAD_THREADS_MAX);

                   /*   Create first thread     */
                   pthread_create(&amp;simpleThread1, 0, producer, (void*)&amp;pro1);

                   /*   Create first thread     */
                   pthread_create(&amp;simpleThread2, 0, consumer, (void*) 0);

                   /*   Wait until all threads stop     */
                   pthread_join(simpleThread1, 0);
                   pthread_join(simpleThread2, 0);
                }

          </programlisting>
        </listitem>

        <listitem>
          <para><emphasis><emphasis role="bold">Note:</emphasis> Change the
          delays in the program and see what happens.</emphasis></para>
        </listitem>
      </orderedlist>
    </section>

    <section id="individual_assignments_stream_sockets">
      <title>Stream Sockets</title>

      <itemizedlist>
        <listitem>
          <para>Stream Sockets</para>
        </listitem>
      </itemizedlist>

      <orderedlist>
        <listitem>
          <para>Run the programs bellow. Make a clear description of the way
          this program works.</para>
        </listitem>

        <listitem>
          <para>What are the advantages of using sockets over named
          pipes?</para>
        </listitem>

        <listitem>
          <para>Rewrite the calculator program you wrote for the last
          laboratory assignment substituting the pipes for sockets .</para>

          <para>Note:</para>

          <para>Compile this programs in a Solaris system using the
          command:</para>

          <programlisting>gcc foo.c -o foo -lsocket -lnsl</programlisting>

          <para>Client Program</para>

          <programlisting>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;stdio.h&gt;

#define DATA "1 2 3 TESTING ... "

main (int argc, char* argv[])
{
   int sock;
   struct sockaddr_in server;
   struct hostent *hp, *gethostbyname();

   sock = socket (AF_INET, SOCK_STREAM, 0);
   if (sock == -1) {
      perror ("Opening stream socket");
      exit (1);
   }

   hp = gethostbyname(argv[1]);

   memcpy ((char*)&amp;server.sin_addr, (char*) hp-&gt;h_addr, hp-&gt;h_length);

   server.sin_family = AF_INET;
   server.sin_port = htons(atoi(argv[2]));

   if ( connect(sock, (struct sockaddr *)&amp;server, sizeof server) == -1) {
      perror("Connecting stream socket");
      exit(1);
   }

   if (write(sock, DATA, sizeof DATA) == -1)
      perror("Writing data to stream socket");

   close (sock);
   exit (0);
}</programlisting>

          <para>Server Program</para>

          <programlisting>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;stdio.h&gt;

#define TRUE 1

main()
{
   int sock, length;
   struct sockaddr_in server;
   int msgsock;
   char buf[1024];
   int rval;

   sock = socket (AF_INET, SOCK_STREAM, 0);
   if (sock==-1) {
      perror( "Opening stream socket");
      exit(1);
   }

   server.sin_family = AF_INET;
   server.sin_addr.s_addr = INADDR_ANY; 
   server.sin_port = 0;
   if (bind (sock, (struct sockaddr *)&amp;server, sizeof(server)) == -1){
      perror("Binding stream socket");
      exit (1);
   }
   length = sizeof server;
   if (getsockname (sock, (struct sockaddr *)&amp;server, &amp;length) == -1){
      perror("Getting socket name");
      exit (1);
   }
   printf("Socket port # %d\n", ntohs(server.sin_port));
   /* Start accepting connections */
   listen( sock, 5);
   do {
      msgsock = accept( sock, (struct sockaddr *) 0, (int*) 0);
      if (msgsock==-1)
         perror("accept");
      else do {
         memset( buf, 0, sizeof buf);
         if (( rval= read( msgsock, buf, 1024)) == -1)
            perror("Reading data stream");
         if (rval == 0)
            printf("Ending connection\n");
         else
            printf( "--&gt;%s\n", buf);
      } while (rval!=0);
      close(msgsock);
   } while (TRUE);
   exit(0);
}</programlisting>
        </listitem>
      </orderedlist>
    </section>

    <section id="individual_assignments_datagram_sockets">
      <title>Datagram Sockets</title>

      <itemizedlist>
        <listitem>
          <para>Datagram Sockets</para>
        </listitem>
      </itemizedlist>

      <orderedlist>
        <listitem>
          <para>Run the programs bellow. Make a clear description of the way
          this program works.</para>
        </listitem>

        <listitem>
          <para>What are the advantages and disadvantages of using Datagram
          sockets over Stream sockets?</para>
        </listitem>

        <listitem>
          <para>Rewrite the calculator program you wrote for the last
          laboratory assignment substituting the pipes for datagram sockets
          .</para>

          <para>Note:</para>

          <para>Compile this programs in a Solaris system using the
          command:</para>

          <programlisting>gcc foo.c -o foo -lsocket -lnsl</programlisting>

          <para>Client Program</para>

          <programlisting>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;stdio.h&gt;
 
#define DATA "Quote"
 
main (int argc, char* argv[])
{
   int sock;
   struct sockaddr_in server;
   struct hostent *hp, *gethostbyname();
   char buf[1024];
 
   sock = socket (AF_INET, SOCK_DGRAM, 0);
   if (sock == -1) {
      perror ("Opening Datagram socket");
      exit (1);
   }
 
   hp = gethostbyname(argv[1]);
   if (hp == (struct hostent *) 0) {
      perror("Unknown Host");
      exit(0);
   }
 
   memcpy ((char*)&amp;server.sin_addr, (char*) hp-&gt;h_addr, hp-&gt;h_length);
 
   server.sin_family = AF_INET;
   server.sin_port = htons(atoi(argv[2]));
 
   if (sendto( sock, DATA, sizeof DATA, 0,
               (struct sockaddr *) &amp;server, sizeof server) == -1) {
      perror("Sending datagram message");
      exit(1);
   }
   if (read( sock, buf, 1024) == -1) {
      perror("Receiving quotation");
      exit(1);
   }
   printf("Quote of the Moment: %s\n", buf);
   close(sock);
}</programlisting>

          <para>Server Program</para>

          <programlisting>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;stdio.h&gt;

#define TRUE 1

int quoteInd= 0;
int quoteNumber= 2;
char* quotes[]= { "lixo1", "lixo2"};

char* getquote() {
   int ind;

   ind= quoteInd;
   quoteInd++;
   if (quoteInd&gt;=quoteNumber) quoteInd=0;
   return quotes[ind];
}

main()
{
   int sock, length;
   struct sockaddr_in server;
   struct sockaddr_in client;
   char buf[16];
   char* quote;

   sock = socket (AF_INET, SOCK_DGRAM, 0);
   if (sock==-1) {
      perror("Opening datagram socket");
      exit(1);
   }

   server.sin_family = AF_INET;
   server.sin_addr.s_addr = INADDR_ANY; 
   server.sin_port = 0;
   if (bind (sock, (struct sockaddr *)&amp;server, sizeof(server)) == -1){
      perror("Binding datagram socket");

      exit (1);
   }
   length = sizeof server;
   if (getsockname (sock, (struct sockaddr *) &amp;server, &amp;length) == -1){
      perror("Getting socket name");
      exit (1);
   }
   printf("Socket port # %d\n", ntohs(server.sin_port));
   
   do{
      if ( recvfrom( sock, buf, 16, 0,
                    (struct sockaddr *) &amp;client, &amp;length) == -1){
         perror("Reading packet");
         exit(1);
      }
      quote= getquote();
      if ( sendto( sock, quote, strlen(quote)+1, 0,
                   (struct sockaddr *) &amp;client, sizeof client) == -1) {
         perror("Writing quota");
         exit(0);
      }
   } while (TRUE);
}          </programlisting>
        </listitem>
      </orderedlist>
    </section>

    <section id="individual_assignments_remote_procedure_calls">
      <title>Remote Procedure Calls</title>

      <itemizedlist>
        <listitem>
          <para>Remote Procedure Calls</para>

          <para>The task is to implement the Time server using RPCs. It has
          two procedures <emphasis>bin_time</emphasis> , that returns the
          current time as a long int, and <emphasis>str_time</emphasis>, that
          convert the time from long int to string.</para>
        </listitem>
      </itemizedlist>

      <orderedlist>
        <listitem>
          <para>Compile the following XDR description of the
          procedures:</para>

          <programlisting>
        program TIME_PROG {
            version TIME_VERS {
                long BIN_TIME(void) = 1;   /* Procedure number 1 */
                string STR_TIME(long) = 2; /* Procedure number 2 */
            } = 1;                         /* Version number 1   */
        } = 0x31234567;                    /* Program number 0x31234567 */
          </programlisting>
        </listitem>

        <listitem>
          <para>Use rpcgen to generate the stub files, sample files and
          Makefile:</para>

          <programlisting>rpcgen -a -C time.xdr          </programlisting>
        </listitem>

        <listitem>
          <para>Add to the sample files the code to implement the
          application:</para>

          <para>To the server file:</para>

          <programlisting>        long * bin_time_1_svc(void *argp, struct svc_req *rqstp)
        {
                static long  result;

               
                result= time((time_t *) 0);
               

                return (&amp;result);
        }

        char ** str_time_1_svc(long *argp, struct svc_req *rqstp)
        {
                static char * result;
                
               
                static tstr[128];
                long t, hour, min, sec;

                t= *argp;
                sec= t % 60;   t /= 60;
                min= t % 60;   t /= 60;
                hour= t % 24;
                sprintf(tstr, "hora %u:%u:%u", hour, min, sec);
                result= tstr;
               

                return (&amp;result);
        }      </programlisting>

          <para>To the client file:</para>

          <programlisting>        void time_prog_1(char *host)
        {
            ...
            result_1 = bin_date_1((void *)&amp;bin_date_1_arg, clnt);
            if (result_1 == (long *) NULL) 
                clnt_perror(clnt, "call failed");
            result_2 = str_date_1((long *) result_1, clnt);
            if (result_2 == (char **) NULL)
                clnt_perror(clnt, "call failed");

                           printf("Time: %u %s\n", *result_1, *result_2);

                       }
         ... </programlisting>
        </listitem>

        <listitem>
          <para>Compile and run the application:</para>

          <programlisting>make makefile.time </programlisting>
        </listitem>

        <listitem>
          <para>Make a clear description of the way this program works.</para>
        </listitem>

        <listitem>
          <para>What are the advantages and disadvantages of using RPCs over
          sockets?</para>
        </listitem>

        <listitem>
          <para>Rewrite the calculator program you wrote for the last
          laboratory assignment substituting the datagrams sockets for
          RPCs.</para>
        </listitem>
      </orderedlist>
    </section>
  </chapter>

  <chapter id="group_assignments" role="assignments">
    <title>Group Assignments - Homeworks</title>

    <section id="group_assignments_message_server">
      <title>Message Server</title>

      <itemizedlist>
        <listitem>
          <para>Message Server</para>

          <para>This program should implement a message system similar to ICQ.
          It has to implement (at least) the following features:</para>

          <itemizedlist>
            <listitem>
              <para>Text client using ncourses (a Linux library to work with
              xterm). A graphic X11 based client is optional.</para>
            </listitem>

            <listitem>
              <para>Warning for users when a new user comes online or goes
              offline.</para>
            </listitem>

            <listitem>
              <para>A command (or text window) to show who is online at the
              moment.</para>
            </listitem>

            <listitem>
              <para>The ability to send messages to a particular user. Sending
              messages to a group of users is optional.</para>
            </listitem>

            <listitem>
              <para>The ability to leave messages to offline users. When this
              users come online they will see the messages.</para>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">NOTE:</emphasis> The program must use
          shared memory and threads in its implementation (take care to
          protected shared memory areas with mutex and/or semaphores). The
          program does not need to keep information on files, it does not have
          to be persistent.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="group_assignments_lisp_server">
      <title>Lisp Server</title>

      <itemizedlist>
        <listitem>
          <para>This program should implement a LISP interpreter that is able
          to get LISP commands from a Telnet connection and send back its
          results also through the same Telnet connection. The server must be
          able to handle more than one client at the same time.</para>

          <para>The LISP interpreter must be able to parse and execute, at
          least, the following lisp commands:</para>

          <programlisting>(CAR list&gt;)               X= &lt;string&gt;,&lt;list&gt;
(CDR &lt;list&gt;)
(LIST X {X} )
(SET &lt;string&gt; X)
(GET &lt;string&gt;)          </programlisting>

          <para>For instance:</para>

          <para><emphasis>Client:</emphasis> (LIST A B 2)</para>

          <para><emphasis>Server:</emphasis> (A B 2)</para>

          <para><emphasis>Client:</emphasis> (CAR (LIST A B 2))</para>

          <para><emphasis>Server:</emphasis> A</para>

          <para><emphasis>Client:</emphasis> (CDR (LIST A B 2))</para>

          <para><emphasis>Server:</emphasis> (B 2)</para>

          <para><emphasis>Client:</emphasis> (SET LIXO AB)</para>

          <para><emphasis>Server:</emphasis> AB</para>

          <para><emphasis>Client:</emphasis> (GET LIXO)</para>

          <para><emphasis>Server:</emphasis> AB</para>

          <para><emphasis>Client:</emphasis> (CAR (CDR (LIST AB CD
          EF)))</para>

          <para><emphasis>Server:</emphasis> CD</para>

          <para><emphasis>Client: </emphasis>(CDR (CAR (LIST (LIST HY HJ I)
          HJ)))</para>

          <para><emphasis>Server:</emphasis> (HJ I)</para>

          <para><emphasis role="bold">NOTE:</emphasis> The program must use
          shared memory and threads in its implementation (take care to
          protected shared memory areas with mutex and/or semaphores). The
          LISP variables should be accessed by all users at the same time. The
          program does not need to keep information on files, it does not have
          to be persistent.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="group_assignments_sql_server">
      <title>SQL Server</title>

      <itemizedlist>
        <listitem>
          <para>SQL Server</para>

          <para>This program should implement a SQL interpreter that is able
          to get SQL commands from a Telnet connection and send back its
          results also through the same Telnet connection. The server must be
          able to handle more than one client at the same time.</para>

          <para>The server has to implement, at least, the following SQL
          commands:</para>

          <programlisting>CREATE TABLE table_name (
col_name &lt;type&gt;,
 . . .)

DROP TABLE table_name

INSERT INTO table_namcol_name1, col_name2, ...)
     VALUES (value1, value2, ...)

DELETE FROM table_name WHERE col_name &lt;operator&gt; value
        [ AND|OR col_name &lt;operator&gt; value ]

SELECT FROM table_name WHERE col_name &lt;operator&gt; value
     [ AND|OR col_name &lt;operator&gt; value ]

&lt;type&gt; can be: string.

&lt;operator&gt; can be: =.</programlisting>

          <para>For more information about SQL syntax see an IBM SQL guide
          &lt;http://ts.adm.ilstu.edu/cgi-bin/bookmgr/bookmgr.cmd/BOOKS/DSNAP0B2/1.2&gt;.</para>

          <para><emphasis role="bold">NOTE:</emphasis> The program must use
          shared memory and threads in its implementation (take care to
          protected shared memory areas with mutex and/or semaphores). The
          tables are visible for all users. The program does not need to keep
          information on files, it does not have to be persistent.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="group_assignments_chat_server">
      <title>Chat Server</title>

      <itemizedlist>
        <listitem>
          <para>Chat Server</para>

          <para>The program should implement a chat server that is able to
          attend multiple clients at the same time. It can be implemented by
          either using a dedicated client or using the <programlisting>telnet</programlisting>
          program. It should be able to have at least 10 rooms for
          conversation. The clients should be able to create new rooms.</para>

          <programlisting>
Commands:

list                        List the names of all rooms.
nickname &lt;name&gt;             Gives a name for the user.
join &lt;room name&gt;            Joins a room.
\                           Leaves a room (only command possible inside a room).

Events that should be broadcasted for all room members:

New user enters room.
Whatever a user types.
User leaves room.

Examples:

User hotair enters room pingpong.
User niceperson: Welcome hotair !
User hotair: Hi.
...
User hotair: I don't like you, niceperson.
User hotair leaves room pingpong.
          </programlisting>

          <para><emphasis role="bold">NOTE:</emphasis> The program must use
          shared memory and threads in its implementation (take care to
          protected shared memory areas with mutex and/or semaphores). The
          program does not need to keep information on files, it does not have
          to be persistent.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="group_assignments_bus_reservation_server">
      <title>Bus Reservation Server</title>

      <itemizedlist>
        <listitem>
          <para>Bus Reservation Server</para>

          <para>This program should implement a server that is able to do
          bookings for a bus service company. The server has to hold a
          database (free implementation) with all buses' routes. This database
          has to hold at least the following information for each
          route:</para>

          <para>For instance:</para>

          <programlisting>Route 1:Initial City  -  Stopovers      -      Final Destination
 Rib. Preto   S.Carlos, Araraq.   Catanduva
Bus1         6:00          7:00     7:30         8:30
Bus2        11:00         12:00    12:30      13:30
Bus3        15:00         16:00    16:30      17:30

Bus1:
Seat     Rib. Preto     S.Carlos, Araraq.   Catanduva
  01            X--------Ocupied-------X
  02                                  X-------Ocupied-----X
  03            X---Ocupied---X        X--Ocupied-X
  04          </programlisting>

          <para>The client should be able to execute at least the following
          commands:</para>

          <para>list1 &lt;Departure City&gt; &lt;Destination&gt; : It shows
          the available buses and number of seats in each bus connecting the
          two destinations:</para>

          <programlisting>list1 RibPreto SCarlos

Bus1   6:00   7:00   12 seats
Bus2  11:00  12:00    4 seats
Bus3  15:00  16:00    8 seats
</programlisting>

          <para>list2 &lt;Departure City&gt; &lt;Destination&gt; &lt;Bus&gt;:
          It shows the available seats in a particular bus connecting the two
          destinations:</para>

          <programlisting>list2 RibPreto SCarlos Bus2

Bus2  2 34 35 40</programlisting>

          <para>get &lt;Departure City&gt; &lt;Destination&gt; &lt;Bus&gt;
          &lt;seat&gt;: It books a particular seat for a passenger (It can
          return OK or failure):</para>

          <programlisting>get RibPreto SCarlos Bus2 34

OK: RibPreto 11:00 SCarlos 12:00 Bus2 34
</programlisting>

          <para>cancel &lt;Departure City&gt; &lt;Destination&gt; &lt;Bus&gt;
          &lt;seat&gt;: It cancels a particular seat for a passenger (It can
          return OK or failure):</para>

          <programlisting>cancel RibPreto SCarlos Bus2 34

OK: RibPreto 11:00 SCarlos 12:00 Bus2 34           </programlisting>

          <para>The server should be able to book and to cancel slots. If a
          seat is booked between Rib. Preto and S. Carlos, it should be able
          to book the same seat between S. Carlos and Catanduva.</para>

          <para>NOTE: The program must use shared memory and threads in its
          implementation (take care to protected shared memory areas with
          mutex and/or semaphores). The program does not need to keep
          information on files, it does not have to be persistent.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="group_assignments_linux_threads_seminar">
      <title>Linux Threads Seminar</title>

      <itemizedlist>
        <listitem>
          <para>Linux Threads Seminar</para>

          <itemizedlist>
            <listitem>
              <para>The current Linux thread implementation (kernel
              2.4.x).</para>
            </listitem>

            <listitem>
              <para>Its advantages and disadvantages.</para>
            </listitem>

            <listitem>
              <para>The two new thread proposed implementations (for future
              kernel 2.6.x).</para>
            </listitem>

            <listitem>
              <para>Their advantages and disadvantages.</para>
            </listitem>

            <listitem>
              <para>The advantages of the new implementations over the
              old.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>

    <section id="group_assignments_mac_os_x_seminar">
      <title>Mac OS X Seminar</title>

      <itemizedlist>
        <listitem>
          <para>Mac OS X Seminar</para>

          <itemizedlist>
            <listitem>
              <para>An introduction about the Mach microkernel.</para>
            </listitem>

            <listitem>
              <para>The Mac OS X kernel implementation (Darwin).</para>
            </listitem>

            <listitem>
              <para>The differences between Mac OS X and Linux.</para>
            </listitem>

            <listitem>
              <para>The differences between Mac OS X and Windows.</para>
            </listitem>

            <listitem>
              <para>The Mac OS X graphic interface (Aqua).</para>
            </listitem>

            <listitem>
              <para>The advantages and disadvantages over the X Windows (Linux
              graphic interface).</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>
  </chapter>
</book>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-default-dtd-file:"/home/ldp/SGML/emacs/book-cnc-2.0.ced"
End:
-->