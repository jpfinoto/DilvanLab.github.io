<!-- Generated by Harlequin Webmaker 2.1.3; Harlequin Transducer 1.0 --> 
<html> <head>
<title>Routing</title>
</head>
<body BGCOLOR="#FFFFFF">
<a NAME="HEADING1"></a>

<h1><a NAME="MARKER-9-3"></a>Chapter 7: Routing</h1>
<hr>
<a NAME="HEADING1-1"></a>
<h1>7.1  Introduction</h1>
 The Router <i>agent server</i> performs all the circuit wiring in the <b>Agents</b> system. The Router server interface and communication aspects were discussed in chapter <a HREF="#nonexistent-marker">4</a>. This chapter focusses on the routing routines used by the server. <p>
 The Router server receives, from its clients, circuits in EDIF format <a HREF="#nonexistent-marker">[55]</a> with all components already placed. These circuits are then routed and returned to the client. <p>
 The Router server basically tries to mimic the way human designers use a simple CAD (Computer Aided Design) system to route circuits. The designer makes all the important decisions about design, such as where the wires are going to and about the quality of the routing. The designer decides if a subnet is well wired or if it needs rewiring (for instance, because it is blocked). CAD offers the designer a tool to represent and manipulate the design. It embeds tools to change the way wires are connected and to calculate important constraints, such as the size of a wire or process rule transgressions. The designer is in charge of the decision making process and the CAD system offers the medium and facilities to implement his or her decisions (fig. <a HREF="#nonexistent-marker">7.1</a>).<p>
<img SRC="router1.gif" WIDTH="552" HEIGHT="328"> <p>
 In the Router server, the designer's role is carried out by the RouterExpert <i>agent object</i> and the other agents under its supervision, and the CAD role is carried out by the Design objects.<p>
<a NAME="HEADING1-6"></a>
<h1>7.2  The CAD role</h1>
 The Design object (DesignCmp) holds the design medium and the methods to analyse or change it. It carries out the CAD role providing the RouterExpert agent with the means to collect information about the design and to implement its decisions about the routing process. <p>
 In addition to holding the design data, the Design object has two groups of methods to performs its other functions: <i>building</i> methods, for changing the design data, and <i>retrieve</i> methods, for collecting information. <p>
<a NAME="HEADING1-9"></a>
<h2>7.2.1    Retrieve methods</h2>
 The methods in this group collect information about the design. Their search can be based on a component's individual characteristic, some spacial relationships among components or some spacial constraint, such as distance. These methods can return boolean statements, references to components and spacial information. <p>
 For example, there are three methods for searches based on individual characteristics: The <code>getByNumber</code> and <code>getByReference</code> methods that find a component based on its number or reference value, and the <code>getByWire</code> method that returns the component that owns a particular wire.<p>
 The two more important spacial relationships are crash and touch. A crash happens when any section of a new wire breaks any design rule in relation to any section belonging to any wire already in the design. A touch happens when a proposed wire section touches any section belonging to any wire in a list, both sections should be in a wiring layer (poly, metal1 or metal2).<p>
<img SRC="router2.gif" WIDTH="576" HEIGHT="310"><p>
The main methods to test the relationships are:<p>
<ul>
<li>The <code>getCrashes</code> methods test if a new wire crashes with any other in the design. They return true if there is a crash. Optionally they can return a reference list pointing to all components (and the wires in them) that crashes with the new wire. These methods can take a list of areas where not to test for crashes, generally these areas cover the attachment points of a new wire.<p>
<li>The <code>getCrashesPointer</code> method (fig. <a HREF="#nonexistent-marker">7.3</a>) tests if a pointer, generally created at an edge of a wire, representing a wire, that spreads in a defined direction and has infinite length, crashes with any component in the design. It returns true if there are any crashes and a list with all wires in the circuit that crashed into it. The list elements include the component holding the wire, the wire section where the crash took place and the distance from the vector origin to the crash. This list is ordered by distance, the closest crash report coming first.<p>
<img SRC="router3.gif" WIDTH="559" HEIGHT="368"><p>
<li>The <code>getWiringLayersTouchPointer</code> method tests if a pointer with a certain width and infinite length touches any component in a list. It returns true if there are any touches and a list with all wires that touched the vector. Only wiring layers (poly, metal1 and metal2) are considered. The returned list is ordered by the distance from the pointer's origin to the touch point, the smallest first. The list elements hold the component, the wire, the wire's section and the distance for each touching event.<p>
<img SRC="router4.gif" WIDTH="563" HEIGHT="346"><p>
</ul>
 Finally, the following methods return information based on spacial constraints (fig. <a HREF="#nonexistent-marker">7.5</a>):<p>
<ul>
<li>The <code>getNetEnvelope</code> method finds a rectangle that contains a net. This rectangle is used to evaluate the size and how big a net is.<p>
<li>The <code>getClosestWiringPoints</code> method finds the two closest points between two subnets.<p>
</ul>
<img SRC="router5.gif" WIDTH="563" HEIGHT="350"><p>
<a NAME="HEADING1-19"></a>
<h2>7.2.2    Building methods</h2>
 The Design object's second function, which is to implement the designer decisions on the design, is performed by the building methods. This group of methods adds elements to the design and can conduct construction tasks that are not complex enough to demand the help of an expert system. The methods are:<p>
<ul>
<li>The <code>changeLayer</code> method finds a wire that takes another wire from one layer to another. This new wire is usually appended to the old one. First, this method finds the via geometry for changing the layers and includes finding the via layer type (Contact or Via) and the minimum sizes of a sandwich of squares from the two layers and the via in between them (fig. <a HREF="#nonexistent-marker">7.6</a>). This sandwich has to be connected to the old wire. The routine tries to place the sandwich in various positions around the old wire end. To speed up the process, a big sandwich is generated covering the total area where the placements will be tried. Using the method <code>getCrashes</code>, a list pointing to all components (and wires) that crash with this big sandwich is generated. Only the components on this list will then be tested when the method tries to place the small sandwich (fig. <a HREF="#nonexistent-marker">7.6</a>).<p>
<img SRC="router6.gif" WIDTH="556" HEIGHT="423"><p>
<li>The <code>makeConnection</code> method tries to connect two wires. If the end of the first wire and the point of connection on the second one are from the same layer, the routine just tries to add a segment connecting the two. If there are crashes it returns false. If the two connection points are in two different layers, the routine tries to add a segment from the first wire to near the place of connection. If this wire segment crashes, smaller ones are tried. At the end of this segment, the routine tries to take the wire to the same layer of the point of contact in the second wire using the method <code>changeLayer</code>. If successful, it adds one more segment to connect the two wires. If there are any obstructions between the two wires the method fails, because it is not supposed to navigate around obstructions.<p>
<li>The <code>connectInSameLayer</code> method wires all points that are on the same layer and can be connected using a straight wire without any layer change. The method is called for a specific layer. It tests all nodes, trying to interconnect all subnets that have wires with segments on the target layer. At the early stage of routing the subnets have only the component's terminals, which are very small wires (just one segment), and sometimes a small straight wire connecting two terminals. In a latter stage of routing this kind of extensive search would be too costly.<p>
<li>The <code>makeDifusionToMetal1</code> method adds a wire extension to all subnets that have only diffusion wires to connect them to Metal1. This routine tests all subnets, from all nodes not yet completely routed, and finds the ones using only diffusion layers. It then tries to change them to Metal1 using the method <code>changeLayer</code>. <p>
</ul>
<a NAME="HEADING1-25"></a>
<h1>7.3  <a NAME="MARKER-9-4"></a>The Designer role</h1>
 The Designer role is carried out by the RouterExpert and Connect <i>agent object</i>s. They are in charge of the decision making process. Their function is to control the way the routing is undertaken using the facilities provided by the Design object.<p>
 The combination of the two agents performs an augmented maze route algorithm. Maze routing was first described by Moore <a HREF="#nonexistent-marker">[67]</a>. Moore routing is performed over a rectangular grid of cells, with some cells free and others blocked. Basically, the algorithm finds the shortest path between two predefined cells that does not pass through any blocked cell. It begins at a start cell, repeatedly expanding outwards to neighbouring cells until the destination is reached. When the goal is reached the complete path can be tracked back to the start point (fig. <a HREF="#nonexistent-marker">7.7</a>).<p>
<img SRC="router7.gif" WIDTH="508" HEIGHT="305"><p>
 Maze routing can be easily generalized, the notion of expanding to neighbours works with any graph, not only with rectangular arrays. The algorithm is almost always enhanced with a cost function, incorporating factors such as preferred routing directions and the cost of layers and vias. Instead of expanding uniformly in all directions, only the most promising, least cost partial path is expanded in each interaction. In place of the shortest path, found in the original form of the algorithm, this enhanced form provides least cost solutions.<p>
 Another performance optimization, which can be employed in the algorithm, is expansion directly to the next <i>interesting</i> <i>point</i> <a HREF="#nonexistent-marker">[68]</a>, where a change in direction or layer is more likely. This saves times skipping over less interesting parts of the layout and, more importantly, by eliminating the need to process data at the costly level of pixels, processing is performed directly on the circuit description held by a Design object.<p>
 A point is defined as <i>interesting</i> when it aligns with the goal point, obstacles' edges or crosses obstacles' sides (fig. <a HREF="#nonexistent-marker">7.8</a>). In the case of obstacles, the edge and sides considered are the ones of the area that overlap the obstacle by a margin. This margin is equal to the minimum separation between the layers of the obstacle and the layer of the wire being routed plus half the wire width. In this way, a wire bending in an interesting point does not break any design rule (fig. <a HREF="#nonexistent-marker">7.8</a>). The agents construct wires to the interesting points and analyse the best possibilities from them. They can turn the wire or change layers and then try the next interesting point.<p>
<img SRC="router8.gif" WIDTH="585" HEIGHT="310"><p>
<a NAME="HEADING1-31"></a>
<h1>7.4  Router expert</h1>
 The RouterServer object is in charge of the communications with the outside world. It can interpret EDIF format <a HREF="#nonexistent-marker">[55]</a> and the commands accepted by the router. It holds the RouterExpert <i>agent</i> <i>object</i> that undertakes the real routing. When the RouterServer object receives a circuit to be routed it reads it into a Design object and passes it to the RouterExpert agent to carry out the routing. When the routing is finished it converts the resulting design to EDIF format and sends it back to the client.<p>
 When the RouterExpert agent receives a circuit, it first performs some simple routing. It connects straight diffusion and polysilicon lines and connects all the unconnected diffusion lines to metal1.<p>
<a NAME="HEADING1-34"></a>
<h2>7.4.1    Connect in same layer</h2>
 The RouterExpert agent uses the Design object's <code>connectInSameLayer</code> method to connect points on the same layer which are close to each other. These connections should lie in a straight line. First, the program tries the points on the diffusion layers (pdiff and ndiff). Only this type of connection will be routed in diffusion, abutted transistors (transistors on the same strip of diffusion) will be connected this way. After routing all diffusion links, the program will try to connect polysilicon points. The placement program tried to align the connected gates of transistors, these will be connected now. If, by chance, the program finds other possible short connections, other than abutted MOSFETs and aligned gates, they will be routed this way too.<p>
<a NAME="HEADING1-36"></a>
<h2>7.4.2    Diffusion to metal openings</h2>
 As the only allowed type of wiring using diffusion has already been carried out (mainly for abutted transistors), any remaining unwired diffusion points have to be connected in metal1. For each unwired diffusion terminal, the Design object's method <code>makeDiffusionToMetal1</code> will be applied to try to extend it into layer metal1 (fig. <a HREF="#nonexistent-marker">7.9</a>). If this change isn't possible the cell can not be routed and an error condition is returned.<p>
<img SRC="router9.gif" WIDTH="731" HEIGHT="720"><p>
<a NAME="HEADING1-38"></a>
<h2>7.4.3    Main connections</h2>
 After the basic connections have been completed, the <code>connectGeneral</code> method wires all remaining connections. The unwired nodes are put in the <code>Routing</code> <code>Nodes</code> <code>Queue</code> list, ordered by importance and size, smaller nodes coming first. This will help if any rerouting has to take place later. The <code>connectGeneral</code> method uses the <code>connectNode</code> method to connect all members of this list. From this stage on, only the wiring layers, polysilicon, metal1 and metal2, will be used for interconnections. <p>
 In a Design object, each node has a list of partially routed subnets (<code>routingNets</code> list). Each list contains at least one wire corresponding to a component terminal. If none of the subnets was wired together all lists will have just this small wire. If they have all been wired, the node will have just one list holding all subnets in its <code>routingNets</code> list. <p>
 The <code>connectNode</code> method connects the subnets in a node's <code>routingNets</code> list. It tries to connect each net using the method <code>connectSubnet</code>. If the method can not connect a subnet, the next subnet in the list will be connected and the unconnected subnet will be tried again later. The method returns FALSE if not all subnets are connected together.<p>
<a NAME="HEADING1-42"></a>
<h2>7.4.4    Connecting a subnet</h2>
 The subnets connection is based on the <i>interesting points</i>, discussed in section <a HREF="#MARKER-9-4">7.3</a>. The wiring of a connection is undertaken by the Connect agents by analysing the nearest interesting points, beginning at the wire origin. A Connect agent is created for each interesting point. From its analysis of the point, a number of operations can be performed: it can change layers, connect the wire to the destination, create a new piece of wire, unwire a blocked path, etc (fig. <a HREF="#nonexistent-marker">7.10</a>). The agent's goal is to reach a point in the destination subnet. It can create other agents (reproducing) to analyse other nearby points of interest. These operations go on until two subnets are finally wired together.<p>
<img SRC="router10.gif" WIDTH="582" HEIGHT="394"><p>
 The RouterExpert agent controls the population of Connect agents and the way they perform the routing. The idea would be to have a population of Connect agents trying their solutions in parallel. If an individual finds a new <i>interesting</i> point, it reproduces. If it completes a wire it sends it to the RouterExpert agent. If it has exhausted all its options, it dies. The RouterExpert would then take care of this &quot;farm&quot;, killing individuals with costly routing and giving more resources to individuals with prospective wires.<p>
 Unfortunately parallelism at this level is not available in BSD Unix (Berkeley System Distribution) <a HREF="#nonexistent-marker">[70]</a>, only in the System V Unix <a HREF="#nonexistent-marker">[71]</a> using the threads mechanism. But even in this case, it only would be real parallelism (not just time sharing) if the host machine had more than one processor. For this reason, a system of list queues is used to schedule Connection agent's execution, in a time sharing fashion.<p>
<a NAME="HEADING1-46"></a>
<h2>7.4.5    The algorithm</h2>
 The RouterExpert agent's method <code>connectSubnet</code> controls the process of routing a subnet. Figure <a HREF="#nonexistent-marker">7.11</a> shows its data structures, its main constituents are:<p>
<ul>
<li><b>Routing Nodes Queue</b> - This list points to the nodes being routed. When a node is routed the <code>CurrentRoutingNode</code> pointer is updated. If a node has to be unwired its position on the list has to be changed and it has to be repositioned after the pointer.<p>
<li><b>AgentsList</b> - This list holds the Connect agents that are waiting to run. <p>
<li><b>AgentsQueue</b> - This is a list that holds the first Connect agent and all other Connect agents that ask for nets to be unwired. Agents on this list will be transferred to the <code>AgentsList</code> when it gets empty.<p>
<li><b>Best Wire </b>- This holds the current best wire. Wires are sent in by the Connect agents when they are running. The variable only keeps the best one.<p>
</ul>
<img SRC="router11.gif" WIDTH="588" HEIGHT="489"><p>
 The main algorithm used by the <code>connectSubnet</code> method is shown in figure <a HREF="#nonexistent-marker">7.12</a> and described bellow:<p>
<img SRC="router12.gif" WIDTH="510" HEIGHT="652"><p>
<ul>
<li><b>Lines 1-3</b>: First the method finds the envelope (fig. <a HREF="#nonexistent-marker">7.3</a>) of each subnet being routed. The routing is carried out from the smaller subnet to the bigger. It is usually easier to reach a point from a small subnet, e.g. a single terminal, to a bigger one, such as a Vdd line, than the other way round. <p>
<li><b>Lines 4-5</b>: The method finds the closest wiring points (fig. <a HREF="#nonexistent-marker">7.3</a>) between the two subnets and calculates certain important constants, such as the cost of the minimum wire connecting the closest wiring points and the average cost of connecting the two subnets. The average cost is the cost of a straight wire connecting between two points over a distance that is the average of the biggest and smallest dimensions of the subnets' envelopes.<p>
<li><b>Lines 6-7</b>: The routine now creates the first Connect agent in order to analyse the first <i>interesting</i> point, the wiring origin, and appends it to the <code>agentsQueue</code> list. As long as the <code>agentsQueue</code> is not empty, the algorithm will try to use the agents on it. <p>
<li><b>Line 8</b>: If a Connection agent asks for other nets to be unwired, the nodes of these nets have to be saved first. As all Connect agents work on the same Design description, to avoid the cost of copying it, the description can not be permanently altered by them. For this reason any unwired nodes have to be saved before any modification takes place.<p>
<li><b>Lines 9-11:</b> The first element in the <code>agentsQueue</code> is put in the <code>agentsList</code>. As long as the <code>agentsList</code> is not empty, the algorithm runs the agents on it. <p>
<li><b>Lines 12-17:</b> The algorithm obtains the first element of the <code>agentsList</code>. If the wire being routed by this agent is already too costly the agent is killed. The environment in the Connect agent is set, which means that the agent can initialize any variables or add something to the Design description. The method <code>run</code> is called in the Connect agent. <p>
<li><b>Lines 18-21</b>: When the Connect agent halts and its <code>run</code> method returns, its environment is reset. This allows the agent to undo any modification to the Design description. The agent is subsequently killed. If the agent has found any new wire, it sent it back to the RouterExpert agent using the method <code>tryAsBestWire</code>. If it has created new Connect agents, they were either added to the lists <code>agentsQueue</code>, if they ask for other nets to be unwired, or to <code>agentsList</code> if they do not ask. <p>
<li><b>Lines 22-25</b>: The Router continues until the <code>agentsList</code> is empty. It then restores any unwired node from the stack. If a suitable wire is found, the process stops. If no wire is found the cycle continues until there are no Connect agents left in the <code>agentsQueue</code>.<p>
<li><b>Lines 26-31</b>: At the end of this process, if a suitable wire has been found, it is added to the node being currently wired. If it is necessary to unwire other nodes to make room for this new wire, these nodes are now unwired and have their position upgraded in the <code>Routing</code> <code>Nodes</code> <code>Queue</code>. They will be rewired later. If no suitable wire has been found the order of the subnets is inverted and the process is repeated, this time from the bigger net to the smaller.<p>
</ul>
 When a Connect agent finds a wire it sends it to the RouterExpert agent using the method <code>tryAsBestWire</code>. The method will test whether the cost of this wire is smaller than the current best one (if there is one). If the new one is cheaper, it will become the new best. The method also tests whether the new wire has a cost very near the cost of the minimum wire. If so, the search stops.<p>
<a NAME="HEADING1-63"></a>
<h2>7.4.6    Rewiring</h2>
 When the path of a wire is totally blocked by an already routed wire, the program unwires the old wire to allow the wiring of the new. After that the old wire is rewired. Unwiring is a very expensive operation. The unwiring of a section of wire can lead to the complete unwiring of many nodes. Unfortunately it has to be carried out when previous wires completely block the path of a new one.<p>
 When a Connect object has the path of its wire obstructed by a wire belonging to a node different from the one it is currently routing, it creates a new Connect agent, which asks for that wire to be removed, and sends it to the RouterExpert agent. This new agent is sent to the <code>AgentsQueue</code> (fig. <a HREF="#nonexistent-marker">7.11</a>). The agents in the <code>AgentsQueue</code> are used only if a wire that does not need any unwiring is not found, or if this wire is very costly (at least twice the cost for the subnets' average wire). Because rewiring is so expensive it is only tried when all agents that do not ask for it (the ones in the <code>agentsList</code>) have been tried.<p>
 When a new Connect agent is added to the <code>AgentsQueue</code>, the program determines which nodes will have to be unwired as a result of the removal of the wire that is blocking that particular agent path. The node, that the wire belongs to, and all nodes wired after it, that share any common area with it, have to be completely unwired. Nodes sharing areas with these unwired nodes have to be unwired as well. For instance, if the nodes were wired in the order A, B and C; A had to be unwired and B occupies an area that overlaps A's. B will have to be unwired and C will be left intact only if it shares area with neither A nor B. The Connect agents are added to the <code>AgentsQueue</code> ordered by the number of nodes that they are asking to be unwired, the smaller numbers (cheaper ones) coming first.<p>
 All this care has to be taken because the wiring of a node reflects in the wiring of the other nodes connected after it. If only the wire that is blocking a path is taken out, other wires, in the same node or from other nodes, could have had their shape heavily influenced by that wire. For instance, they could have changed layers to avoid the wire, and if this wire is then deleted and rewired, it can now follow another route and leave an unnecessary change of layer in the design. The only way to ensure that such situations do not take place is to unwire not only the blocking wire but all wires that could have had any topological conflicts with it. Some other less &quot;radical&quot; methods, such as recursive rerouting <a HREF="#nonexistent-marker">[48]</a>, would fail when using more than two layers for routing.<p>
 Figure <a HREF="#nonexistent-marker">7.12</a> shows a possible error due to partial rewiring. The <code>Net</code> <code>#3</code> wire, left side of the figure, was fully blocked by <code>Net</code> <code>#1</code> and <code>Net</code> <code>#2</code> wires. The program then removes the piece of <code>Net</code> <code>#1</code> wire that is blocking the way (marked by dotted lines). The routing of <code>Net</code> <code>#3</code> proceeds to completion, and <code>Net</code> <code>#1</code> is rewired (right side of the figure). What happens then is that <code>Net</code> <code>#1</code> rewires the removed piece in another layer, to cross over <code>Net</code> <code>#2</code> and <code>Net</code> <code>#3</code> layers. This leaves <code>Net</code> <code>#2</code> with a useless piece of wire (marked by dotted lines), making a bridge over a no-existing obstruction. In this case, the two nets, <code>Net</code> <code>#1</code> and <code>Net</code> <code>#3</code>, have to be rewired to avoid the mistake.<p>
<img SRC="router13.gif" WIDTH="523" HEIGHT="355"><p>
 After unwiring a node, the RouterExpert moves it from its original position in the <code>Routing</code> <code>Nodes</code> <code>Queue</code>, to a position after the current node being routed. In this way, the node will eventually be rewired. To avoid loops where A asks B to be unwired and then some time later, when B is being rewired, it asks A to be unwired, a node that unwires another during its routing, can not be unwired.<p>
<a NAME="HEADING1-70"></a>
<h1>7.5  Connection object agent</h1>
 The Connection agent is at the core of the routing process, it carries out the actual routing of the subnets. It is created to analyse <i>interesting</i> points. It finds the next <i>interesting</i> points, extends its wire to reach them, and creates new Connection agents to analyse them. If it finds a connection with the target subnet, it extends its wire to it and proposes it as the best wire to the RouterExpert agent.<p>
 When a Connection agent is created it receives data from its parent about its &quot;mission&quot;. This data includes: where the Connection agent is in the design, where it should go and the wire segment it already holds. The agent then remains dormant, either in the RouterExpert's <code>agentsQueue</code> or <code>agentsList</code>, until the RouterExpert runs it. <p>
 When the Connection agent begins to run, it first checks out its environment and finds out in what direction the target point for its wire is. With this information it plans which of its four operators will be activated first. It feeds them into the <code>Options</code> list, a list that holds operators to be applied, and applies the operators in the list until it is emptied. The applied operators can trigger other operators to be applied (adding them to the <code>Options</code> list). As a result of the operators actions, the agent can extend its wire to other <i>interesting</i> points, create new Connect agents and propose new best wires to the RouterExpert agent. When the agent has tried all possibilities (it emptied the <code>Options</code> list), constrained by its environment and knowledge base, it halts and its <code>run</code> method returns.<p>
<a NAME="HEADING1-74"></a>
<h2>7.5.1    The Connect agent operators</h2>
 The Connect agent expert applies four operators to probe its design options. The most important is the <code>Change</code> <code>Layer</code> operator, which is the only one to do the final connection to the target net. This operator will be introduced in a separate section, the other three are:<p>
<ul>
<li><b>Change Layer</b> - It changes the wire layer to the one specified. It basically uses the method <code>changeLayer</code> from a Design object to make the change. On failure it just returns the message &quot;can't change&quot;. <p>
<li><code>Go<b> to XY </b></code>- It tries to extend the current wire for a specified distance in a specified direction. After changing the wire's direction it finds the dimensions of the wire's section that should be added and uses the Design object method <code>getCrashes</code> to test if the new section fits in place (figure <a HREF="#nonexistent-marker">7.13</a>, left). In case of failure it returns &quot;can't go&quot;.<p>
<li><code>Get<b> Round</b></code> - It tries to go round a specified obstacle in a specified direction. The direction should be parallel to one side of the obstruction. The operator will look for an <i>interesting</i> point: the place where a pointer, which has its origin at the current wire's end and points parallel to the specified direction, aligns with the obstacle's edge (plus a separation margin). It will then find the dimensions of a corresponding wire segment which would fit from the end of the wire to the interesting point and will use the Design object <code>getCrashes</code> to test if this new section fits (figure <a HREF="#nonexistent-marker">7.13</a>, right). In case of failure it returns &quot;can't get&quot;.<p>
</ul>
<img SRC="router14.gif" WIDTH="545" HEIGHT="419"><p>
 If successful all three operators add the new section to their wires and create a new Connect agent to work on this new <i>interesting</i> point. When they create new Connect agents they send them to the RouterExpert to the <code>agentsList</code>. They do not create agents that ask for nets to be unwired. If unsuccessful all operators return messages that can be used by the Connect agent to trigger the activation of other operators.<p>
<a NAME="HEADING1-80"></a>
<h2>7.5.2    The Change Direction operator</h2>
 The <code>Change</code> <code>Direction</code> operator is Connect agent's most important object because it probes the space in defined directions, looking for a connection in the target net or for obstructions. It gathers information that can be used to activate other operators.<p>
 When this operator is used it receives a pointer with the direction it should probe into, its vector direction. It then uses the Design object method <code>getWiringLayersTouchPointer</code> (fig. <a HREF="#nonexistent-marker">7.3</a>) to test if a pointer, with the same width and layer type as its last wire segment and pointing in its vector direction, touches any wire in the target subnets (or any other subnet belonging to the same node). If the result of this test is negative, the operator uses the Design method <code>getCrashesPointer</code>, to detect any crash in the operator's vector direction. If there is a crash the operator will add to the <code>Options</code> list the operator <code>Goto</code> <code>XY</code> in the crash's direction up to the crash's point edge (fig. <a HREF="#nonexistent-marker">7.14</a>, middle). If the operator's vector aligns with the Goal point (fig. <a HREF="#nonexistent-marker">7.8</a>, left) it adds another operator <code>Goto</code> <code>XY</code> to the <code>Options</code> list, to add a new segment extending the wire up to the alignment point (fig. <a HREF="#nonexistent-marker">7.14</a>, left). The operator returns the message &quot;No touch&quot;.<p>
<img SRC="router15.gif" WIDTH="570" HEIGHT="367"><p>
 If there is a touch in one of the target subnets the operator uses the Design object method <code>makeConnection</code> to try to make a connection. If there is a connection, the resulting wire is sent to the RouterExpert agent as a possible best wire (fig. <a HREF="#nonexistent-marker">7.14</a>, right). <p>
 If there is no connection the operator uses the Design method <code>getCrashesPointer</code>, to detect any crash in the operator's vector direction. If there are no crashes it returns the message &quot;Can't make connection&quot; and, as before, if the operator's vector aligns with the Goal point (fig. <a HREF="#nonexistent-marker">7.8</a>, left) it will add an operator <code>Goto</code> <code>XY</code> to the <code>Options</code> list. If there are crashes the operator tries the following series of operations to overcome the obstructions between its position and the target subnet:<p>
<ul>
<li><b>Reroute</b> - It creates a new Connect agent that asks for the obstructions to be unwired and sends it to the RouterExpert <code>agentsQueue</code> list.<p>
<li><b>Get Round</b> - If the obstruction is very close to the point were the Connect agent is in the design, it will add operators <code>Get</code> <code>Round</code> to try to pass around the obstruction (fig. <a HREF="#nonexistent-marker">7.15</a>, left). It will return the message &quot;Full blocked&quot;.<p>
<li><b>Goto XY</b> - If the obstruction is within a certain distance from the Connect agent, it will add an operator <code>Goto</code> <code>XY</code> to get close to the point of obstruction (fig. <a HREF="#nonexistent-marker">7.15</a>, middle). It will return the message &quot;Blocked&quot;.<p>
<li><b>Goto goal alignment</b> - If the goal alignment with the operator's direction vector occurs before the obstruction, it will add a <code>Goto</code> <code>XY</code> operator to get to the point of alignment (fig. <a HREF="#nonexistent-marker">7.15</a>, right).<p>
</ul>
<img SRC="router16.gif" WIDTH="590" HEIGHT="349"><p>
 If the operator <code>Change</code> <code>Direction</code> manages to make a connection it returns the message &quot;Success&quot;.<p>
<a NAME="HEADING1-90"></a>
<h2>7.5.3    The general operation</h2>
 In the Connect agents all the wire building and <i>interesting</i> points analyses take place when the operators are applied. Operators are applied from the <code>Options</code> list. One way of adding operators to the list is through the operator <code>Change</code> <code>Direction</code>, as explained in the last subsection. <p>
 The other way, as explained earlier, is when the Connect agent begins to run and survey its environment. The operators chosen, to be added to the <code>Options</code> list, depend mainly on the last operation performed by the parent of the Connect agent prior to its creation. For instance, if the last action was an operator <code>Goto</code> <code>XY</code> to approach a obstruction, <code>Get</code> <code>Round</code> operators will be added to the <code>Options</code> list to try to overcome the obstruction.<p>
 In addition to any operator dictated by the surrounding environment, on all occasions, the algorithm will add to the <code>Options</code> list: <code>Change</code> <code>Layers</code> operators to the agent's wire adjacent layers (for instance poly to metal1), and at least two <code>Change</code> <code>Direction</code> operators going each to one of the possible directions (north, south, east and west).<p>
 The rules in the Connect agent knowledge base try to strike a balance between the number of particular cases they take into consideration and the likelihood of any of the particular cases leading to a perfect wire. Here, some examples of the special circumstances the knowledge base analyses have been illustrated, but there are others. Many more will be added as the program matures.<p>
 In summary, the basic behaviour of each Connect agent is to try to extend the wire it has inherited from its parent. This continues until no operators are available in the <code>Options</code> list. The agent's job is to try all reasonable possibilities for expanding the wire. The task of the RouterExpert agent is to restrain the Connect agents, promoting the ones that found a good path, in such a way that the program finds a good solution in a reasonable amount of time.<p>
 The interaction of these two types of agents creates the final routing, as shown in figure <a HREF="#nonexistent-marker">7.16</a>. This routing is subsequently sent back to the Router server's client. Similar to the Placer server, the Router on success sends back the design, as an EDIF command, otherwise it sends the message <code>(LIST</code> <code>SORRY).</code><p>
<img SRC="router17.gif" WIDTH="750" HEIGHT="703"><p>
 <p>
<dl>
<dt><a HREF="router.html#HEADING1-1"><b>7.1 </b> - Introduction</a><dd>
<dt><a HREF="router.html#HEADING1-6"><b>7.2 </b> - The CAD role</a><dd>
<dt><a HREF="router.html#HEADING1-9"><b>7.2.1   </b> - Retrieve methods</a><dd>
<dt><a HREF="router.html#HEADING1-19"><b>7.2.2   </b> - Building methods</a><dd>
<dt><a HREF="router.html#HEADING1-25"><b>7.3 </b> - The Designer role</a><dd>
<dt><a HREF="router.html#HEADING1-31"><b>7.4 </b> - Router expert</a><dd>
<dt><a HREF="router.html#HEADING1-34"><b>7.4.1   </b> - Connect in same layer</a><dd>
<dt><a HREF="router.html#HEADING1-36"><b>7.4.2   </b> - Diffusion to metal openings</a><dd>
<dt><a HREF="router.html#HEADING1-38"><b>7.4.3   </b> - Main connections</a><dd>
<dt><a HREF="router.html#HEADING1-42"><b>7.4.4   </b> - Connecting a subnet</a><dd>
<dt><a HREF="router.html#HEADING1-46"><b>7.4.5   </b> - The algorithm</a><dd>
<dt><a HREF="router.html#HEADING1-63"><b>7.4.6   </b> - Rewiring</a><dd>
<dt><a HREF="router.html#HEADING1-70"><b>7.5 </b> - Connection object agent</a><dd>
<dt><a HREF="router.html#HEADING1-74"><b>7.5.1   </b> - The Connect agent operators</a><dd>
<dt><a HREF="router.html#HEADING1-80"><b>7.5.2   </b> - The Change Direction operator</a><dd>
<dt><a HREF="router.html#HEADING1-90"><b>7.5.3   </b> - The general operation</a><dd>
</dl>

<hr>

<pre><h3><a HREF="result.html"><b><img SRC="next.gif" WIDTH="40" HEIGHT="40"> Next</a>            <a HREF="contents.html"><b><img SRC="book.gif" WIDTH="40" HEIGHT="40"> Contents</a>       <a HREF="mailto:d.moreira@ieee.org"><b><img SRC="comments.gif" WIDTH="40" HEIGHT="40"> Talk to me</a></h3></pre>

</body>
</html> 