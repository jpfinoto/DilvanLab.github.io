<!-- Generated by Harlequin Webmaker 2.1.3; Harlequin Transducer 1.0 --> 
<html> <head>
<title>Agents Servers</title>
</head>
<body BGCOLOR="#FFFFFF">
<a NAME="HEADING1"></a>

<h1><a NAME="MARKER-9-6"></a>Chapter 4: Agent Servers</h1>
<hr>
<a NAME="HEADING1-1"></a>
<h1>4.1  Introduction</h1>
 In chapter <a HREF="#MARKER-9-6">3</a> the concept of agents, as software components that communicate with their peers by exchanging messages in a communication language <a HREF="#nonexistent-marker">[31]</a>, was introduced. It was said as well, that the agent metaphor is employed here at two levels: at a higher level, servers can be seen as large agents that communicate and cooperate over a network, and at a lower level small relatively simple agents work together inside the servers. The later are implemented using <i>agent objects</i> and were introduced in chapter <a HREF="#MARKER-9-6">3</a>. The former are the main topic of this chapter.<p>
 Software agents can be used to partition large software into smaller units, in the software industry agents can play an important role in a product suite <a HREF="#nonexistent-marker">[53]</a>. Suites are a set of applications that used to operate in isolation, but have been integrated to help reduce the cost of software ownership and improve productivity. Applications can communicate and use each other's resources to accomplish a bigger task. Because they still are independent programs, they can run in parallel in different machines, thus improving performance. <p>
<a NAME="HEADING1-4"></a>
<h1>4.2  Client/Server Model</h1>
 The <b>Agents</b> system uses four <i>agent servers</i> that can run in parallel on different machines to solve cooperatively a placement-routing problem. They were implemented as a distributed system using a client/server model. A distributed computer system contains software programs and data resources dispersed across independent computers connected through a communication network <a HREF="#nonexistent-marker">[51]</a>. Distributed solutions are increasingly common in applications for office automation, process control, collaborative workgroups and concurrent engineering. Distributed architectures allow users of individual, networked computers to share data and processing power, often over long distances. Distribution can also enhance availability, reliability and performance. However, to deliver these benefits, distributed computing incurs design costs not present in centralized systems, most notably increased control complexity. Figure <a HREF="#nonexistent-marker">4.1</a> shows an example of a practical, heterogeneous computer network, where many different machines from different vendors are interconnected. Just the number of user manuals for a system like this, can give a good idea of the degree of complexity involved.<p>
<img SRC="servers1.gif" WIDTH="755" HEIGHT="536"><p>
 Coordination models represent one way to deal with this increased control complexity coherently and uniformly. A coordination model establishes logical roles and associated behaviours (for applications that assume such roles) for executing distributed interactions <a HREF="#nonexistent-marker">[51]</a>. <p>
 One coordination model widely used in distributed systems is the client/server architecture. A program, the client, requests an operation or service that some other application, the server, provides. When a server receives a client request, it performs the requested service and returns to the client any results. A client interface specifies the individual services or operations offered by the server.<p>
 The client/server model offers simplicity in closely matching the flow of data with the control flow. In addition, the model promotes modular, flexible, and extensive system designs. Data resources and computing services can be organized, integrated and used as a service. Services include operating system functions, such as naming and authentication; shared information resources, such as printers and file systems; and applications, such as database and electronic mail. Programs can sometimes act either as servers or clients, for instance a relational database server (such as Oracle) reading a file from a file server is acting as a client (of the file server), but when it gives the retrieved information to the application that requested it, it is acting as a server.<p>
<a NAME="HEADING1-9"></a>
<h1>4.3  Software agents</h1>
 Agent-based software engineering was invented to facilitate the creation of software able to interoperate in heterogeneous environments <a HREF="#nonexistent-marker">[31]</a>. In this approach to software development, application programs are developed as software agents, i.e., software components that communicate with their peers by exchanging messages in an expressive agent communication language. The advantages of this approach are more flexibility and its suitability for use in a client/server implementation model. As said before, the whole <b>Agents</b> system is formed by four <i>agent servers</i>:<p>
<ul>
<li><b>Router</b> - It wires the circuits sent to it.<p>
<li><b>Placer</b> - It places components in a cell and uses the Router to wire them.<p>
<li><b>Database</b> - It keeps all the information that is dependent upon the fabrication process, such as the design rules.<p>
<li><b>Broker</b> - It makes the services of the other servers available. As its name implies it manages the available resources, in this case the servers, to meet the demands of the clients.<p>
</ul>
<a NAME="HEADING1-15"></a>
<h2>4.3.1    Communication</h2>
 The <i>agent servers</i> communicate over a network, and as they are intended to run on Unix machines and over the Internet, TCP/IP Internet Protocol <a HREF="#nonexistent-marker">[52]</a> sockets were used.<b> </b>Sockets are the basic components of interprocess (intersystems) communication in TCP/IP. They provide access to the network transport protocols and are an endpoint of communication to which a name can be bound. There are two kinds of sockets for application programs: the datagram and the stream sockets. A stream socket provides bidirectional, reliable, sequential, and unduplicated flow of data with no record boundaries. A datagram socket provides just bidirectional flow of data, the data is divided in packages, the receiver can receive them in a different order from the sending sequence and may receive duplicated messages.<p>
 Stream sockets were chosen as the communication method between the servers because a secure and simple method was required. Using stream sockets and the C++ iostream library, it was possible to develop a simple stream pipe between the servers. <p>
 Servers and clients send commands through the sockets as ASCII strings using Lisp <a HREF="#nonexistent-marker">[54]</a> like languages. This form was chosen because Lisp is easy and fast to parse and extend, it facilitates debugging (the messages can be easily read) and for compatibility with EDIF (Electronic Design Interchange Format) <a HREF="#nonexistent-marker">[55]</a>. EDIF is a standard Lisp like language used to represent electronic designs. The arrangement of stream sockets plus ASCII Lisp languages is so simple, that it is possible to make a <code>telnet</code> connection with any server, type in the commands and read the servers answers.<p>
<a NAME="HEADING1-19"></a>
<h2>4.3.2    The router and placer servers</h2>
 The Router and Placer <i>agent servers</i> form the core of the <b>Agents</b> system, their implementation will be discussed in more detail in the following chapters. In this chapter, only their interface with the other servers will be discussed.<p>
 After starting, the servers will connect to a client and interpret all strings coming from it as an EDIF language statement. In addition to the EDIF standard commands, the servers will perform the three commands shown in table <a HREF="#MARKER-9-4">4.1</a>.
 All the other commands in EDIF will be accepted as well, for instance, the client can send in cell libraries. Also the set of commands can be expanded easily. All the servers will answer the commands using EDIF as well.<p>

<table BORDER="1">
<th>Command<th>Action <th>Answer<tr>
<td><code>(DIE)</code><td>Kills the server.<td>None<tr>
<td><code>(CLEAR)</code><td>Clear the library and design data in the servers.<td><code>(LIST</code> <code>OK)</code><tr>
<td><code>(ROUTE<b> (EDIF ...))</b></code><p><b>or</b><p>(PLACE<b> </b>(EDIF<b> ...</b>))<td>Route or Place the circuit sent in the command <code>(EDIF</code>....<code>)</code>. The command <code>EDIF</code>, shown here only partially, encodes a full circuit description.<td><code>(EDIF</code> ...<code>)</code><p>or<p><code>(LIST</code> <code>SORRY)</code> </table>
<caption><h3 align="center">Table 4.1: Placer and Router non-EDIF commands.</h3><a NAME="MARKER-9-4"></a></caption>

<a NAME="HEADING1-22"></a>
<h1>4.4  The Squeme language</h1>
 Like the Router and Placer servers, the Database and Broker servers will treat all strings sent to it as commands in a Lisp-like language, but this time the language is Squeme <a HREF="#nonexistent-marker">[56]</a> not EDIF. It was designed to have an exceptionally clear and simple semantics and few different ways to form expressions. A wide variety of programming paradigms, including imperative, functional, and message passing styles find convenient expression is Squeme.<p>
 The main difference between Squeme and Common Lisp (the ANSI standard for the Lisp language) is simplicity. The designers of Squeme believe that programming languages should be designed not by piling up features, but by removing the weaknesses and restrictions that make additional features appear necessary. Squeme demonstrates that a very small set of rules for forming expressions, with no restrictions on how they are composed, is enough to create a practical and efficient language that is able to support the main programming paradigms. The Squeme standard <a HREF="#nonexistent-marker">[56]</a> is just 55 pages long, probably the smallest standard for any mainstream language.<p>
 Because it is simple, Squeme is fast, portable and easy to use, which makes it a perfect language for rapid prototyping. For this reasons there are many implementations of Squeme. The STk Squeme implementation <a HREF="#nonexistent-marker">[57]</a> was chosen because it is available in source code, it is compact and easy to extend and because it incorporates the Tk toolkit <a HREF="#nonexistent-marker">[58]</a>. The Tk toolkit is a powerful graphical toolkit that offers high level widgets, such as buttons, menus and canvas and is easy to use, requiring little knowledge of the X11 windows system fundamentals. Tk was originally built on top of an interpretative shell-like language called Tcl <a HREF="#nonexistent-marker">[59]</a>. STk replaces Tcl with Squeme, producing a very powerful graphical rapid prototyping system. Even though the STk graphic capabilities aren't important for the final <b>Agents</b> system, they were paramount during the development stage, giving an invaluable insight into the program's workings.<p>
 To allow STk to interpret commands from a stream socket, it was necessary to extend the core STk commands with two new ones: <code>server-command-socket</code> and <code>client-command-socket</code>. The first command creates a socket and listens to it until a connection to a client is established, it is used to create servers. The second command creates a socket and connects it to specified host socket, it is used to create clients. Both commands will, after connection, interpret strings coming out of the sockets as Squeme language commands. All this listen and connection activity is implemented using the notifier mechanism supplied by the Tk library, for this reason any other activity going on at the same time in the program, such as text editing or button operation, will not freeze waiting for a connection to get started or for data to be received.<p>
<a NAME="HEADING1-27"></a>
<h2>4.4.1    The process DataBase server</h2>
 The kind of placement and routing undertaken by the <b>Agents</b> system is process independent, which means that the system should not be dependent upon particular process design rules. To achieve this independence all the information about the process rules is kept in a process Database server separate from the Placer and Router servers. Whenever any server needs information about the process, it should query the database, through its network connection (socket stream), using the Squeme language.<p>
 Figure <a HREF="#nonexistent-marker">4.2</a> shows the database server window, named <code>db</code>. The figure shows the button Quit, that kills the application, and a text widget showing all the queries received and their answers. This window is not essential to the database server, it is used to show the flow of information to help debugging the program.<p>
<img SRC="servers2.gif" WIDTH="746" HEIGHT="528"><p>
 The Database server stores its information in hash tables, the information is assessed using a very simple language. The queries state the type of the information they are looking for and to which elements (usually layers) this information refers. For instance:<p>
<pre>
(minSpacing ndiff cont)
</pre>
 This query is looking for information concerning minimum space between two elements: the layers ndiff and pdiff.<p>
 The answer for all queries is sent back in EDIF format, this is implemented this way because the clients of the Database server, the Placer and Router server, can parse EDIF but not Squeme. Of course, if necessary in the future, this capability can be added to them. The answer to the minSpacing query is then <code>(E 15 -7)</code>, which represents 1.5 mm.<p>
 The data for each particular process is read from a process description file. The data tables are created by the command:<p>
<pre>
 (data-command (&lt;type&gt; &lt;number of elements&gt; (&lt;description&gt;) ...)
</pre>
 The field <code>&lt;type&gt;</code> is the type of the query, <code>&lt;number</code> <code>of</code> <code>elements&gt;</code> is the number of elements the query refers to, and the <code>&lt;description&gt;</code> is a list containing a particular combination of elements and the information this combination should retrieve. The command to make the <code>minSpacing</code> query table can be created like this:<p>
<pre>
(data-command
  '(minSpacing 2
    (NWELL NWELL (E 85 -7))
    (NWELL NDIFF (E 65 -7))
    (POLY VIA (E 20 -7))
     ...
  ))
</pre>
 The &lt;<code>number of element&gt;</code> field can be 0, in which case the query does not refer to any elements and always returns the same value. Table <a HREF="#MARKER-9-4">4.1</a> shows some of the information kept by the two process design rules used currently by the servers.<p>

<table BORDER="1">
<th>Query<th>Meaning <th>Answer<tr>
<td><code>(minWidth &lt;l1&gt;)</code><td>Minimum width of layer &lt;l1&gt;<td><code>EDIF number</code><tr>
<td><code>(minSpacing &lt;l1&gt; &lt;l2&gt;)</code><td>Minimum separation between layers &lt;l1&gt; and &lt;l2&gt;..<td><code>EDIF number</code><tr>
<td><code>(</code>minOverlapping<b> </b>&lt;l1&gt; &lt;l2&gt;))<td>Minimum overlapping of layer &lt;l1&gt; over layer &lt;l1&gt;.<td><code>EDIF</code> <code>number</code><tr>
<td><code>(</code>layersNames)<td>The names of all layers available in the process.<td><code>EDIF</code> <code>list</code><tr>
<td><code>(</code>gridValue)<td>Minimum dimension allowed by the process' rules.<td><code>EDIF</code> <code>number</code></table>
<caption><h3 align="center">Table 4.2: Possible queries to a Database server.</h3><a NAME="MARKER-9-4"></a></caption>
<p>
<a NAME="HEADING1-45"></a>
<h1>4.5  Architecture of multi-agent systems</h1>
 Once all the agents of a system have been planed, the question remains of how these agents should be organized to improve collaboration. A model based on a broker was adopted. A broker is one who acts as an agent in negotiating contracts. In terms of distributed computing, the broker provides an intermediary between the client making a request and the server which fulfils the request <a HREF="#nonexistent-marker">[61]</a>. <p>
 An <i>agent server</i> called Broker was created to coordinate the access of applications to the Placer, Router and Database servers. It was written in Squeme and, like the Database <i>agent server</i>, the Broker interprets Squeme commands sent in by a stream socket connection with a client. On top of Squeme, the Broker implements a sub-set of the KQML (Knowledge Query and Manipulation Language) <a HREF="#nonexistent-marker">[60]</a>. <p>
<a NAME="HEADING1-48"></a>
<h2>4.5.1    The Knowledge Query and Manipulation Language</h2>
 KQML is a language for programs to use to communicate attitudes about information, such as querying, stating, believing, requiring and subscribing. The language is indifferent to the format of the information itself, thus KQML expressions can contain subexpressions in other languages, such as EDIF or Squeme. KQML is most useful for communications among agent-based programs, in the sense that these programs are autonomous and asynchronous and thus need a more complex interaction language. Finally, KQML is complementary to new approaches to distributed computing, like the CORBA (Common Object Request Broker Architecture) <a HREF="#nonexistent-marker">[22]</a>.<p>
 Each agent appears to KQML as if it manages a knowledge base (KB). That means, communication with the agent is with regard to this KB. However, the implementation of an agent is not necessarily structured as a knowledge base, a wrapper code then has to translate the representation used in the agent into a knowledge base abstraction for the benefit of the other agents. For this reason it is said that each agent manages a virtual knowledge base (VKB). Agents talk about the contents of their and other's VKB using KQML, but they can represent statements in their VKBs in a variety of languages.<p>
 Each message in KQML language is a list of components enclosed in matching parenthesis. The first word in the list indicates the type of communication, the subsequent entries are parameters, identified by keywords. The Broker recognizes three default parameters for all messages (table 
<a HREF="#MARKER-9-4">4.1</a>) and it defines four types of communications (table <a HREF="#MARKER-9-4">4.1</a>).<p>
<a NAME="HEADING1-52"></a>
<p>
<table BORDER="1">
<th>Parameter<th>Meaning <tr>
<td><code>:content</code><td>The information about which the query express an attitude.<tr>
<td><code>:language</code><td>The name of the representation language of the <code>:content</code> parameter. It defaults to Squeme.<tr>
<td>:sender<td>A symbol representing the sender of the query.</table>
<caption><h3 align="center">Table 4.3: Default message parameters.</h3><a NAME="MARKER-9-4"></a></caption>
<p>
<table BORDER="1">
<th>Type<th>Meaning <tr>
<td><code>tell</code><td>Queries of this type indicate that the <code>:contents</code> sequence is in the sender's VKB.<tr>
<td><code>evaluate</code><td>Queries of this type indicate that the sender would like the recipient to evaluate the expression in the <code>:contents</code> parameter.<tr>
<td>ask-one<td>Extra parameter <code>:aspect &lt;expression&gt;.</code><p>Queries of this type indicate that the sender wishes to know if the <code>:contents</code> matches any sentence in the recipient's VKB that complies with the restrictions in <code>:aspect</code>.<tr>
<td>recommend-one<td>Queries of this type indicate that the sender wants the recipient to reply with the name of an agent that is particularly suited to the kind of processing indicated by <code>:contents</code>.</table>
<caption><h3 align="center">Table 4.4: KQML communication types.</h3><a NAME="MARKER-9-4"></a></caption>
<p>

<h2>4.5.2    The Broker server</h2>
 The Broker agent server retains information about its clients and about the three servers (Placer, Router and Database). This information forms the Broker's VKB. Each client or server is identified by a symbol (generally a number) and has an entry in the KB. Each entry has six fields with information about the server or client: Identification symbol, type, host where it is running, socket port it uses to start communications and information about its process. Not all the fields need to hold information, especially if the entry is about a client. The searches are undertaken using the identity symbol of a client/server as a key. Like the other servers (Placer, Router and Database), the Broker answers its questions in EDIF not in KQML. This is not a good implementation, to really comply with the ideas embedded in KQML the Broker should have used KQML in both directions, this would allow a more standard dialogue with application clients. However, as the Placer and Router serves cannot parse Squeme (and thus KQML), this compromise solution had to be made for the first version of the system. In future versions, the Broker should use KQML in both directions.<p>
 The Broker does a lot of the housekeeping that would, otherwise, have to be undertaken by its clients. The Broker will start the Database agent server when it starts, there is only one Database per Broker. It will start the requested server, Placer or Router, for the client if there is not any available and the resources in the system allow it. It will start the servers on predefined hosts. The client does not have to worry about the network address of any server. Indeed, the only server it needs to know the address of is the Broker, all the other addresses will be supplied by the Broker. Finally the Broker will clean up all the servers it started when it is shut down. The Broker decouples the clients from the implementation details of the servers, the only service that needs to be advertised is the Broker itself.<p>
 When an application wants to use any of the services provided by the serves it starts a negotiation with the broker (fig. <a HREF="#nonexistent-marker">4.3</a>). The following dialogue would then take place:<p>
<pre>
<b>1-</b> Application asks a service:
 To Broker:    <code>(recommend-one :sender ap1 :content 'placer)</code>
 Broker sends back Placer's identity:
 Answer:       <code>(list 5)</code>
<b>2-</b> Broker starts a new Placer server to serve the client's requests.
<b>3-</b> The recent created server (Placer or Router) sends back to the Broker its address and finds out the Database server's address:
 To Broker:    <code>(tell :sender 5 :content '(myPort 6565))</code>
 Answer:       <code>(list OK)</code>
 New server asks the Database server address:
 To Broker:    <code>(recommend-one :sender 5 :content 'processDB)</code>
 Answer:       <code>(list 0)</code>
 To Broker:    <code>(ask-one :sender 5 :aspect 'address :content 0)</code>
 Answer:       <code>(list eagle 7676)</code>
<b>4-</b> Application asks the service's address:
 To Broker:    <code>(ask-one</code> <code>:sender</code> <code>ap1</code> <code>:aspect</code> <code>'address</code> <code>:content</code> <code>5)</code> 
 Answer:       <code>(list stork 6565)</code>
 The Broker knows the Placer's machine because it created it. If the application asks the service's address before it is available, the Broker answers<code> (list sorry)</code> and the application should keep trying.
<b>5-</b> The application begins to talk to the Placer server directly:
 To service:   <code>(place</code> <code>(edif</code> <code>shiftreg.cir</code> <code>(design</code> <code>shiftreg</code> ...<code>)))</code>
 Answer:       <code>(edif</code> <code>shiftreg.cir</code> <code>(design shiftreg</code> ...<code>))</code>
</pre>
<img SRC="servers3.gif" WIDTH="724" HEIGHT="437"><p>
 The client in this negotiation can be either an application trying to use one of the services or the Placer server asking the Broker to use a Router. Similarly to the Database server the Broker has a window to display information. As shown in figure <a HREF="#nonexistent-marker">4.4</a>, the window shows the dialogue between the Broker and its clients and has a quit button to shut it down.<p>
<img SRC="servers4.gif" WIDTH="623" HEIGHT="400"><p>
<a NAME="HEADING1-77"></a>
<h2>4.5.3    Development phase servers</h2>
 There are two more servers used just during development. The debugger server displays information about the rules firing in the <i>agent objects</i> inside other servers.<p>
 The graphics server displays layout views and other graphic information about the internal states of a client. As shown in figure <a HREF="#nonexistent-marker">4.5</a>, this server shows not only layout, but vectors, illustrating to where the algorithm is going and rectangles, showing crashes or terminals. The server has the buttons:<p>
*  <code>Quit</code> - Quit the server.<p>
*  <code>Clear</code> - Clear the graphic window.<p>
*  <code>In</code> - Zoom into the design.<p>
*  <code>Out</code> - Zoom out of the design.<p>
*  <code>Layers Setting<b> </b></code>- It pops up a menu containing all the layers names and allows the user to show each layer with only its contours or completely painted.<p>
*  <code>Redraw</code> - Redraws the design in the graphic window.<p>
<img SRC="servers5.gif" WIDTH="731" HEIGHT="707"><p>
 On the bottom of the window, there is a bar showing the contours and colours representing all layers. It shows if the elements of a layer are being shown only by their contour or if they are being full painted.<p>
 The client server model is widely used nowadays, it is the model of choice for the majority of the commercial distributed applications. Programs ranging from the simple Telnet utility to huge distributed business-wide databases are based in this model, and, as networked systems became more and more common, more applications are bound to adhere to this model.<p>
<dl>
<dt><a HREF="servers.html#HEADING1-1"><b>4.1 </b> - Introduction</a><dd>
<dt><a HREF="servers.html#HEADING1-4"><b>4.2 </b> - Client/Server Model</a><dd>
<dt><a HREF="servers.html#HEADING1-9"><b>4.3 </b> - Software agents</a><dd>
<dt><a HREF="servers.html#HEADING1-15"><b>4.3.1   </b> - Communication</a><dd>
<dt><a HREF="servers.html#HEADING1-19"><b>4.3.2   </b> - The router and placer servers</a><dd>
<dt><a HREF="servers.html#HEADING1-22"><b>4.4 </b> - The Squeme language</a><dd>
<dt><a HREF="servers.html#HEADING1-27"><b>4.4.1   </b> - The process DataBase server</a><dd>
<dt><a HREF="servers.html#HEADING1-45"><b>4.5 </b> - Architecture of multi-agent systems</a><dd>
<dt><a HREF="servers.html#HEADING1-48"><b>4.5.1   </b> - The Knowledge Query and Manipulation Language</a><dd>
<dt><a HREF="servers.html#HEADING1-52"><b>4.5.2   </b> - The Broker server</a><dd>
<dt><a HREF="servers.html#HEADING1-77"><b>4.5.3   </b> - Development phase servers</a><dd>
</dl>

<hr>

<pre><h3><a HREF="genetic.html"><b><img SRC="next.gif" WIDTH="40" HEIGHT="40"> Next</a>            <a HREF="contents.html"><b><img SRC="book.gif" WIDTH="40" HEIGHT="40"> Contents</a>       <a HREF="mailto:d.moreira@ieee.org"><b><img SRC="comments.gif" WIDTH="40" HEIGHT="40"> Talk to me</a></h3></pre>

</body>
</html> 