<!-- Generated by Harlequin Webmaker 2.1.3; Harlequin Transducer 1.0 --> 
<html> <head>
<title>Genetic Algorithm</title>
</head>
<body BGCOLOR="#FFFFFF">
<a NAME="HEADING1"></a>

<h1><a NAME="MARKER-9-3"></a>Chapter 5: Genetic Algorithm</h1>
<hr>
<a NAME="HEADING1-1"></a>
<h1>5.1  Introduction</h1>
 In nature, individuals best suited to competition for scanty resources survive. Evolving to keep adapted to a changing environment is essential for the members of any species. Although evolution manifests itself as changes in the species' features, it is in the species' genetical material that those changes are controlled and stored. Specifically evolution's driving force is the combination of natural selection and the change and recombination of genetic material that occurs during reproduction <a HREF="#nonexistent-marker">[17]</a>.<p>
 Evolution is an astonishing problem solving machine. It took a soup of primordial organic molecules, and produced from it a complex interrelating web of live beings with an enormous diversity of genetic information. Enough information to specify every characteristic of every species that now inhabits the planet. The force working for evolution is an algorithm, a set of instructions that is repeated to solve a problem. The algorithm behind evolution solves the problem of producing species able to thrive in a particular environment <a HREF="#nonexistent-marker">[63]</a>.<p>
 Genetic algorithms, first proposed by Holland in 1975 <a HREF="#nonexistent-marker">[64]</a>, are a class of computational models that mimic natural evolution to solve problems in a wide variety of domains <a HREF="#nonexistent-marker">[65]</a>. Genetic algorithms are particularly suitable for solving complex optimization problems and for applications that require adaptive problem solving strategies.<p>
<a NAME="HEADING1-5"></a>
<h1>5.2  Optimization techniques</h1>
 Placement and routing are two search intensive tasks. Even though <i>agent objects</i> use knowledge to reduce search time, a great deal of searching is still necessary. A good proportion of this search time will be spent optimizing the components' placement in the layout. In searching for optimum solutions, optimization techniques are used and can be divided into three broad classes <a HREF="#nonexistent-marker">[65]</a>, as shown in figure <a HREF="#nonexistent-marker">5.1</a>.<p>
<img SRC="genetic1.gif" WIDTH="585" HEIGHT="465"><p>
<ul>
<li><b>Numerical techniques</b> use a set of necessary and sufficient conditions to be satisfied by the solutions of an optimization problem. They subdivide into direct and indirect methods. Indirect methods search for local extremes by solving the usually non-linear set of equations resulting from setting the gradient of the objective function to zero. The search for possible solutions (function peaks) starts by restricting itself to points with zero slope in all directions. Direct methods, such as those of Newton or Fibonacci, seek extremes by &quot;hopping&quot; around the search space and assessing the gradient of the new point, which guides the search. This is simply the notion of &quot;hill climbing&quot;, which finds the best local point by climbing the steepest permissible gradient. These techniques can be used only on a restricted set of &quot;well behaved&quot; functions.<p>
<li><b>Enumerative techniques</b> search every point related to the function's domain space (finite or discretized), one point at a time. They are very simple to implement but usually require significant computation. These techniques are not suitable for applications with large domain spaces. Dynamic programming is a good example of this technique.<p>
<li><b>Guided random search techniques</b> are based on enumerative techniques but use additional information to guide the search. Two major subclasses are simulated annealing and evolutionary algorithms. Both can be seen as evolutionary processes, but simulated annealing uses a thermodynamic evolution process to search minimum energy states. Evolutionary algorithms use natural selection principles. This form of search evolves throughout generations, improving the features of potential solutions by means of biological inspired operations. Genetic Algorithms (GAs) are a good example of this technique.<p>
</ul>
 Calculus based techniques are only suitable for a restricted set of well behaved systems. Placement optimization has a strong non-linear behaviour and is too complex for these methods. The set of possible layouts for a circuit can be enormous, which rules out the enumerative techniques. <p>
 These assumptions leave out only the guided random search techniques. Their use of additional information to guide the search reduces the search space to manageable sizes. There are two subclasses to this technique, simulated annealing and evolutionary algorithms. Both can be used to carry out placement, as shown in <a HREF="#nonexistent-marker">[66]</a> and <a HREF="#nonexistent-marker">[8]</a>.<p>
 Agents could use many techniques for placement optimization. Currently it uses the <code>EvalAgent</code> class to implement a genetic algorithm. However, another classes could be created to implement other methods, such as Min-Cut, Force Directed or simulated annealing. They could be used in place of the <code>EvalAgent</code> class, without any other modification to other parts of the program. A future implementation using simulated annealing is very probable, but the genetic algorithm was chosen, as the first implementation, because of its novelty and because it has shown better results than simulated annealing <a HREF="#nonexistent-marker">[8]</a>. <p>
<a NAME="HEADING1-13"></a>
<h1>5.3  The algorithm</h1>
 A genetic algorithm emulates biological evolution to solve optimization problems. It is formed by a set of individual elements (the population) and a set of biological inspired operators that can change these individuals. According to evolutionary theory only the individuals that are the more suited in the population are likely to survive and to generate off-springs, thus transmitting their biological heredity to new generations.<p>
 In computing terms, genetic algorithms map strings of numbers to each potential solution. Each solution becomes an individual in the population, and each string becomes a representation of an individual. There should be a way to derive each individual from its string representation. The genetic algorithm then manipulates the most promising strings in its search for an improved solution. The algorithm operates through a simple cycle:<p>
 1.  <b>Creation of a population of strings.</b><p>
 2.  <b> Evaluation of each string.</b><p>
 3.  <b>Selection of the best strings.</b><p>
 4.  <b>Genetic manipulation to create a new population of strings.</b><p>
 Figure <a HREF="#nonexistent-marker">5.2</a> shows how these four stages interconnect. Each cycle produces a new generation of possible solutions (individuals) for a given problem. At the first stage, a population of possible solutions is created as a start point. Each individual in this population is encoded into a string (the chromosome) to be manipulated by the genetic operators. In the next stage, the individuals are evaluated, first the individual is created from its string description (its chromosome) and its performance in relation to the target response is evaluated. This determines how fit this individual is in relation to the others in the population. Based on each individual's fitness, a selection mechanism chooses the best pairs for the genetic manipulation process. The selection policy is responsible to assure the survival of the fittest individuals.<p>
<img SRC="genetic2.gif" WIDTH="556" HEIGHT="363"><p>
 The manipulation process applies the genetic operators to produce a new population of individuals, the offspring, by manipulating the genetic information possessed by the pairs chosen to reproduce. This information is stored in the strings (chromosomes) that describe the individuals. Two operators are used: Crossover and mutation. The offspring generated by this process take the place of the older population and the cycle is repeated until a desired level of fitness in attained or a determined number of cycles is reached.<p>
<a NAME="HEADING1-22"></a>
<h2>5.3.1    Crossover</h2>
 Crossover is one of the genetic operators used to recombine the population genetic material. It takes two chromosomes and swaps part of their genetic information to produce new chromosomes. This operation is similar to sexual reproduction in nature. As figure <a HREF="#nonexistent-marker">5.3</a> shows, after the crossover point has been randomly chosen, portions of the parent's chromosome (strings) <b>Parent 1</b> and <b>Parent 2</b> are combined to produce the new offspring <b>Son</b>.<p>
<img SRC="genetic3.gif" WIDTH="586" HEIGHT="282"><p>
 The selection process associated with the recombination made by crossover assures that special genetic structures, called building blocks, are retained for future generations. These building blocks represent the most fit genetic structures in the population. <p>
<a NAME="HEADING1-26"></a>
<h2>5.3.2    Mutation</h2>
 The recombination process alone cannot explore search space sections not represented in the population's genetic structures. This could make the search get stuck around local minima. Here mutation goes into action. The mutation operator introduces new genetic structures in the population by randomly changing some of its building blocks, helping the algorithm escape local minima traps. Since the modification is totally random and thus not related to any previous genetic structures present in the population, it creates different structures related to other sections of the search space.<p>
 As shown in figure <a HREF="#nonexistent-marker">5.4</a>, mutation is implemented by occasionally altering a random bit from a chromosome (string), the figure shows the operator being applied to the fifth element of the chromosome.<p>
<img SRC="genetic4.gif" WIDTH="298" HEIGHT="259"><p>
 A number of other operators, other than crossover and mutation, have been introduced since the basic model was proposed. They are usually versions of the recombination and genetic alterations processes adapted to constraints of a particular problem. Examples of other operators are: inversion, dominance and genetic edge recombination.<p>
<a NAME="HEADING1-31"></a>
<h2>5.3.3    Problem dependent parameters</h2>
 This description of the genetic algorithms' computational model reviews the steps needed to create the algorithm. However, a real implementation takes account of a number of problem-dependent parameters. For instance, the offspring produced by the genetic manipulation (the next population to be evaluated) can either replace the whole population (generational approach) or just its less fitted members (steady-state approach). Problem constraints will dictate the best option.<p>
 Other parameters to be adjusted are the population size, crossover and mutation rates, evaluation method, and convergence criteria. <p>
<a NAME="HEADING1-34"></a>
<h2>5.3.4    Encoding</h2>
 Critical to the algorithm performance is the choice of underlying encoding for the solution of the optimization problem (the individuals on the population). Traditionally, binary encodings have being used because they are easy to implement. The crossover and mutation operators described earlier are specific to binary encodings. When symbols other than 1 or 0 are used, the crossover and mutation operators must be tailored accordingly.<p>
 A large number of optimization problems have continuous variables. A common technique for encoding them in the binary form uses a fixed-point integer encoding, each variable being coded using a fixed number of bits. The binary code of all the variables can then be concatenated in the strings of the population. A drawback of encoding variables as binary strings is the presence of Hamming cliffs: large Hamming distances between the codes of adjacent integers. For instance, 01111 and 10000 are integer representations of 15 and 16, respectively, and have a Hamming distance of 5. For the genetic algorithm to change the representation from 15 to 16, it must alter all bits simultaneously. Such Hamming cliffs present a problem for the algorithm, as both mutation and crossover can not overcome them easily.<p>
 It is desirable that the encoding makes the representation as robust as possible. This means that even if a piece of the representation is randomly changed, it will still represent a viable individual. For instance, suppose that a particular encoding scheme describes a circuit by the position of each of its components and a pointer to their individual descriptions. If this pointer is the description's memory address, it is very unlikely that, after a random change in its value, the pointer will still point to a valid description. But, if the pointer is a binary string of 4 bits pointing into an array of 16 positions holding the descriptions, regardless of the changes in the 4 bit string, the pointer will always point to a valid description. This makes the arrangement more tolerant to changes, more robust.<p>
<a NAME="HEADING1-38"></a>
<h2>5.3.5    The evaluation step</h2>
 The evaluation step in the cycle, shown in figure <a HREF="#nonexistent-marker">5.2</a>, is the one more closely related to the actual system the algorithm is trying to optmize. It takes the strings representing the individuals of the population and, from them, creates the actual individuals to be tested. The way the individuals are coded in the strings will depend on what parameters one is trying to optmize and the actual structure of possible solutions (individuals). However, the resulting strings should not be too big or the process will get very slow, but should be of the right size to represent well the characteristics to be optimized. After the actual individuals have been created they have to be tested and scored. These two tasks again are very related to the actual system being optimized. The testing depends on what characteristics should be optimized and the scoring, the production of a single value representing the fitness of an individual, depends on the relative importance of each different characteristic value obtained during testing.<p>
<a NAME="HEADING1-40"></a>
<h2>5.3.6    Implementation</h2>
 The <b>Agents</b> system uses the genetic algorithm for the placement optimization task, to improve components placement before routing. The Placer server exploits topological relationships between components of the design to create the groups of cells. However no grid or position coordinates are determined for them. These groups are placed and this placement optimized using the genetic algorithm (GA) encapsulated in the Eval <i>agent object</i>.<p>
 As the implementation of the Eval <i>agent object</i> is very dependent upon to the implementation of the other components of the Placer server, the actual implementation of this object and the genetic algorithm embedded in it will be left for the placement chapter.<p>
<dl>
<dt><a HREF="genetic.html#HEADING1-1"><b>5.1 </b> - Introduction</a><dd>
<dt><a HREF="genetic.html#HEADING1-5"><b>5.2 </b> - Optimization techniques</a><dd>
<dt><a HREF="genetic.html#HEADING1-13"><b>5.3 </b> - The algorithm</a><dd>
<dt><a HREF="genetic.html#HEADING1-22"><b>5.3.1   </b> - Crossover</a><dd>
<dt><a HREF="genetic.html#HEADING1-26"><b>5.3.2   </b> - Mutation</a><dd>
<dt><a HREF="genetic.html#HEADING1-31"><b>5.3.3   </b> - Problem dependent parameters</a><dd>
<dt><a HREF="genetic.html#HEADING1-34"><b>5.3.4   </b> - Encoding</a><dd>
<dt><a HREF="genetic.html#HEADING1-38"><b>5.3.5   </b> - The evaluation step</a><dd>
<dt><a HREF="genetic.html#HEADING1-40"><b>5.3.6   </b> - Implementation</a><dd>
</dl>

<hr>

<pre><h3><a HREF="placer.html"><b><img SRC="next.gif" WIDTH="40" HEIGHT="40"> Next</a>            <a HREF="contents.html"><b><img SRC="book.gif" WIDTH="40" HEIGHT="40"> Contents</a>       <a HREF="mailto:d.moreira@ieee.org"><b><img SRC="comments.gif" WIDTH="40" HEIGHT="40"> Talk to me</a></h3></pre>

</body>
</html> 