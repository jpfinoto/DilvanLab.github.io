<!-- Generated by Harlequin Webmaker 2.1.3; Harlequin Transducer 1.0 --> 
<html> <head>
<title>Placement</title>
</head>
<body BGCOLOR="#FFFFFF">
<a NAME="HEADING1"></a>

<h1><a NAME="MARKER-9-14"></a>Chapter 6: Placement</h1>
<hr>
<a NAME="HEADING1-1"></a>
<h1>6.1  Introduction</h1>
 The Placer <i>agent server</i> undertakes the placement of circuit cells in a defined area. In chapter <a HREF="#nonexistent-marker">4</a>, the server interface and communication aspects were discussed. This chapter focusses on how the server does the placement itself.<p>
 After reading the design information from its client in EDIF format <a HREF="#nonexistent-marker">[55]</a>, the server performs the placement of components basically in three steps: <p>
<ul>
<li>It forms columns of related transistors. These columns can be formed by MOS transistors that are connected by their gates, MOS transistors that have their source and drain interconnected (pass pair) or bipolar transistors that share connections.<p>
<li>It forms groups joining columns that share drain or source connections. As these connections are implemented using diffusion layers, the line of transistors, formed by joining the MOSFET columns, can be laid out in the same diffusion strip <a HREF="#nonexistent-marker">[48]</a>.<p>
<li>It performs the layout of each cell by placing the groups using genetic algorithm techniques and calling Router <i>agent servers</i> to route them.<p>
</ul>
 The best placement successfully routed becomes the final circuit. This circuit is then sent back to the client application, again, as an EDIF description.<p>
<a NAME="HEADING1-8"></a>
<h1>6.2  The EDIF description</h1>
 The server receives, from its client, an EDIF description of the circuit to place and route and the area available for this design. The design is formed by a list of EDIF cells containing physical mask layout views and one cell, the main cell, containing a symbolic view reporting how the other cells are connected. An EDIF cell with just a physical view looks like:<p>
<pre>
(cell NMOS
  (userData cellFunction NMOS) 
  (view maskLayout Physical 
   (interface 
   (declare inout port (list source drain)) 
   (portImplementation drain (figureGroup NDIFF ...) ...) 
   ...) 
   (contents (figureGroup POLY ...) ...)))
</pre>
 The <code>userData</code> field defines the type of the cell. The cell type is defined for use in the <b>Agents</b> system, it is not a type defined in EDIF, thus an <code>userData</code> command is used. The mask layout view is divided into two parts, the interface and the view's contents. In the interface command, the cell's input and output terminals are declared and their implementation described. In the contents command, the whole cell is described including the terminals. This data structure is maintained after the EDIF commands are interpreted by the Placer server.<p>
 The main cell, the one containing the netlist information, looks like:<p>
<pre>
(cell mainCell 
  (userData cellFunction main) 
  (view symbolic Symbolical 
   (contents 
    (instance PMOS Physical fet1)
   (instance stdNode Physical node0)
    (instance VSS Physical VSS)
   (mustJoin (qualify node0 node)
    (qualify fet7 source) (qualify bip2 emiter)
     (qualify VDD pad)
   ) 
    (mustJoin (qualify node1 node) 
     (qualify VSS pad)
     (qualify fet1 drain) (qualify fet4 drain)
     (qualify bip1 colector) 
    )
   ...
  )))
</pre>
 Again, an <code>userData</code> command defines the type of the cell and there can be only one main cell per design. Only the content field of the symbolic view is used. It holds two commands: the <code>instance</code> command, which declares a cell as part of the layout and gives it a name, and the <code>mustJoin</code> command, which declares what cells are connected and the terminals used in the connection.<p>
 Apart from the main cell there are five kinds of cells:<p>
*  <b>Pad cells</b> - They describe the ports used by the design. Ports are the terminals used by the design as input/output ports. They come already placed.<p>
*  <b>MOSFET cells</b> - They describe CMOS field effect transistors. These transistors will be placed as an array of components.<p>
*  <b>Bipolar cells</b> - They describe bipolar transistors (PNP or NPN).<p>
*  <b>General cells</b> - They describe any kind of cell.<p>
*  <b>ElectricNode cells</b> - They describe all the wiring for a given node. They usually would come empty and the Router <i>agent server</i> would place all the necessary wires to route the particular node in them. However they can come prerouted.<p>
 Pad cells come already placed because their placement is more closely related to the global strategy of the leaf cell placement by a silicon compiler (or other type of client), than to the internal arrangements of the cell design. Having used an object oriented approach, the placer should not take part in activities outside its boundaries, such as the global silicon compiler's strategies for leaf cell placement and routing.<p>
 Bipolar cells were added having in mind to support BICMOS (Bipolar plus CMOS transistors) digital designs. General cells are used to include any kind of cells. They can be used to include small analogue cells, resistors, capacitors, unusually big or shaped transistors. They give greater flexibility to the placement, but, because of their possibly unusual shape, they can reduce the quality of the final placement. They should be used with care.<p>
 The server places components' cells over a design containing the pad cells and any preplaced cells. The server can accept partially placed or wired layouts for completion. Figure <a HREF="#nonexistent-marker">6.1</a> shows a possible input design and the three types of cells to be placed: CMOS transistors, bipolar transistors and general cells (It is considered that all ElectricNode cells are empty).<p>
<img SRC="placer1.gif" WIDTH="593" HEIGHT="461"><p>
<a NAME="HEADING1-48"></a>
<h1>6.3  Column formation</h1>
 The placement strategy is first to form columns of related transistors. Related transistors are: MOS transistors that are connected by their gates, MOS transistors that have their source and drain interconnected (pass pair) or bipolar transistors that share connections. Then to form groups joining columns of MOSFETs that share drain or source connections. And finally to perform the layout of each cell by placing the groups using genetic algorithm techniques and calling Router <i>agent servers</i> to route them.<p>
 There are three kinds of<i> agent objects</i> for placement: the Cont <i>agent object</i> controls all the operations; the Abutted <i>agent object</i> first builds columns of related transistors and subsequently tries to unite with other Abutted agents to form groups, and the Eval <i>agent object</i> uses the genetic algorithm (GA) to find a good placement for the groups.<p>
 The Cont agent coordinates all the actions. It receives the new circuit, after it has been interpreted from EDIF as a list. It separates the NMOS, PMOS and bipolar transistors and general cells in different lists and creates the first Abutted agent.<p>
 An Abutted agent has two behaviours. When it is created it performs its first behaviour: it goes to the lists of available cells, in the Cont agent, and grabs the first cell it can obtain in the following order: NMOS, PMOS, bipolar or general cells. Then it tries to create the biggest possible column following the rules:<p>
<ul>
<li><b>To make a gate-connected MOSFET column:</b> if it obtained a PMOS transistor, it tries to obtain other PMOS that have their gate connected to the first one. When there are no more PMOS transistors, it tries the NMOS. If it begins with a NMOS transistor, it tries only the NMOS transistors, the PMOS list is already empty. <p>
<li><b>To make a pass pair MOSFET column:</b> if the Abutted agent obtained a single transistor and could not make a column of gate connected transistors out of it, it tries to obtain other ones that form a pass pair with the first one. A pass pair are two transistors that have their source and drain interconnected.<b></b><p>
<li><b>To make a column of bipolar transistors:</b> if all MOSFETs have already been processed, the Abutted agent obtains a bipolar transistor and tries to find another that has interconnections with the first to form a column.<p>
<li><b>To get a general cell:</b> if all the transistors have been used, the Abutted agent obtains a cell. They do not try to join cells together, since there can be only one per agent.<p>
</ul>
 These rules are followed in sequence, when an Abutted agent is created it first tries to grab MOSFETs, then transistors and, at the end, cells. When an agent forms its column of MOSFETs, or of bipolar transistors or gets a cell, it stops and tries to reproduce. If there are more cells to be obtained in the Cont agent, a new Abutted agent is created and it tries to obtain its own set of cells. Abutted agents behave like a culture of bacteria, they keep reproducing until there is no more food.<p>
 Figure <a HREF="#nonexistent-marker">6.2</a> shows the moment when a new Abutted agent is created. There are no more MOSFETs available (PMOS and NMOS lists are empty). The agent is then attempting to grab a bipolar transistor from the bipolar list. At least one more agent will be created to grab the only element of the general list.<p>
<img SRC="placer2.gif" WIDTH="583" HEIGHT="476"><p>
<a NAME="HEADING1-59"></a>
<h1>6.4  Group formation</h1>
 When the column creation process finishes, the Cont agent switches the Abutted agents to their second behaviour. The Abutted agents will now try to pair up with other agents joining their cells. To pair up, two agents have to share a number of source/drain interconnections. The idea is to join columns of MOSFETs, by either the source or the drain sides. In this way these MOSFETs can be laid out in parallel strips of diffusion, they can be abutted. Only Abutted agents holding MOSFETs' columns can pair up, but not all of them have to pair up. At the end there can be agents holding just one cell.<p>
 The group formation process is performed in cycles controlled by the Cont agent. In this process only Abutted agents holding columns of MOSFETs are considered. In each cycle, the Cont agent goes through the list of Abutted agents, exposes each agent to the others and asks the other agents how well they connect to this agent. Each agent then creates a report showing its situation relating to the exposed agent. This report states if a match is possible, how good this match is and details how it should be implemented. At the end of a cycle, the two agents that have the best connections between each other are joined. These cycles continue until no agents can be joined or the quality of the possible connections is too poor.<p>
 Figure <a HREF="#nonexistent-marker">6.3</a> shows the report and joining stages in more detail. During this particular report stage, agent <code>Abutted</code> <code>#5</code> was exposed and agent <code>Abutted</code> <code>#8</code> created a report about their match. They have two possible connections through nodes 1 and 2. The joining report has two parts: a list, containing the line's connection order, and the sides of the connection. The list contains pairs of connecting lines. In the example from figure <a HREF="#nonexistent-marker">6.3</a>, the report states that, in a connection between the two agents, two lines will be joined: line 0 of <code>Abutted</code> <code>#8</code> will connect to line 1 of <code>Abutted</code> <code>#5</code> and line 1 of <code>Abutted</code> <code>#8</code> will connect to line 0 of <code>Abutted</code> <code>#5</code>. Also it states that the drain side of <code>Abutted</code> <code>#8</code> should join the drain side of <code>Abutted</code> <code>#5</code>. Source side means the right side, and drain side means the left side.<p>
<img SRC="placer3.gif" WIDTH="575" HEIGHT="599"><p>
 In this particular case, the report was the best one and the two Abutted agents are joined. As the report states that the two agents should be joined by their left side, and because any two groups of MOSFETs only can be joined left to right, the group of MOSFETs belonging to <code>Abutted</code> <code>#5</code> will be mirrored in relation to the Y axis. After this transformation, <code>Abutted</code> <code>#5</code> connection side becomes right and the connection is possible. To connect each line properly the program uses the connection description list from the report.<p>
 After the grouping of cells has finished, the Cont agent contains a list of Abutted agents holding groups of cells. It then takes these cells from the agents and puts them in a list. The Abutted agents are then destroyed. The next step is to place the groups of cells in the empty design (Top of figure <a HREF="#nonexistent-marker">6.1</a>).<p>
<a NAME="HEADING1-65"></a>
<h1>6.5  The genetic algorithm placement</h1>
 Up to now, only topological relationships between the cells of the design have been exploited to create the groups of cells held by the Cont agent, no grid or position coordinates have been determined for them. This groups will be now placed and this placement optimized using the genetic algorithm (GA) encapsulated in the Eval <i>agent object</i>.<p>
 The inputs for the Eval agent are an empty design and a list holding the groups of cells to be placed. The empty design is the same received by the server and shown in figure <a HREF="#nonexistent-marker">6.1</a>. The list of groups comes from the Cont agent and it holds three kinds of groups of cells: arrays of MOSFETs, a list of bipolar transistors and individual general cells (fig. <a HREF="#nonexistent-marker">6.4</a>). The Eval agent has to position them in the empty design in the best possible way.<p>
<img SRC="placer4.gif" WIDTH="488" HEIGHT="379"><p>
 Before describing the actual algorithm implementation, some steps should be defined because they are closely related to the system being optimized. There are four main points to be defined: encoding, genetic operations, evaluation and classification.<p>
<a NAME="HEADING1-69"></a>
<h2>6.5.1    Encoding</h2>
 Each individual solution in the population is represented by a set of numbers and this representation should be as robust as possible. Figure <a HREF="#nonexistent-marker">6.5</a> shows an individual and the chromosome that represents it.<p>
<img SRC="placer5.gif" WIDTH="601" HEIGHT="852"> <p>
 The chromosome is not represented by a string, as would be expected, but by a list. This is done to avoid Hamming cliffs and to enhance robustness. As the top of figure <a HREF="#nonexistent-marker">6.5</a> shows, the elements of this list represent each group being laid out in the cell, with the groups laid out in the same order as they appear in the list. For each group there is another list describing how that particular group will be laid out. This list has the following elements:<p>
<ul>
<li><b>Group number</b> is the position (integer) of the group in the group list, the list that holds the description of all groups.<p>
<li><b>Flip flag</b> is a flag (symbol) that indicates if the group is to be flipped or not, to be flipped means to be mirrored in the Y axis.<p>
<li><b>Line list</b> is a list with the order that the lines in the group should be laid out. Lines in a group can be freely swapped and will be laid out in the order they appear in the list.<p>
<li><b>Dx</b> represents the distance (integer) between this group and the last group laid out.<p>
<li><b>Dy</b> represents the distance (integer) between the group and the Y axis.<p>
<li><b>Gap</b> represents the distance (integer) added to either the minimum separation between PMOS and NMOS transistors in the case of a group holding an array of them or to the minimum separation between two bipolar transistors in the case of a group holding a list of bipolar transistors.<p>
</ul>
 With the information provided by the chromosome, the individual, shown in figure <a HREF="#nonexistent-marker">6.5</a>, is laid out on the design, in this case, containing only the pads (Vss, Vee, Input and Output). Figure <a HREF="#nonexistent-marker">6.6</a> shows the actual circuit placement.<p>
<img SRC="placer6.gif" WIDTH="725" HEIGHT="674"><p>
<a NAME="HEADING1-79"></a>
<h2>6.5.2    Genetic operations</h2>
 The way the genetic operations are carried out is dependent upon the chosen encoding for the genes. The chosen encoding, in this case, was a list and this affects the way cross-over and mutation are performed. <p>
 As figure <a HREF="#nonexistent-marker">6.7</a> shows, when two individuals mate, their genetic material mix, in this case the list containing placement information for each group. A parent is chosen randomly to be the main parent, the order of the groups in its chromosome will determine the order in the offspring chromosome. In figure <a HREF="#nonexistent-marker">6.7</a>, <code>parent</code> <code>1</code> was chosen as the main parent, the order of groups in the offspring reassembles its own, but the actual group's placement information came randomly from both parents. Indeed, in this particular example, only group 3 came from <code>parent</code> <code>1</code>.<p>
<img SRC="placer7.gif" WIDTH="552" HEIGHT="250"><p>
 After an offspring is generated, swap and mutation operations can be applied. At the top level, mutation can be used to swap the position of some groups in the offspring. Inside each group description, cross-over and mutation can happen. The <code>FLIP</code> flag can be changed by mutation and the group's lines can be swapped. The distances <code>Dx</code>, <code>Dy</code> and gap can be swapped among the groups or just changed.<p>
 Cross-over and mutation operations can generate illegal individuals. Illegal meaning placements that violate design rules. When evaluated they will be classified as &quot;born dead&quot; individuals and will not be added to the population list. It is not possible, at the mating stage, to detect all &quot;born dead&quot; configurations, however the ones that produce out of boundaries placement of cells can be detected and corrected.<p>
 To correct them, the program calculates the length of all cells and subtracts it from the length of the available area for placement. This gives the available free space between cells. This space is then divided by the number of cells plus one, which gives the average separation in between the cells and from them to the border of the placement area. The routine then calculates the space left between the last placed cell in the offspring and the border of the available area. If this value is negative it means that the cells are overflowing the available area. If this value is too big, it means that all cells are crowded in one end of the available space (fig. <a HREF="#nonexistent-marker">6.8</a>).<p>
<img SRC="placer8.gif" WIDTH="460" HEIGHT="535"><p>
 Figure <a HREF="#nonexistent-marker">6.8</a> shows what the program does to correct the placement. The routine randomly chooses one of the group of cells, then, using the average separation calculated before as a base value, it randomly takes a percentage of the base value and subtracts or adds (depending if the cell is overflowing or crowded) this value to the group's Dx (at maximum adding or subtracting 50% of Dx). It repeats this operation until the space left between the last cell and the available area is neither negative nor too big.<p>
 The same operations are repeated for the Dy and Gap distances, the only differences being that these operations have to be undertaken for each group of cells and the distance to be adjusted is the distance from the top of the cell and the top of the available placement area. In this case Dy and Gap are altered until the cell fits in the space.<p>
<a NAME="HEADING1-87"></a>
<h2>6.5.3    Evaluation</h2>
 The new individuals created should be evaluated to find how good their placement is. This step is more closely related to the system being optimized than to the algorithm itself. The best way of doing the evaluation would be by actually routing each placement using the Router <i>agent server</i>. Unfortunately the routing process is slow and would take too long to evaluate all candidates. In place of full routing a method is used to estimate the cost of wiring the circuit. The objective of this method is to evaluate how much a particular placement contributes for the total length of wire and to the amount of crossing among the wires of the circuits. Figure <a HREF="#nonexistent-marker">6.9</a> shows the wire connection as straight lines in a &quot;rat's nest&quot; fashion, from that projection one can see how much this particular placement will influence the routing process.<p>
<img SRC="placer9.gif" WIDTH="434" HEIGHT="359"><p>
 To get a similar effect, the evaluation routine uses the same wiring algorithms, that the router uses, but it allows crossing over and short circuits to take place and it does not test for design rule violations. All connections are carried out with the smallest wire possible, changes of layer, however, are undertaken whenever necessary.<p>
 As the evaluation pseudo routing takes place, the cost of the wires is being computed. The routine that calculates the cost of each wire is the same that is used by the router. The number of crossings of each new wire with all the old ones, already laid out, is accumulated. At the end, the evaluation routine has the total cost of the pseudo routing and the total number of crossings. Each placement will be judged by these two values.<p>
<a NAME="HEADING1-91"></a>
<h2>6.5.4    <a NAME="MARKER-9-15"></a>Classification</h2>
 After evaluation, each placement or &quot;individual&quot; has two values: the total wire cost and the number of crossings. The whole population of individuals is kept in a list, which is ordered by fitness, the fittest individuals coming first in the list. Every new individual has to be appended to this list in the appropriate position. There is another list holding the evaluation values of each individual in the same order as in the population list. The classification routine goes through this list, calculating a fitness value from each individual evaluation value, and comparing it with the new individual fitness. The routine can give different weights to each evaluation value when calculating the fitness, which can make some characteristics more important than others. After an individual's position has been found, the routine appends it and its evaluation values in the same position to respective lists.<p>
 As discussed in chapter <a HREF="#nonexistent-marker">5</a>, the offspring produced by genetic manipulation (the next population to be evaluated) could either replace the whole population (generational approach) or just its less fitted members (steady-state approach). The steady-state approach was implemented here, because the processing time to evaluate each individual is high, which leads to the use of a relatively small population. The program could not afford to kill all individuals from one generation to the next. New individuals are then continuously appended to the population list. When the population reaches a predetermined maximum number, half of it is killed.<p>
 The fitness of an individual, and thus its position in the population list, determines its probability of reproduction and death. As figure <a HREF="#nonexistent-marker">6.10</a> shows, as the position of an individual in the population list increases, its probability of reproduction decreases and its probability of death increases. Both probabilities depend solely on the individual's position in the list, not on its actual fitness value. The two probabilities vary following the normal distribution. To generate the random numbers in such a distribution, the output of a function that generates random numbers between 0 and 1 with equal probability (r) is used as an argument for the erf function:<p>
<img SRC="placer10.gif" WIDTH="585" HEIGHT="301"><p>
<pre>
<img SRC="equation.gif" WIDTH="504" HEIGHT="110"><p>
<!
<I?
<MATH?
Rnumber = erf(r OVER sigma)
</MATH?

, where </I?
<MATH?
erf(x) = 2 OVER (SQRTpi)&INT;<SUB?0</SUB?<SUP?x</SUP?e<SUP?-t<SUP?2</SUP?</SUP?dt
</MATH?

     <B?      <I?and </I?</B?
s<I? is the standard deviation of the distribution<B?.</B?</I?
>

</pre>
 To find an individual for reproduction or death:<p>
<pre>
<i>Ind<samp>reproduction= round((1-Rnumber)*Total), Inddeath= round(Rnumber*Total)</samp></i>.
</pre>
 The normal distribution was chosen because it is the distribution used by nature. Whenever individuals are chosen to reproduce or die one of these two probabilities is always used. It means that an unfit individual can reproduce and a fit one can die, but these events have a very small probability of taking place.<p>
<a NAME="HEADING1-101"></a>
<h2>6.5.5    The algorithm implementation</h2>
 Once the four steps, encoding, genetic operations, evaluation and classification, are defined the actual algorithm implementation is basically that described in Chapter <a HREF="#nonexistent-marker">5</a>.<p>
 As stated earlier, the inputs for the Eval agent are an empty design and a list holding the groups of cells to be placed. When this agent is created it generates four individuals by placing then randomly. These individuals are then evaluated and classified and become the population.<p>
<img SRC="placer11.gif" WIDTH="606" HEIGHT="431"><p>
 The Cont agent can use the Eval agent's method <code>run</code> to run a certain number of generations. This cycle (fig. <a HREF="#nonexistent-marker">6.11</a>) is very similar to the one described in figure <a HREF="#nonexistent-marker">5.2</a>. The main difference is the classification stage. This new cycle takes into account the position of an individual in the population list which determines its probability of reproducing or dying, not its actual fitness value. This is similar to nature: fitness only gives a better chance of survival, it does not guarantee it. The stages depicted in figure <a HREF="#nonexistent-marker">6.11</a> are:<p>
<ul>
<li><b>Selection</b> - Two individuals are chosen to mate from the population. The probability of an individual being chosen is greater for the ones in the beginning of the population list (section <a HREF="#MARKER-9-15">6.5.4</a>).<p>
<li><b>Genetic Operations</b> - The genetic material is mixed using cross-over and mutation. If clones are generated (individuals identical to one of the parents) the process is repeated.<p>
<li><b>Evaluation</b> - The resulting genetic description is translated into a placement and then evaluated. Placements that are illegal are considered &quot;born dead&quot; and are not included in the population.<p>
<li><b>Classification</b> - The result of the evaluation is classified in relation to the results of the other members of the population, according to the fitness criteria.<p>
<li><b>Population</b> - The offspring enters the population list in its proper position.<p>
</ul>
 The cycle is repeated until a certain number of generations has been tried. This number of generations is variable, it is determined by the Cont agent when it calls the Eval agent method <code>run</code>.<p>
<a NAME="HEADING1-111"></a>
<h1>6.6  The placement routing cycle</h1>
 The Cont agent refines the placement of a circuit by doing placement/routing cycles. First, the Cont agent runs a number of generations in the Eval agent to produce a placement for the design and then it sends it to a Router <i>agent server</i>. This cycle is repeated until a Router server produces a fully routed design. <p>
 All the communication and resource management of the Router servers is undertaken by the RouterComm object (fig. <a HREF="#nonexistent-marker">6.12</a>). When it receives a design to route the object tries to find a free Router server. If there is none it requests a new one from the Broker <i>agent server</i>. When a Router server is available, the RouterComm object sends the placed design to it. In each cycle, the RouterComm checks if any Router server has already finished its wiring. If one has and the routing was successful, the completed design is returned to the client and the Placer server stops. If the routing failed, this Router server is marked free and can be used for wiring another design.<p>
<img SRC="placer12.gif" WIDTH="601" HEIGHT="448"><p>
 If the RouterComm object doesn't have any free Router servers available and the Broker server refuses to give it a new one, the program stops until a Router becomes available.<p>
<img SRC="placer13.gif" WIDTH="730" HEIGHT="708"><p>
 The Placer server finishes, when a design is successfully routed, an error condition occurs or if it has been trying to route for a number of generations unsuccessfully. Figure <a HREF="#nonexistent-marker">6.13</a> shows a placed/wired design ready to be returned to a client application by the server. If successful the server returns the placed/wired circuit:<p>
<pre>
<code>(edif</code> <code>shiftreg.cir</code> <code>(design shiftreg</code> ...<code>))</code>
</pre>
 If it fails it returns the statement:<p>
<pre>
<code>(list sorry)</code>
</pre>
 In both cases the server stops and waits for further commands from the client application.<p>
<dl>
<dt><a HREF="placer.html#HEADING1-1"><b>6.1 </b> - Introduction</a><dd>
<dt><a HREF="placer.html#HEADING1-8"><b>6.2 </b> - The EDIF description</a><dd>
<dt><a HREF="placer.html#HEADING1-48"><b>6.3 </b> - Column formation</a><dd>
<dt><a HREF="placer.html#HEADING1-59"><b>6.4 </b> - Group formation</a><dd>
<dt><a HREF="placer.html#HEADING1-65"><b>6.5 </b> - The genetic algorithm placement</a><dd>
<dt><a HREF="placer.html#HEADING1-69"><b>6.5.1   </b> - Encoding</a><dd>
<dt><a HREF="placer.html#HEADING1-79"><b>6.5.2   </b> - Genetic operations</a><dd>
<dt><a HREF="placer.html#HEADING1-87"><b>6.5.3   </b> - Evaluation</a><dd>
<dt><a HREF="placer.html#HEADING1-91"><b>6.5.4   </b> - Classification</a><dd>
<dt><a HREF="placer.html#HEADING1-101"><b>6.5.5   </b> - The algorithm implementation</a><dd>
<dt><a HREF="placer.html#HEADING1-111"><b>6.6 </b> - The placement routing cycle</a><dd>
</dl>

<hr>

<pre><h3><a HREF="router.html"><b><img SRC="next.gif" WIDTH="40" HEIGHT="40"> Next</a>            <a HREF="contents.html"><b><img SRC="book.gif" WIDTH="40" HEIGHT="40"> Contents</a>       <a HREF="mailto:d.moreira@ieee.org"><b><img SRC="comments.gif" WIDTH="40" HEIGHT="40"> Talk to me</a></h3></pre>

</body>
</html> 