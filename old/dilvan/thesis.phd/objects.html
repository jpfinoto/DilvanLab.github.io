<!-- Generated by Harlequin Webmaker 2.1.3; Harlequin Transducer 1.0 --> 
<html> <head>
<title>Agents Object Oriented Structure</title>
</head>
<body BGCOLOR="#FFFFFF">
<a NAME="HEADING1"></a>

<h1>Chapter 2: Agents <a NAME="MARKER-9-6"></a>Object Oriented Structure</h1>
<hr>
<a NAME="HEADING1-1"></a>
<h1>2.1  Introduction</h1>
 Object orientation is a technique well suited for system modelling. The word system here has a wide meaning, being either a dedicated software system or any organizational system (such as a company or a football team). Using object-orientation as a base, one can model the system as a number of objects that interact <a HREF="Refer.html#REF-20">[20]</a>. Hence, irrespective of the type of system being modelled, one regards its contents as a number of objects which in one way or another are related.<p>
 The world around us can be seen as objects, such as people, houses, cars which are in many ways related to each other. What the objects model depends on what one intends to represent. A model of our world can be represented equally well by loan, credit, stock and share objects, if one is interested in financial markets. The objects chosen will then be dependent on what the object model is intended to represent.<p>
 People tend to think about the world in terms of objects, and therefore it is simpler for them to do the same when representing a data model. Such a model, based on an object-oriented approach, is easier to understand because it is more closely related to reality. Such a design method will have a small semantic gap between the model and reality, as shown on figure <a HREF="Objects.html#FIG-1">2.1</a>. On the top of the figure are the real life objects, with many attributes, such as colour, size, functionality, and at the bottom the data structure that captures only the real life objects' characteristics and relationships relevant to a certain computational task. The semantic gap is the difference between how completely a model represents reality and reality itself. The closer the object oriented model is related with reality, the smaller the semantic gap.<p>
 <a NAME="FIG-1"><img SRC="objects1.gif" WIDTH="732" HEIGHT="584"><p></a>
 The smaller the gap, the easier the system is to understand and modify. Modifications will tend to be local, affecting one or few individual items, which are represented by code isolated in objects.<p>
<a NAME="HEADING1-7"></a>
<h1>2.2  Objects</h1>
 The object is the most important concept in this chapter. The word object is used in nearly all contexts. What the concept means here is an entity able to save a state (information) and which offers a number of operations (behaviours) to either examine or affect this state. <p>
 In an object oriented model, the components of the modelled system are represented by a number of objects. These objects usually correspond to real life entities, such as a share, an invoice, or a customer.<p>
 One can associate information (states) and operations (behaviours) to each object. For instance, an <code>Invoice</code> object can hold information such as the name of the company to be invoiced, the invoice value or tax deductions. It can have a set of operations to modify this information and to perform behaviours such as billing the customer account or warning that a bill is overdue. The only part of an object accessible from the outside should be its operations, its inside should be hidden from the outside world. Outside objects just use those operations, they can not see how they work (fig. <a HREF="#nonexistent-marker">2.2</a>). Only when one looks inside an object, can a person see how it implements its operations.<p>
<a NAME="FIG-2"><img SRC="objects2.gif" WIDTH="557" HEIGHT="419"><p></a>
 Amongst the information an object holds are any associations with other objects. For example, the <code>Invoice</code> object may hold a <code>Person</code> object to represent the customer. The model's objects have relations with each other. A family, for instance, can be represented as an object, called <code>Family</code>, that holds a grouping of objects called <code>Man</code>, <code>Woman</code> and <code>Child</code>, that have the relationship of belonging to the same family. The object <code>Family</code> represents this particular aggregate, but it is not the aggregate itself. An aggregate is a union of several objects, and such an union can often be represented by an object of its own. For instance, the object <code>Football</code> <code>Team</code> can be built to hold twelve objects of type <code>Man</code>, and to express the particular relationship these twelve men have to each other. This relationship can be expressed in various forms, such as the group behaviour of playing football.<p>
 The internal workings of any object are only available when someone looks into them. This includes their information structure, their constituent parts and how the behaviour for the operations is defined.<p>
 The dynamics in an object oriented model are created by means of stimuli to or from other objects. A stimulus is the event when an object communicates with another object. In a programming context, the word <i>message</i> is used. An object sends messages to other objects, and has operations triggered by messages sent from them. These operations can in turn cause new messages to be sent. For example, if the object <code>Invoice</code> is required to bill the customer it will receive a stimulus that will trigger this behaviour, if <code>Invoice</code> is written in a language that implements message passing (such as Smalltalk) this stimulus will be a message. Complicated behaviours will fire many stimuli between many objects. If we send the message <i>play</i> to the object <code>Football</code> <code>Team</code> it will send many messages to each object <code>Man</code>, which in turn will send many messages between themselves and to other objects outside <code>Football</code> <code>Team</code>. <p>
 All information in an object oriented system is stored inside objects and can only be modified when objects receive messages to do so. The behaviour and information are encapsulated in the objects. Objects support the concept of information hiding, they hide their internal structure from outsiders. To use an object one only needs to know which operations it offers. For example, if a object oriented graphics library is used by an object oriented application the routines in the library can be changed at will. The application program code will not be affected provided that the messages that the library accepts are still the same. Encapsulation insures that the application writers do not know anything about the library implementation and thus can not write implementation dependent code. Encapsulation means that all that can be seen of an object is its interface (the operations it can perform).<p>
 These concepts have their roots in abstract data types. They are structures with a number of operations that affect them. Both, objects and abstract data types, are abstractions and are defined in terms of what they do, not how they do it. One of the advantages is that one should be able to use them independently of their implementation. This means that even if the implementation is modified, it shouldn't be necessary to change the way the abstract data types are used. Another advantage is the reduction in complexity as the users have no possibility of becoming involved in the objects internal affairs but should only have the ability to use them according to their specifications.<p>
<a NAME="HEADING1-16"></a>
<h1>2.3  Class</h1>
 Objects in a system will share common characteristics and it will be possible to group them accordingly. Looking at the object <code>Football</code> <code>Team</code>, one can see that its objects (the eleven players) share similar behaviours and structure. All can jump, talk, kick, etc. These objects have the same mould or template. Such a group represents a class. In Jacobson <a HREF="Refer.html#REF-20">[20]</a> a class is a definition, a template or a mould to enable the creation of new objects and is, therefore, a description of the common characteristics of several objects. <p>
 Using the concept of class, characteristics can be associated with a whole group of objects. A class can then be described as an abstraction that describes all the common characteristics of the objects forming part of it.<p>
 An object that belongs to a class is called an instance of that class. The players in the object <code>Football</code> <code>Team</code> are instances of the class <code>Man</code> (fig. <a HREF="#nonexistent-marker">2.4</a>). The information structure and behaviour of an object is defined by its class, but each instance has a unique identity. Different instances can receive different sequences of stimuli and, as a result, have different internal states.<p>
<a NAME="FIG-3"><img SRC="objects3.gif" WIDTH="499" HEIGHT="569"><p></a>
 All players are instances of the same class <code>Man</code>, and therefore will have the same behaviour. If one wishes to create a female football team and describe the fact that men and women have different behaviour, another class, <code>Woman</code>, has to be created. For this new class, behaviour and structure should be described, and a lot of this information will be just a repetition from the description of the class <code>Man</code>. Elements such as name or age are the same for the two classes.<p>
<a NAME="HEADING1-21"></a>
<h1>2.4  Inheritance</h1>
 As stated earlier, if the two classes <code>Man</code> and <code>Woman</code> are compared they will have a lot of common information. This common information can be shared by the classes by extracting them and putting them in another class. In this new class called <code>Person</code>, everything that is common to <code>Man</code> and <code>Woman</code> is described, in this way common characteristics can be shared by many classes. All the common characteristics are collected under one specific class and the original classes (in this case <code>Man</code> and <code>Woman</code>) inherit from it. As they inherit the common characteristics, <code>Man</code> and <code>Woman</code> only need to implement the characteristics unique to them, for example behaviours, such as <i>dance</i> and <i>walk</i> can be defined differently for each. The two classes contain the same things as before, but their description is simplified by inheritance from <code>Person</code> (fig. <a HREF="#nonexistent-marker">2.4</a>).<p>
<a NAME="FIG-4"><img SRC="objects4.gif" WIDTH="446" HEIGHT="567"><p></a>
 Using inheritance, common descriptions can be reused, promoting the concept of code reusability <a HREF="Refer.html#REF-22">[22]</a>. And as descendant classes only implement the extra information that differentiates them, inheritance cuts redundancy, leading to smaller, easier to understand systems. Another advantage is that, if it is necessary to change some characteristic in the class <code>Person</code> (e.g. how a person talks), it is sufficient to do the modification in one place. When the modification is implemented <code>Man</code> and <code>Woman</code> automatically inherit it. This helps create models that are easier to modify and evolve.<p>
<a NAME="HEADING1-24"></a>
<h2>2.4.1    Multiple inheritance</h2>
 Let us assume that one wants to build a new class for female teachers from the class <code>Woman</code>. Teachers can be male or female and women can have many other professions apart from teaching. When describing a new class, if one needs characteristics from two other classes, it is possible to inherit from both of them. Multiple inheritance means that one class can have more than one direct ancestor. In the present example the new class <code>FemaleTeacher</code> would inherits all woman operations from the class <code>Woman</code> and the all the teacher's operations from the class <code>Teacher</code>. Only information concerning female teachers would have to be added.<p>
 Multiple inheritance permits the combination of the functionality of different classes into one, but it has its problems. If each of the ancestor classes have a method with the same name, let's say a method called print. This method prints the class representation in the standard I/O. From which ancestor will the derived class inherit this method? It can not inherit from both. And if the ancestors have internal variables with the same name, how can the derived class name them? Unfortunately there isn't a standard way for dealing with this problem and each object oriented language offers a different solution.<p>
<a NAME="HEADING1-27"></a>
<h1>2.5  Polymorphism</h1>
 Objects in a system will stimulate each other and their behaviour as a whole will be the system behaviour. Instances can have information about other instances they send messages to, but if an instance doesn't have to be aware of which class the receiving instance belongs to, we have polymorphism. Polymorphism means that the sender of a stimulus does not need to know the receiving instance's class. The receiving instance can belong to an arbitrary class <a HREF="Refer.html#REF-20">[20]</a>. <p>
 The class <code>Person</code> performs the operation <code>Get</code> <code>Person</code>'<code>s</code> <code>Name</code> (fig. <a HREF="#nonexistent-marker">2.4</a>), all classes derived from it inherit this operation. If an object wants to query about a person's name, it doesn't matter if the object receiving this query will be from the class <code>Man</code>, <code>Woman</code> or <code>FemaleTeacher</code>, all of them should implement the operation.<p>
 It is up to the receiver of a stimulus to determine how it should be interpreted, not the transmitter. The transmitter needs only to know that another instance can perform a certain behaviour, not which class it belongs to nor which operations will perform that behaviour. Only what should occur is specified, not how it should be implemented. In this way flexible and modification resistant systems can be implemented. If a new object from a new class is added, this modification should only affect this new object not those who send stimuli to it.<p>
<a NAME="HEADING1-31"></a>
<h1>2.6  Object Oriented Programming</h1>
 To define what is object oriented programming is very difficult. It is essentially a style of programming. An object oriented system can be implemented in a standard procedural language, like C. An implementation in an object oriented language, however, would profit from the better representation of the core concepts (like objects and classes) and from facilities such as inheritance.<p>
 An object oriented language should support, at least, the following core concepts of object orientation:<p>
<pre>
                    Encapsulated objects
                    Class and instance concepts
                    Inheritance between classes
                    Polymorphism
</pre>
 There are many object oriented languages around, such as Smalltalk <a HREF="Refer.html#REF-27">[27]</a>, Eiffel <a HREF="Refer.html#REF-29">[29]</a>, CLOS <a HREF="Refer.html#REF-30">[30]</a> or Objective C <a HREF="Refer.html#REF-28">[28]</a>. Different languages have chosen different solutions for different problems, and they support object orientation concepts in different ways. This makes some languages more suited for some applications than others.<p>
 C++ was the language of choice for this application for many reasons:<p>
<ul>
<li><b>Compatibility</b> - C++ is compatible with ANSI-C, it inherits its basic language mechanisms such as functions, arithmetic, selection statements and looping constructs <a HREF="Refer.html#REF-23">[23]</a>. C++ is more an evolution of C to deal better with object oriented programming than a complete new concept (like Smalltalk). Indeed one can write ANSI-C programs in C++. This compatibility allows the reuse of C programming expertise and the use of libraries and programs already written in C. And, as C is a very popular language in the VLSI software field, this compatibility becomes a big asset.<p>
<li><b>Efficiency</b> - Again because it is an object oriented extension to the language C, C++ inherits its efficiency. As C, C++ allows the user a great deal of control. If, on one hand, this increases the development burden for the programmers (C++ isn't a language for rapid prototyping) on the other hand it allows a better use of the resources available. C++ inherits many of the C language's performance compromises.<p>
<li><b>Portability</b> - C++ is becoming a very popular language, not only in the object oriented world but mainly in the mainstream language market. There are many popular implementations in all popular operational systems, such as Visual C++ (Microsoft), Borland C++ for Windows-Dos; Gnu G++, SunSoft C++, for Unix. Objective C, for instance, has the same C ascendence and advantages but lacks the widespread availability of C++.<p>
</ul>
 In addition to these characteristics, C++ is a fully fledged object oriented language, supporting all four core object oriented concepts. The following subsections show how C++ can implement each concept. They do not try to show how the whole language works. A complete definition of the language and related programming techniques can be found in <a HREF="Refer.html#REF-23">[23]</a>, <a HREF="Refer.html#REF-24">[24]</a> and <a HREF="Refer.html#REF-26">[26]</a>.<p>
<a NAME="HEADING1-40"></a>
<h2>2.6.1    Objects</h2>
 In C++ an object is implemented internally as a number of variables which stores information and a number of operations for the object. In opposition to pure object oriented languages, like SmallTalk, in C++ internal variables can be made accessible from outside. Each object is able to receive a certain number of stimuli, in C++ this is done by calling one of the object's public functions. An object can be referenced by its name or address. A call to an object <code>Invoice</code> would look as follows:<p>
<pre>
By name: invoice.billAccount();
By address reference: invoicePtr-&gt;billAccount();
</pre>
<a NAME="HEADING1-44"></a>
<h2>2.6.2    Classes and instances</h2>
 Objects are described by classes. They are both a module for source code and a type for the class instances. In C++ classes are user defined types. An example of a class <code>Invoice</code> would look as follows:<p>
<pre>
class Invoice {
 float value;
 char* customerName;
public:
 char*  getCustomerName();
 void  billCustomer();
 void  printInvoice();
};
</pre>
 In this class two variables, <code>value</code> and <code>customerName</code>, and three functions, <code>getCustomerName</code>, <code>billAccount</code> and <code>printInvoice</code>, are declared. In this particular case, only the functions are accessible from outside the class instances, because they were declared public. Functions and variables can be defined as in C, just by adding a reference to the class, as in:<p>
<pre>
char* Instance::getCustomerName() { &lt;function body&gt; }
</pre>
 Instances can be declared or created by the operator new, in this case this operator returns a pointer to the instance:<p>
<pre>
Declared: Invoice invoice1;
Created:    Invoice* invoicePtr= new Invoice;
</pre>
<a NAME="HEADING1-59"></a>
<h2>2.6.3    Inheritance between classes</h2>
 Inheritance means that another class can be derived from a existing one, just stating how it differs from it. The class from which another class is derived becomes its base class. Assume that a new class <code>Invoice</code> is needed, which is able to bill someone over the Internet using e-mail. It differs from <code>Invoice</code> just on the operations dealing with the network. A possible declaration would be:<p>
 <p>
<pre>
class InvoiceEmail: public Invoice{
 char* emailAddress;
public:
 void setEmailAddress(char*);
 void billCustomer();
};
</pre>
 This class declaration states that <code>InvoiceEmail</code> descends from <code>Invoice</code>. The new class inherits all functions and variables of <code>Invoice</code>. It adds the variable <code>emailAddress</code> to hold the customer e-mail address. It also adds as well a new function <code>setEmailAddress</code> to change the e-mail address, and overrides the <code>Invoice</code>'s function <code>billCustomer</code> to allow the new way of billing. The C++ override feature allows the substitution of a function in the ascendent class for a new one defined in the new class.<p>
<a NAME="HEADING1-69"></a>
<h2>2.6.4    Polymorphism</h2>
 In C++ pointers to a base class can be used to refer objects of a derived class. Polymorphic behaviour can be implemented in C++ using this feature and virtual functions. Virtual functions allow the declaration of functions in a base class that can be redefined in each derived class. The compiler and loader will guarantee the correct correspondence between objects and functions applied to them <a HREF="Refer.html#REF-23">[23]</a>. For example, in the last case, if the new function <code>billCustomer</code> in the class <code>InvoiceEmail</code> is to be used, a variable of type <code>InvoiceEmail</code> or a pointer of type <code>InvoiceEmail*</code> has to be used. But if the class <code>Invoice</code> is redefined as:<p>
<pre>
class Invoice {
 float value;
 char* customerName;
public:
    char*  getCustomerName();
 virtual  void     billCustomer();
    void  printInvoice();
};
</pre>
 The function <code>billCustomer</code> becomes virtual. Now if a general pointer of type <code>Invoice*</code> is created and used to point to objects of classes <code>Invoice</code> and <code>InvoiceEmail</code>, when the function <code>billCustomer</code> is called, the compiler will use the correct version for each case:<p>
<pre>
Invoice* invoicePtr; 
invoicePtr= new Invoice;
invoicePtr-&gt;billCustomer();           // Calls the function in Invoice;
   ...
invoicePtr= new InvoiceEmail;
invoicePtr-&gt;billCustomer();           // Calls it in InvoiceEmail;
</pre>
 The programmer doesn't have to know which kind of object is pointed by <code>invoicePtr</code>, he just needs to know that the function <code>billCustomer</code> will bill a customer, it is up to the receiving object to decide how to implement it.<p>
<a NAME="HEADING1-87"></a>
<h1>2.7  Agents' basic structure</h1>
 At the implementation level, object orientation means encapsulating data structure with related functions and using the notion of stimuli by message passing or, in C++ case, by function calling to accomplish the task of programming. Object oriented design means turning the software requirements into specifications for objects and derived class hierarchies from which the objects can be created. The problem becomes how to find the objects <a HREF="Refer.html#REF-19">[19]</a>.<p>
 In any realistic software project, changes are all but inevitable. Also, the nature of the human creative process is inherently evolutionary. The usual human approach to a new programming task is to go through an interactive process of analysing the problem, implementing it, and then refining the design. Prototypes or working models of the program are created. Object oriented design techniques reflect the evolutionary aspect of software development. The steps of analysis, design, and implementation used in more traditional software development approaches, are still necessary, but the separation between them is blurred. And in each phase the design is more closely tied to real world objects found in the problem being solved.<p>
 The development of the hierarchy of classes used in this project followed this model, a prototype with a hierarchy of classes was created <a HREF="Refer.html#REF-18">[18]</a>. On this prototype many ideas were tried, some classes were moved up and down the class hierarchy. The position of a class in the hierarchy reflects how specialized the class is, the higher its position the more general a class is. Many classes where broken down, generally making a more general class, more useful to share behaviour, and a more specialized one, more useful to implement a specific task.<p>
 Through this interactive process, the basic hierarchy of classes shown on figure <a HREF="#nonexistent-marker">2.5</a> and <a HREF="#nonexistent-marker">2.6</a> was created. These figures show only the basic classes, shared by all programs (placement and routing included). <p>
 Other classes where created to support specific behaviours, and will be discussed in the following chapters, whenever needed. The following explanations about this class hierarchy are intended to give an overview of how the classes relate to each other and to show the basic foundations of the program. More specific topics about the program workings are not discussed.<p>
<a NAME="HEADING1-93"></a>
<h2>2.7.1    <a NAME="MARKER-9-7"></a>The Object class</h2>
 The root class of figure <a HREF="#nonexistent-marker">2.5</a>, <code>Object</code>, has the basic virtual functions shared by almost all other classes. Those functions allow a very high level of polymorphism, they allow basic functions to be performed by objects regardless of their types. The declaration of those public functions is:<p>
<pre>
class Object{
   ...
public:
 virtual   void   operator=(const Object&amp;);
 virtual   Object&amp;   copy() const;
 virtual   Type&amp;   type() const;
 virtual   Boolean   relate(const Symbol&amp;, const Object&amp;) const;
 virtual   void   print(ostream&amp;) const;
};

<a NAME="FIG-5"><img SRC="objects5.gif" WIDTH="767" HEIGHT="606"><p></a>
</pre>
 The five basic operations all objects should perform are then:<p>
<ul>
<li><b>Equal</b> - The <code>operator=</code> overloads the normal C++ operator = to perform the operation defined in the function. In this case, creating an equal operator that is performed by any object on any other object, regardless of type. Of course, if the two objects involved in the operation do not support it between themselves an error will be signalled.<p>
<li><b>Copy</b> - Creates a copy of the object and returns a pointer to it.<p>
<li><b>Type</b> - Returns the type of the object.<p>
<li><b>Relate</b> - Takes two arguments, the first is a symbol representing a relationship, the second an object. If the object receiving this stimulus has the relationship represented by symbol with the object in the function's second argument, it returns true.<p>
<li><b>Print</b> - Prints a representation of the object on the stream provided. A stream can be almost any character device, such as the screen, a file or a socket.<p>
</ul>
 These five functions allow a more general treatment for the various objects in the program. They allow, for instance, that general set classes, like the class List, perform their functions not actually knowing which kind of objects they hold. In this way more work can be performed by general classes, reducing complexity.<p>
<a NAME="HEADING1-113"></a>
<h2>2.7.2    Second hierarchical layer</h2>
 The second layer in the hierarchy has three classes:<p>
<ul>
<li><b>IregObj</b> - Holds unusual objects that do not implement all or part of the virtual functions defined in the class <code>Object</code>. It is used for debugging purposes only.<p>
<li><b>RealObj</b> - The classes derived from <code>RealObj</code> hold the basic data structures: type, numbers, strings, numbers and Null (a class representing NULL).<p>
<li><b>OwnObj</b> - Classes derived from <code>OwnObj</code> are set structures formed by other objects. For example: class <code>Pt</code> (point) is formed by two objects of class <code>Int</code> (integer), class <code>Linea</code> (line) is formed by two objects from <code>Pt</code>.<p>
</ul>
 In Agents, design information is stored in different kinds of list objects, some store whole designs (<code>DesignCmp</code>) other just a simple wire (<code>Wire</code>). When one of this list objects is deleted all memory allocated to hold its elements should be deallocated. As C++ does not have any automatic garbage collection facility, it is the programmer's responsibility to ensure that all the allocated memory is deallocated when its space is no longer necessary. Objects from classes derived from <code>OwnObj</code> can &quot;own&quot; the objects inside them. This means that they will do all the memory management, creating and destroying objects whenever necessary. If an object is &quot;owned&quot; by another, there are mechanisms for not allowing any other object to destroy it. This solution is more efficient than Lisp style garbage collection and it takes care of almost all memory management problems.<p>
<a NAME="HEADING1-119"></a>
<h2>2.7.3    The other layers</h2>
 The first two layers hold virtual classes, classes that only hold functionality for the use of derived classes. It is not possible to create objects belonging to them. From the third level onwards almost all classes are non-virtual, there are objects belonging to them. On the left of figure <a HREF="#nonexistent-marker">2.5</a> is shown the main <code>RealObj</code> derived classes:<p>
<ul>
<li><b>Type</b> - Holds the type of an object.<p>
<li><b>Number</b> - A virtual class that holds basic functionality for numbers. The actual number classes, <code>Int</code> for integers, <code>Real</code> for real numbers and <code>Ptr</code> for pointers, are derived from it.<p>
<li><b>Null</b> - A class that represents the NULL value.<p>
<li><b>String</b> - A class which holds and manipulates strings. The class <code>Symbol</code> is derived from it, <code>Symbol</code> is a special kind of string that can not be changed once created.<p>
</ul>
 On the left side of figure <a HREF="#nonexistent-marker">2.5</a>, the main <code>OwnObj</code> derived classes are shown:<p>
<ul>
<li><b>List</b> - Holds a linked list of objects. There is also a template class called <code>Lst</code> that creates specialized lists for any kind of object, for example <code>Lst&lt;Int&gt;</code> for <code>Int</code> objects and <code>Lst&lt;Pt&gt;</code> for <code>Pt</code> objects.<p>
<li><b>ViewObj</b> - This is a virtual class for viewer objects. An object is said to be a viewer when it points to another object and its methods modify this object. Through the viewer methods other objects can interface with the viewed object as if it had another completely different interface (or view). <code>ViewLst</code> is a specialization of <code>ViewObj</code> to deal with lists.<p>
<li><b>Pt, Linea, Segment and Rectangle</b> - These are the basic geometric classes, that hold basic geometric figures, respectively, point, line, segment and rectangle.<p>
<li><b>Component</b> - The class describes the components found in the design.<p>
</ul>
<a NAME="HEADING1-130"></a>
<h2>2.7.4    <a NAME="MARKER-9-8"></a>Design classes</h2>
 An important part of the general class hierarchy (fig. <a HREF="#nonexistent-marker">2.5</a>) are the classes dealing with the design representation under <code>Component</code> and <code>List</code> classes, shown in figure <a HREF="#nonexistent-marker">2.6</a>. Note that the hierarchy of classes representing the design is based upon OOP requirements it does not necessarily resemble a design hierarchy. The hierarchy can be divided in three groups:<p>
<ul>
<li><b>Components</b> - The four classes derived from the <code>Component</code> class describe the components found in the design: MOS and bipolar transistors, I/O pads and electric nodes. They hold information such as the I/O pads of each component and the component's layout description.<p>
<a NAME="FIG-6"><img SRC="objects6.gif" WIDTH="663" HEIGHT="450"><p></a>
<li><b>Wire</b> - This class describes layout as a list of rectangles belonging to various layers that form a particular connection. It is used by <code>Component</code> objects to describe the components layout.<p>
<li><b>Design</b> - The class <code>DesignCmp</code> holds the designs. It is basically a list of objects derived from class <code>Component</code> and a rich set of functions to manipulate them.<p>
</ul>
 These classes are extensively used by the objects dealing with the placement and routing.<p>
<a NAME="HEADING1-136"></a>
<h2>2.7.5    The Agents' library organization</h2>
 Apart from these two hierarchies there are many more classes in Agents, divided in groups of libraries (fig. <a HREF="#nonexistent-marker">2.7</a>):<p>
<a NAME="FIG-7"><img SRC="objects7.gif" WIDTH="717" HEIGHT="598"><p></a>
<ul>
<li><b>Basic functions</b> - These libraries provide the basic functionality for strings, lists, streams (genlib.h); socket (TCP/IP) communications (socklib.h); and lexical functions (langlib.h).<p>
<li><b>Basic Objects </b>- These libraries, basiclib.h, varlib.h and geomelib.h, provide the basic object hierarchy (shown in section <a HREF="#MARKER-9-7">2.7.1</a>).<p>
<li><b>Edif objects</b> - The ediflib.h library provides the basic capability to read the EDIF language.<p>
<li><b>Expert Agents</b> - The basic expert system capabilities, used in the agent expert systems, come from the experlib.h library.<p>
<li><b>Basic design representation</b> - The library complib.h provides the hierarchy shown in section <a HREF="#MARKER-9-8">2.7.4</a> and the basic classes to deal with design rules constraints.<p>
<li><b>Router Server</b> - Functionality exclusive to the router server (router.h).<p>
<li><b>Placer Server</b> - Functionality exclusive to the placer server (placer.h).<p>
</ul>
 The following chapters will explore in more depth the functionality and classes in these libraries. The above hierarchy just tries to give an overview of the program organization.<p>
 <p>
 <p>
<dl>
<dt><a HREF="objects.html#HEADING1-1"><b>2.1 </b> - Introduction</a><dd>
<dt><a HREF="objects.html#HEADING1-7"><b>2.2 </b> - Objects</a><dd>
<dt><a HREF="objects.html#HEADING1-16"><b>2.3 </b> - Class</a><dd>
<dt><a HREF="objects.html#HEADING1-21"><b>2.4 </b> - Inheritance</a><dd>
<dt><a HREF="objects.html#HEADING1-24"><b>2.4.1   </b> - Multiple inheritance</a><dd>
<dt><a HREF="objects.html#HEADING1-27"><b>2.5 </b> - Polymorphism</a><dd>
<dt><a HREF="objects.html#HEADING1-31"><b>2.6 </b> - Object Oriented Programming</a><dd>
<dt><a HREF="objects.html#HEADING1-40"><b>2.6.1   </b> - Objects</a><dd>
<dt><a HREF="objects.html#HEADING1-44"><b>2.6.2   </b> - Classes and instances</a><dd>
<dt><a HREF="objects.html#HEADING1-59"><b>2.6.3   </b> - Inheritance between classes</a><dd>
<dt><a HREF="objects.html#HEADING1-69"><b>2.6.4   </b> - Polymorphism</a><dd>
<dt><a HREF="objects.html#HEADING1-87"><b>2.7 </b> - Agents' basic structure</a><dd>
<dt><a HREF="objects.html#HEADING1-93"><b>2.7.1   </b> - The Object class</a><dd>
<dt><a HREF="objects.html#HEADING1-113"><b>2.7.2   </b> - Second hierarchical layer</a><dd>
<dt><a HREF="objects.html#HEADING1-119"><b>2.7.3   </b> - The other layers</a><dd>
<dt><a HREF="objects.html#HEADING1-130"><b>2.7.4   </b> - Design classes</a><dd>
<dt><a HREF="objects.html#HEADING1-136"><b>2.7.5   </b> - The Agents' library organization</a><dd>
</dl>

<hr>

<pre><h3><a HREF="agents.html"><b><img SRC="next.gif" WIDTH="40" HEIGHT="40"> Next</a>            <a HREF="contents.html"><b><img SRC="book.gif" WIDTH="40" HEIGHT="40"> Contents</a>       <a HREF="mailto:d.moreira@ieee.org"><b><img SRC="comments.gif" WIDTH="40" HEIGHT="40"> Talk to me</a></h3></pre>

</body>
</html> 