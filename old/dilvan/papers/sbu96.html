<html> <head>
<title>SBMicro-96</title>
</head>
<body BGCOLOR="FFFFFF">
<a NAME="HEADING1"></a>
<p>
<center>
<h1>Using the Genetic Algorithm for Placement in Leaf Cells</h1>
<br>
<br>
<br>
 <font SIZE="4"><i>Dilvan de Abreu Moreira</i></font><p>
<img SRC="sbu96-1.gif" WIDTH="336" HEIGHT="74"><p>
 <b>Correspondence to:</b><br>
 Email: dilvan@lcaee.fee.unicamp.br<br>
 Phone: (+55 192) 397680 ext:298<br>
 Fax: (+55 192) 391395 att: Dilvan-DSIF<p>
<br><br> <p>
 <font SIZE="4"><i>Les T. Walczowski</i></font><p>
<img SRC="sbu96-2.gif" WIDTH="218" HEIGHT="52"><p>
 Electronics Engineering Laboratories<br>
 The University, Canterbury - Kent<br>
 CT2 7NT - United Kingdom<br>
 Email: ltw@ukc.ac.uk<p>
<br>
<br>
<h2>ABSTRACT</h2>
</center>
 The genetic algorithm mimics natural evolution to solve problems in a wide variety of domains. It is particularly suitable for solving complex, search intensive, optimization problems, like the placement of component cells of a leaf cell. It has been used in the placement server of a distributed leaf cell generator, it can place CMOS, BICMOS, bipolar and mixed analogue/digital cells. Because the genetic algorithm does not make assumptions or impose restrictions upon the type of layout or circuit being optimized, it can place unusual layouts and work with a richer set of layout options.<p>
 <p>
<a NAME="HEADING1-18"></a>
<br>
<br>
<h2>1  Introduction</h2>
 In nature, individuals best suited to competition for scanty resources survive. Evolving to keep adapted to a changing environment is essential for the members of any species. Although evolution manifests itself as changes in the species' features, it is in the species' genetical material that those changes are controlled and stored. The force working for evolution's success is the genetic algorithm. It solves the problem of producing species able to thrive in a particular environment <a HREF="#MARKER-9-7">[1]</a>.<p>
 The genetic algorithm, first proposed by Holland in 1975 <a HREF="#MARKER-9-8">[2]</a>, mimics natural evolution to solve problems in a wide variety of domains <a HREF="#MARKER-9-9">[3]</a>. It is particularly suitable for solving complex, search intensive, optimization problems, like the placement of component cells in a leaf cell. Leaf cells are subcircuits of a complexity comparable with SSI (Small Scale Integration) components such as one-bit adders, flip-flops or multiplexers, that form circuit libraries.<p>
<a NAME="HEADING1-21"></a>
<h2>2  The algorithm</h2>
 The genetic algorithm is formed by a set of individual elements (the population) and a set of biological inspired operators, that can change these individuals. According to evolutionary theory, only the individuals that are the more suited in the population are likely to survive and to generate off-springs, thus transmitting their biological heredity to new generations.<p>
 In computing terms, the genetic algorithm maps strings of numbers to each potential solution. Each solution becomes an individual in the population, and each string becomes a representation of an individual. There should be a way to derive each individual from its string representation. The genetic algorithm then manipulates the most promising strings in its search for an improved solution. <p>
 The algorithm operates through a simple cycle, shown in figure <a HREF="#fig3">1</a>. On each cycle, a new generation of possible solutions (individuals) for a given problem is produced. At the first stage, a population of possible solutions is created as a start point. Each individual in this population is encoded into a string (the chromosome) to be manipulated by the genetic operators. In the next stage, the individuals are evaluated, first the individual is created from its string description (its chromosome) and its performance in relation to a target response is evaluated. This determines how fit this individual is in relation to the others in the population. Based on each individual's fitness, a selection mechanism chooses the best pairs for the genetic manipulation process. The selection policy is responsible to assure the survival of the fittest individuals. Genetic operators are then used to produce new populations of individuals, the offspring, by manipulating the genetic information possessed by the pairs chosen to reproduce. This information is stored in the strings (chromosomes) that describe the individuals. <p>
<a NAME="fig3"></a><center><img SRC="sbu96-3.gif" width="550" height="284">
<p>
<h4>Figure 1: The &quot;reproduction&quot; cycle.</h4></center>

 The two main genetic operators used are crossover and mutation. The offspring generated by this process take the place of the older population and the cycle is repeated until a desired level of fitness is attained or a determined number of cycles is reached.<p>

<a NAME="HEADING1-26"></a>
<h3> Genetic operators</h3>
<ul>
<li>Crossover is one of the genetic operators used to recombine the population genetic material. It takes two chromosomes and swaps part of their genetic information to produce new chromosomes. This operation is similar to sexual reproduction in nature. As figure <a HREF="#fig4">2</a> shows, after the crossover point has been randomly chosen, portions of the parent's chromosome (<b>Parent 1</b> and <b>Parent 2)</b> are combined to produce the new offspring <b>Son</b>. The selection process associated with the recombination made by crossover assures that special genetic structures, called building blocks, are retained for future generations. These building blocks represent the most fit genetic structures in the population. <p>
<a NAME="fig4"></a><center><img SRC="sbu96-4.gif" WIDTH="414" HEIGHT="161">
<p>
<h4>Figure 2: Crossover.</h4></center>

<li>Mutation is used because the recombination process alone cannot explore search space sections not represented in the population's genetic structures. This could make the search get stuck around local minima. The mutation operator introduces new genetic structures in the population by randomly changing some of its building blocks, helping the algorithm escape local minima traps. Since the modification is totally random and thus not related to any previous genetic structures present in the population, it creates different structures related to other sections of the search space. As shown in figure
 <a HREF="#fig5">3</a>, mutation is implemented by occasionally altering a random part of a chromosome.<p>
<a NAME="fig5"></a><center><img SRC="sbu96-5.gif" WIDTH="190" HEIGHT="141">
<p>
<h4>Figure 3: Mutation.</h4></center>

</ul>
 A number of other operators, other than crossover and mutation, have been introduced since the basic model was proposed. They are usually versions of the recombination and genetic alterations processes adapted to constraints of a particular problem. <p>

<a NAME="HEADING1-30"></a>
<h3> Problem dependent parameters</h3>
 This description of the genetic algorithms' computational model reviews the steps needed to create the algorithm. However, a real implementation takes account of a number of problem-dependent parameters:<p>
<ul>
<li>The choice of the underlying encoding of the individuals on the population is critical to the algorithm performance. It is desirable that the encoding makes the representation as robust as possible. This means that even if a piece of the representation is randomly changed, in the majority of cases, it should still represent a viable individual.<p>
<li>The evaluation is a step closely related to the actual system the algorithm is trying to optmize. It takes the strings representing the individuals of the population and, from them, creates the actual individuals and test and score them. The testing depends on what characteristics should be optimized and the scoring depends on the relative importance of each different characteristic value obtained during testing<p>
</ul>
 Other parameters to be adjusted are the population size, crossover and mutation rates, evaluation method, and convergence criteria. <p>
<a NAME="HEADING1-35"></a>
<h2>3  The placement problem</h2>
 The genetic algorithm is used, in the placement program of the Agents <a HREF="#MARKER-9-10">[4]</a> system, to place groups of cells in a mask layout area forming a circuit cell. The inputs to the algorithm are an empty design area and a list holding the groups of cells to be placed. There are three kinds of groups of cells: arrays of MOSFETs, a list of bipolar transistors and individual general cells. The program generates some placed circuits that are then sent to the routing servers. The first placement successfully routed becomes the final circuit.<p>
 The algorithm works in the same way as described in the last section, which leaves the problem dependent parameters, encoding and evaluation, to be defined.<p>
<a NAME="HEADING1-38"></a>
<h3> Encoding</h3>
 In the coding used in this application, the chromosome is not represented by a string, as would be expected, but by a list. This is done to avoid Hamming cliffs <a HREF="#MARKER-9-9">[3]</a> and to enhance robustness. The elements of this list represent each group being laid out in the cell, with the groups laid out in the same order as they appear in the list. For each group there is another list describing how that particular group should be laid out:<p>
<pre>
Chromosome: [ Group 0, Group 1, Group 2, ..., Group n]
Group: [Group number, Flip flag, [Line 0, Line 1, ..., Line n], Dx, Dy, Gap]
</pre>
<ul>
<li><b>Group number</b> is the group's identification.<p>
<li><b>Flip flag</b> indicates if the group is to be mirrored in the Y axis.<p>
<li><b>Line list</b> is a list with the order that the lines in the group should be laid out. <p>
<li><b>Dx</b> represents the distance between this group and the last group laid out.<p>
<li><b>Dy</b> represents the distance between the group and the Y axis.<p>
<li><b>Gap</b> is the gap added to the minimum separation between a cell's transistors.<p>
</ul>
 With the information provided by the chromosomes, the individual, shown in figure <a HREF="#fig6">4</a>, can be laid out on a cell, in this case, containing only the pads (Vss, Vee, Input and Output).<p>
<a NAME="fig6"></a><center><img SRC="sbu96-6.gif" WIDTH="588" HEIGHT="373">
<p>
<h4>Figure 4: Coding schema.</h4></center>
 The way the encode is undertaken can affect the mutation and cross-over operations. Cross-over is carried out by swapping sets of elements in the lists (what is similar to swap parts of a string), and mutation is undertaken by changing randomly the composition of list elements, such as the Flip flag. Cross-over and mutation operations can generate illegal individuals. Illegal meaning placements that violate design rules. When evaluated they will be classified as &quot;born dead&quot; individuals and will not be added to the population list.<p>

<a NAME="HEADING1-50"></a>
<h3> Evaluation</h3>
 The new individuals created should be evaluated to find how good their placement is. The best way of doing the evaluation would be by actually routing each placement. Unfortunately the routing process is slow and would take too long to evaluate all candidates. In place of full routing a method is used to estimate the cost of wiring the circuit. It uses the same wiring algorithms, that a router uses, but it allows crossing over and short circuits to take place, and it does not test for design rule violations. As the evaluation pseudo routing takes place, the cost of the wires is being computed. At the end, the evaluation routine has the total cost of the pseudo routing and the total number of crossings. <p>
 After evaluation, each placement or &quot;individual&quot; has it fitness calculated from two values: the total wire cost and the number of crossings. The whole population of individuals is kept in a list, which is ordered by fitness, the fittest individuals coming first in the list. New individuals are continuously appended to the population list. When the population reaches a predetermined maximum number, half of it is killed.<p>
 The fitness of an individual, and thus its position in the population list, determines its probability of reproduction and death. As the position of an individual in the population list increases, its probability of reproduction decreases and its probability of death increases.<a NAME="MARKER-9-6"></a><p>
<a NAME="HEADING1-54"></a>
<h3>The algorithm implementation</h3>
 Once encoding and evaluation are defined the actual algorithm implementation is basically that described earlier. The inputs for the program are an empty design and a list holding the groups of cells to be placed. The routine first generates four individuals, by placing the cells in them randomly. These individuals are then evaluated and classified and become the population.<p>
 The program then runs a certain number of generations or cycles (fig. <a HREF="#fig3">1</a>). When it finishes it sends the placed circuit to be wired by a router. It continues to generate new placements of the same circuit until one of the routers manages to successful wire one of then. An example of a placed circuit is shown in figure <a HREF="#fig7">5</a>.<p>
<a NAME="fig7"></a><center><img SRC="sbu96-7.gif" WIDTH="483" HEIGHT="273">
<p>
<h4>Figure 5: A placed circuit.</h4></center>



<a NAME="HEADING1-57"></a>
<h2>4  Conclusion</h2>
 The genetic algorithm is a very powerful and flexible optimization algorithm. Its use in the Agents system placer demonstrated that it can generate layout flexibly, as it can place CMOS, BICMOS and mixed analogue/digital leaf cells. Because the algorithm does not make assumptions or impose restrictions upon the type of layout or circuit being placed, it can place unusual layouts and work with a richer set of layout options.<p>
<a NAME="HEADING1-59"></a>
<h2>5  Acknowledgments</h2>
 The authors would like to acknowledge, the CNPq - National Council for Research an agency of the Brazilian Federal Government, for the financial support for this work.<p>
<a NAME="HEADING1-61"></a>
<h2>6  References</h2>
<dl COMPACT>
<dt>[1]<dd>  <a NAME="MARKER-9-7"></a>C.T. Walbridge, &quot;Genetic Algorithms: What Computers Can Learn from Darwin&quot;, <i>Technology Review</i>, January 1989<i>,</i> pp. 47-53.<p>
<dt>[2]<dd>  <a NAME="MARKER-9-8"></a>J.H. Holland, <i>Adaptation in Natural and Artificial Systems,</i> Univ. of Michigan Press, Ann Arbor, Mich. 1975.<p>
<dt>[3]<dd>  <a NAME="MARKER-9-9"></a>J.L. Ribeiro Filho, P.C. Treleaven and C. Alippi, &quot;Genetic-Algorithm Programming Environments&quot;, <i>Computer,</i> vol. 27, no. 6, June 1994, pp. 28-43.<p>
<dt>[4]<dd>  <a NAME="MARKER-9-10"></a>D.A. Moreira and L.T. Walczowski, &quot;Automated Placement for a Leaf Cell Generator&quot;, <i>ISCAS 94, Proc. of the IEEE Inter. Symposium on Circuits and Systems,</i> June 1994, vol. 1, pp 117-120.<p>

</body>
</html> 
